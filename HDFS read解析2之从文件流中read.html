<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="google-site-verification" content="0hClWroWscvQbyOyRPhAZWjOZJ6g3SFCdO47yYakvdk">







  <meta name="baidu-site-verification" content="27E5EbutCm">







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="BigData,Hadoop,HDFS,read,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="上篇主要记录了HDFS read打开一个文件流的流程，该篇记录下从打开的文件流里read数据的流程。">
<meta name="keywords" content="BigData,Hadoop,HDFS,read">
<meta property="og:type" content="article">
<meta property="og:title" content="HDFS read解析2之从文件流中read">
<meta property="og:url" content="http://bigdatadecode.club/HDFS read解析2之从文件流中read.html">
<meta property="og:site_name" content="big data decode club">
<meta property="og:description" content="上篇主要记录了HDFS read打开一个文件流的流程，该篇记录下从打开的文件流里read数据的流程。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2016-11-15T13:11:31.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HDFS read解析2之从文件流中read">
<meta name="twitter:description" content="上篇主要记录了HDFS read打开一个文件流的流程，该篇记录下从打开的文件流里read数据的流程。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://bigdatadecode.club/HDFS read解析2之从文件流中read.html">





  <title> HDFS read解析2之从文件流中read | big data decode club </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-80813521-1', 'auto');
  ga('send', 'pageview');
</script>








  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1260961002&web_id=1260961002" language="JavaScript"></script>
  </div>






  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">big data decode club</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">hunhun -- Any answers you can find in source code.</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://bigdatadecode.club/HDFS read解析2之从文件流中read.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="混绅士">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="big data decode club">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                HDFS read解析2之从文件流中read
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-15T21:11:31+08:00">
                2016-11-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2016-11-15T21:11:31+08:00">
                2016-11-15
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Hadoop/" itemprop="url" rel="index">
                    <span itemprop="name">Hadoop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/HDFS read解析2之从文件流中read.html" class="leancloud_visitors" data-flag-title="HDFS read解析2之从文件流中read">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><a href="http://bigdatadecode.club/HDFS read解析.html">上篇</a>主要记录了HDFS read打开一个文件流的流程，该篇记录下从打开的文件流里read数据的流程。</p>
<a id="more"></a>
<h2 id="HDFS-Read之从文件流中read"><a href="#HDFS-Read之从文件流中read" class="headerlink" title="HDFS Read之从文件流中read"></a>HDFS Read之从文件流中read</h2><p>读取文件流中的数据通过文件流FSDataInputStream对象的read方法进行读取，最终调用了DFSInputStream的read方法(可以写个hdfs read file demo 进行debug下就会发现)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span> buf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// ReaderStrategy 将不同的BlockReader进行了封装</span></span><br><span class="line">  <span class="comment">// 真正读数据的是BlockReader对象</span></span><br><span class="line">  ReaderStrategy byteArrayReader = <span class="keyword">new</span> ByteArrayStrategy(buf);</span><br><span class="line">  <span class="keyword">return</span> readWithStrategy(byteArrayReader, off, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">readWithStrategy</span><span class="params">(ReaderStrategy strategy, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  Map&lt;ExtendedBlock,Set&lt;DatanodeInfo&gt;&gt; corruptedBlockMap </span><br><span class="line">    = <span class="keyword">new</span> HashMap&lt;ExtendedBlock, Set&lt;DatanodeInfo&gt;&gt;();</span><br><span class="line">  failures = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (pos &lt; getFileLength()) &#123;</span><br><span class="line">    <span class="keyword">int</span> retries = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (retries &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// currentNode can be left as null if previous read had a checksum</span></span><br><span class="line">        <span class="comment">// error on the same block. See HDFS-3067</span></span><br><span class="line">        <span class="comment">// pos 和 blockEnd 会在blockSeekTo -&gt; getBlockAt 中赋值</span></span><br><span class="line">        <span class="keyword">if</span> (pos &gt; blockEnd || currentNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 当前position所在的block</span></span><br><span class="line">          currentNode = blockSeekTo(pos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> realLen = (<span class="keyword">int</span>) Math.min(len, (blockEnd - pos + <span class="number">1L</span>));</span><br><span class="line">        <span class="keyword">if</span> (locatedBlocks.isLastBlockComplete()) &#123;</span><br><span class="line">          realLen = (<span class="keyword">int</span>) Math.min(realLen, locatedBlocks.getFileLength());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读取buffer</span></span><br><span class="line">        <span class="keyword">int</span> result = readBuffer(strategy, off, realLen, corruptedBlockMap);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (result &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          pos += result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// got a EOS from reader though we expect more data on it.</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected EOS from the reader"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dfsClient.stats != <span class="keyword">null</span>) &#123;</span><br><span class="line">          dfsClient.stats.incrementBytesRead(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        <span class="comment">// 如果检测到ChecksumException 则只抛出异常，再次进行循环</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (ChecksumException ce) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ce;    </span><br><span class="line">        <span class="comment">// 如果捕获到IO异常，则retries次数减1，进入下一次循环        </span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries == <span class="number">1</span>) &#123;</span><br><span class="line">          DFSClient.LOG.warn(<span class="string">"DFS Read"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        blockEnd = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (currentNode != <span class="keyword">null</span>) &#123; addToDeadNodes(currentNode); &#125;</span><br><span class="line">        <span class="keyword">if</span> (--retries == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Check if need to report block replicas corruption either read</span></span><br><span class="line">        <span class="comment">// was successful or ChecksumException occured.</span></span><br><span class="line">        reportCheckSumFailure(corruptedBlockMap, </span><br><span class="line">            currentLocatedBlock.getLocations().length);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>readWithStrategy会重试2次进行读取，<em>如果捕获到<code>ChecksumException</code>则直接进行重试(本次尝试不计数)</em>，当捕获到<code>IOException</code>异常时会进行重试(尝试次数减1)，重新选择dn进行读取，并把有io异常的dn放入deadNodes map中。<strong>一个block一个deadNodes？？？</strong></p>
<p><strong>deadNodes是DFSInputStream的属性，则应该是一个DFSInputStream一个deadNodes，但是在读取一个block结束之后，deadNodes会不会被clear掉？？读取失败之后会clear deadNodes</strong></p>
<p>readWithStrategy中主要有两个方法，分别是<code>blockSeekTo</code>和<code>readBuffer</code>，blockSeekTo是找到当前pos的block，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> DatanodeInfo <span class="title">blockSeekTo</span><span class="params">(<span class="keyword">long</span> target)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Connect to best DataNode for desired Block, with potential offset</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  DatanodeInfo chosenNode = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">int</span> refetchToken = <span class="number">1</span>; <span class="comment">// only need to get a new access token once</span></span><br><span class="line">  <span class="keyword">int</span> refetchEncryptionKey = <span class="number">1</span>; <span class="comment">// only need to get a new encryption key once</span></span><br><span class="line">  <span class="keyword">boolean</span> connectFailedOnce = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Compute desired block</span></span><br><span class="line">    <span class="comment">//得到target所在的dn locations信息</span></span><br><span class="line">    LocatedBlock targetBlock = getBlockAt(target, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">assert</span> (target==pos) : <span class="string">"Wrong postion "</span> + pos + <span class="string">" expect "</span> + target;</span><br><span class="line">    <span class="keyword">long</span> offsetIntoBlock = target - targetBlock.getStartOffset();</span><br><span class="line">    <span class="comment">// 从dn set中选出一个dn</span></span><br><span class="line">    DNAddrPair retval = chooseDataNode(targetBlock, <span class="keyword">null</span>);</span><br><span class="line">    chosenNode = retval.info;</span><br><span class="line">    InetSocketAddress targetAddr = retval.addr;</span><br><span class="line">    StorageType storageType = retval.storageType;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ExtendedBlock blk = targetBlock.getBlock();</span><br><span class="line">      Token&lt;BlockTokenIdentifier&gt; accessToken = targetBlock.getBlockToken();</span><br><span class="line">      <span class="comment">// 使用 Builder模式 创建一个 blockReader</span></span><br><span class="line">      blockReader = <span class="keyword">new</span> BlockReaderFactory(dfsClient.getConf()).</span><br><span class="line">          setInetSocketAddress(targetAddr).</span><br><span class="line">          setRemotePeerFactory(dfsClient).</span><br><span class="line">          setDatanodeInfo(chosenNode).</span><br><span class="line">          setStorageType(storageType).</span><br><span class="line">          setFileName(src).</span><br><span class="line">          setBlock(blk).</span><br><span class="line">          setBlockToken(accessToken).</span><br><span class="line">          setStartOffset(offsetIntoBlock).</span><br><span class="line">          setVerifyChecksum(verifyChecksum).</span><br><span class="line">          setClientName(dfsClient.clientName).</span><br><span class="line">          setLength(blk.getNumBytes() - offsetIntoBlock).</span><br><span class="line">          setCachingStrategy(cachingStrategy).</span><br><span class="line">          setAllowShortCircuitLocalReads(!shortCircuitForbidden()).</span><br><span class="line">          setClientCacheContext(dfsClient.getClientContext()).</span><br><span class="line">          setUserGroupInformation(dfsClient.ugi).</span><br><span class="line">          setConfiguration(dfsClient.getConfiguration()).</span><br><span class="line">          build();</span><br><span class="line">      <span class="keyword">if</span>(connectFailedOnce) &#123;</span><br><span class="line">        DFSClient.LOG.info(<span class="string">"Successfully connected to "</span> + targetAddr +</span><br><span class="line">                           <span class="string">" for "</span> + blk);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> chosenNode;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> InvalidEncryptionKeyException &amp;&amp; refetchEncryptionKey &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        DFSClient.LOG.info(<span class="string">"Will fetch a new encryption key and retry, "</span> </span><br><span class="line">            + <span class="string">"encryption key was invalid when connecting to "</span> + targetAddr</span><br><span class="line">            + <span class="string">" : "</span> + ex);</span><br><span class="line">        <span class="comment">// The encryption key used is invalid.</span></span><br><span class="line">        refetchEncryptionKey--;</span><br><span class="line">        dfsClient.clearDataEncryptionKey();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (refetchToken &gt; <span class="number">0</span> &amp;&amp; tokenRefetchNeeded(ex, targetAddr)) &#123;</span><br><span class="line">        refetchToken--;</span><br><span class="line">        <span class="comment">// Fetch a block from namenode and cache it ????</span></span><br><span class="line">        fetchBlockAt(target);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        connectFailedOnce = <span class="keyword">true</span>;</span><br><span class="line">        DFSClient.LOG.warn(<span class="string">"Failed to connect to "</span> + targetAddr + <span class="string">" for block"</span></span><br><span class="line">          + <span class="string">", add to deadNodes and continue. "</span> + ex, ex);</span><br><span class="line">        <span class="comment">// Put chosen node into dead list, continue</span></span><br><span class="line">        addToDeadNodes(chosenNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>blockSeekTo主要包含两个方法和一个BlockReader的实例化对象，一个方法是<code>getBlockAt</code>，其作用是得到当前offset所在的block的dn locations信息，另一个方法是<code>chooseDataNode</code>，其作用是从<code>getBlockAt</code>得到的dn locations list中得到一个dn。getBlockAt的实现逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> LocatedBlock <span class="title">getBlockAt</span><span class="params">(<span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> updatePosition)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (locatedBlocks != <span class="keyword">null</span>) : <span class="string">"locatedBlocks is null"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> LocatedBlock blk;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//check offset</span></span><br><span class="line">  <span class="keyword">if</span> (offset &lt; <span class="number">0</span> || offset &gt;= getFileLength()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"offset &lt; 0 || offset &gt;= getFileLength(), offset="</span></span><br><span class="line">        + offset</span><br><span class="line">        + <span class="string">", updatePosition="</span> + updatePosition</span><br><span class="line">        + <span class="string">", locatedBlocks="</span> + locatedBlocks);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (offset &gt;= locatedBlocks.getFileLength()) &#123;</span><br><span class="line">    <span class="comment">// offset to the portion of the last block,</span></span><br><span class="line">    <span class="comment">// which is not known to the name-node yet;</span></span><br><span class="line">    <span class="comment">// getting the last block </span></span><br><span class="line">    blk = locatedBlocks.getLastLocatedBlock();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// search cached blocks first</span></span><br><span class="line">    <span class="comment">// 使用二分查找从缓存的block中查找当前offset所在的block</span></span><br><span class="line">    <span class="keyword">int</span> targetBlockIdx = locatedBlocks.findBlock(offset);</span><br><span class="line">    <span class="comment">// 在缓存中没有找到</span></span><br><span class="line">    <span class="keyword">if</span> (targetBlockIdx &lt; <span class="number">0</span>) &#123; <span class="comment">// block is not cached</span></span><br><span class="line">      targetBlockIdx = LocatedBlocks.getInsertIndex(targetBlockIdx);</span><br><span class="line">      <span class="comment">// fetch more blocks</span></span><br><span class="line">      <span class="comment">// 再次抓取blocks，从当前offset处开始抓取</span></span><br><span class="line">      <span class="keyword">final</span> LocatedBlocks newBlocks = dfsClient.getLocatedBlocks(src, offset);</span><br><span class="line">      <span class="keyword">assert</span> (newBlocks != <span class="keyword">null</span>) : <span class="string">"Could not find target position "</span> + offset;</span><br><span class="line">      <span class="comment">// 将new block插入到缓存的targetBlockIdx位置中</span></span><br><span class="line">      locatedBlocks.insertRange(targetBlockIdx, newBlocks.getLocatedBlocks());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到offset所在的block  targetBlockIdx是block在缓存中的索引</span></span><br><span class="line">    blk = locatedBlocks.get(targetBlockIdx);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// update current position</span></span><br><span class="line">  <span class="comment">// 更新read的起始地址pos和结束地址blockEnd</span></span><br><span class="line">  <span class="keyword">if</span> (updatePosition) &#123;</span><br><span class="line">    pos = offset;</span><br><span class="line">    blockEnd = blk.getStartOffset() + blk.getBlockSize() - <span class="number">1</span>;</span><br><span class="line">    currentLocatedBlock = blk;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> blk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getBlockAt主要是得到offset所在的block，其检索方法是先在缓存(这个缓存大小是由<em>dfs.client.read.prefetch.size</em>决定的)中进行二分查找，找到就返回其索引，如果没有找到则再次调用rpc进行重新抓取block，<strong>此次抓取的block的是从offset所在block开始抓取的</strong>。下面看下<code>findBlock</code>的代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public int findBlock(long offset) &#123;</span><br><span class="line">  <span class="comment">// create fake block of size 0 as a key</span></span><br><span class="line">  <span class="comment">// 创建一个LocatedBlock对象，便于和LocatedBlocks中的block进行比较</span></span><br><span class="line">  <span class="type">LocatedBlock</span> key = <span class="keyword">new</span> <span class="type">LocatedBlock</span>(</span><br><span class="line">      <span class="keyword">new</span> <span class="type">ExtendedBlock</span>(), <span class="keyword">new</span> <span class="type">DatanodeInfo</span>[<span class="number">0</span>], <span class="number">0</span>L, <span class="literal">false</span>);</span><br><span class="line">  key.setStartOffset(offset);</span><br><span class="line">  key.getBlock().setNumBytes(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 重写comparator</span></span><br><span class="line">  <span class="type">Comparator</span>&lt;<span class="type">LocatedBlock</span>&gt; comp = </span><br><span class="line">    <span class="keyword">new</span> <span class="type">Comparator</span>&lt;<span class="type">LocatedBlock</span>&gt;() &#123;</span><br><span class="line">      <span class="comment">// Returns 0 iff a is inside b or b is inside a</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      public int compare(<span class="type">LocatedBlock</span> a, <span class="type">LocatedBlock</span> b) &#123;</span><br><span class="line">        long aBeg = a.getStartOffset();</span><br><span class="line">        long bBeg = b.getStartOffset();</span><br><span class="line">        long aEnd = aBeg + a.getBlockSize();</span><br><span class="line">        long bEnd = bBeg + b.getBlockSize();</span><br><span class="line">        <span class="keyword">if</span>(aBeg &lt;= bBeg &amp;&amp; bEnd &lt;= aEnd </span><br><span class="line">            || bBeg &lt;= aBeg &amp;&amp; aEnd &lt;= bEnd)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// one of the blocks is inside the other</span></span><br><span class="line">        <span class="keyword">if</span>(aBeg &lt; bBeg)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// a's left bound is to the left of the b's</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 调用Collections的二分查找</span></span><br><span class="line">  <span class="keyword">return</span> <span class="type">Collections</span>.binarySearch(blocks, key, comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>findBlock主要是利用Collections的二分查找进行查找offset所在的block，进行比较时先创建一个LocatedBlock对象，然后重写Comparator进行对象的比较。如果没有找到则调用<code>dfsClient.getLocatedBlocks</code>，从当前offset所在的block为起点进行再次抓取固定长度的block，并将newBlocks插入缓存中的blocks中。</p>
<p>抓取block是通过rpc调用dfsClient.getLocatedBlocks从FSNamesystem中获得blocks列表，然后通过<code>locatedBlocks.insertRange</code>插入到缓存中，locatedBlocks.insertRange代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertRange</span><span class="params">(<span class="keyword">int</span> blockIdx, List&lt;LocatedBlock&gt; newBlocks)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 返回在缓存中查找失败返回的low处的索引</span></span><br><span class="line">  <span class="keyword">int</span> oldIdx = blockIdx;</span><br><span class="line">  <span class="keyword">int</span> insStart = <span class="number">0</span>, insEnd = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 如果缓存blocks的最后一个元素依然小于目标block的offset时(也就是low=len+1)</span></span><br><span class="line">  <span class="comment">// 则不进入for循环</span></span><br><span class="line">  <span class="comment">// 找到目标block在newBlocks中的索引</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> newIdx = <span class="number">0</span>; newIdx &lt; newBlocks.size() &amp;&amp; oldIdx &lt; blocks.size(); </span><br><span class="line">                                                      newIdx++) &#123;</span><br><span class="line">    <span class="keyword">long</span> newOff = newBlocks.get(newIdx).getStartOffset();</span><br><span class="line">    <span class="keyword">long</span> oldOff = blocks.get(oldIdx).getStartOffset();</span><br><span class="line">    <span class="comment">// 当newBlocks</span></span><br><span class="line">    <span class="keyword">if</span>(newOff &lt; oldOff) &#123;</span><br><span class="line">      insEnd++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(newOff == oldOff) &#123;</span><br><span class="line">      <span class="comment">// replace old cached block by the new one</span></span><br><span class="line">      blocks.set(oldIdx, newBlocks.get(newIdx));</span><br><span class="line">      <span class="keyword">if</span>(insStart &lt; insEnd) &#123; <span class="comment">// insert new blocks</span></span><br><span class="line">        blocks.addAll(oldIdx, newBlocks.subList(insStart, insEnd));</span><br><span class="line">        oldIdx += insEnd - insStart;</span><br><span class="line">      &#125;</span><br><span class="line">      insStart = insEnd = newIdx+<span class="number">1</span>;</span><br><span class="line">      oldIdx++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// newOff &gt; oldOff</span></span><br><span class="line">      <span class="keyword">assert</span> <span class="keyword">false</span> : <span class="string">"List of LocatedBlock must be sorted by startOffset"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  insEnd = newBlocks.size();</span><br><span class="line">  <span class="comment">// 将大于目标block的blocks插入缓存中</span></span><br><span class="line">  <span class="keyword">if</span>(insStart &lt; insEnd) &#123; <span class="comment">// insert new blocks</span></span><br><span class="line">    blocks.addAll(oldIdx, newBlocks.subList(insStart, insEnd));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>insertRange将<em>newBlocks</em>中的block根据其在<em>blocks</em>中的顺序<em>分区间插入blocks中</em>。区间由insStart和insEnd控制，for循环中调整insEnd和insStart的值，分批次插入到blocks中。</p>
<p>此时就可以得到目标block的locations信息，通过<code>chooseDataNode</code>选择一个dn，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DNAddrPair <span class="title">chooseDataNode</span><span class="params">(LocatedBlock block,</span></span></span><br><span class="line"><span class="function"><span class="params">    Collection&lt;DatanodeInfo&gt; ignoredNodes)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getBestNodeDNAddrPair(block, ignoredNodes);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ie) &#123;</span><br><span class="line">      <span class="comment">// 捕获到getBestNodeDNAddrPair中chosenNode为null的异常之后</span></span><br><span class="line">      <span class="comment">// 清空deadNodes，重新获取该block的信息</span></span><br><span class="line">      <span class="comment">// 尝试3次，抛出异常</span></span><br><span class="line">      String errMsg = getBestNodeDNAddrPairErrorString(block.getLocations(),</span><br><span class="line">        deadNodes, ignoredNodes);</span><br><span class="line">      String blockInfo = block.getBlock() + <span class="string">" file="</span> + src;</span><br><span class="line">      <span class="comment">// dfs.client.max.block.acquire.failures 默认是3</span></span><br><span class="line">      <span class="comment">// 获取该block信息3次，注意与获取3次dn的区别</span></span><br><span class="line">      <span class="keyword">if</span> (failures &gt;= dfsClient.getMaxBlockAcquireFailures()) &#123;</span><br><span class="line">        String description = <span class="string">"Could not obtain block: "</span> + blockInfo;</span><br><span class="line">        DFSClient.LOG.warn(description + errMsg</span><br><span class="line">            + <span class="string">". Throwing a BlockMissingException"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BlockMissingException(src, description,</span><br><span class="line">            block.getStartOffset());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      DatanodeInfo[] nodes = block.getLocations();</span><br><span class="line">      <span class="keyword">if</span> (nodes == <span class="keyword">null</span> || nodes.length == <span class="number">0</span>) &#123;</span><br><span class="line">        DFSClient.LOG.info(<span class="string">"No node available for "</span> + blockInfo);</span><br><span class="line">      &#125;</span><br><span class="line">      DFSClient.LOG.info(<span class="string">"Could not obtain "</span> + block.getBlock()</span><br><span class="line">          + <span class="string">" from any node: "</span> + ie + errMsg</span><br><span class="line">          + <span class="string">". Will get new block locations from namenode and retry..."</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Introducing a random factor to the wait time before another retry.</span></span><br><span class="line">        <span class="comment">// The wait time is dependent on # of failures and a random factor.</span></span><br><span class="line">        <span class="comment">// At the first time of getting a BlockMissingException, the wait time</span></span><br><span class="line">        <span class="comment">// is a random number between 0..3000 ms. If the first retry</span></span><br><span class="line">        <span class="comment">// still fails, we will wait 3000 ms grace period before the 2nd retry.</span></span><br><span class="line">        <span class="comment">// Also at the second retry, the waiting window is expanded to 6000 ms</span></span><br><span class="line">        <span class="comment">// alleviating the request rate from the server. Similarly the 3rd retry</span></span><br><span class="line">        <span class="comment">// will wait 6000ms grace period before retry and the waiting window is</span></span><br><span class="line">        <span class="comment">// expanded to 9000ms. </span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> timeWindow = dfsClient.getConf().timeWindow;</span><br><span class="line">        <span class="keyword">double</span> waitTime = timeWindow * failures +       <span class="comment">// grace period for the last round of attempt</span></span><br><span class="line">          timeWindow * (failures + <span class="number">1</span>) * DFSUtil.getRandom().nextDouble(); <span class="comment">// expanding time window for each failure</span></span><br><span class="line">        DFSClient.LOG.warn(<span class="string">"DFS chooseDataNode: got # "</span> + (failures + <span class="number">1</span>) + <span class="string">" IOException, will wait for "</span> + waitTime + <span class="string">" msec."</span>);</span><br><span class="line">        Thread.sleep((<span class="keyword">long</span>)waitTime);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException iex) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 从block的所有dn中没有找到合适的dn，则将deadNodes清空，重新获取该block的信息</span></span><br><span class="line">      <span class="comment">// 一个block一个deadNodes</span></span><br><span class="line">      deadNodes.clear(); <span class="comment">//2nd option is to remove only nodes[blockId]</span></span><br><span class="line">      openInfo();</span><br><span class="line">      block = getBlockAt(block.getStartOffset(), <span class="keyword">false</span>);</span><br><span class="line">      failures++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> DNAddrPair <span class="title">getBestNodeDNAddrPair</span><span class="params">(LocatedBlock block,</span></span></span><br><span class="line"><span class="function"><span class="params">    Collection&lt;DatanodeInfo&gt; ignoredNodes)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  DatanodeInfo[] nodes = block.getLocations();</span><br><span class="line">  StorageType[] storageTypes = block.getStorageTypes();</span><br><span class="line">  DatanodeInfo chosenNode = <span class="keyword">null</span>;</span><br><span class="line">  StorageType storageType = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (nodes != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 遍历选出非deadNode节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!deadNodes.containsKey(nodes[i])</span><br><span class="line">          &amp;&amp; (ignoredNodes == <span class="keyword">null</span> || !ignoredNodes.contains(nodes[i]))) &#123;</span><br><span class="line">        chosenNode = nodes[i];</span><br><span class="line">        <span class="comment">// Storage types are ordered to correspond with nodes, so use the same</span></span><br><span class="line">        <span class="comment">// index to get storage type.</span></span><br><span class="line">        <span class="keyword">if</span> (storageTypes != <span class="keyword">null</span> &amp;&amp; i &lt; storageTypes.length) &#123;</span><br><span class="line">          storageType = storageTypes[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 循环了一圈依然没有找到合适的dn</span></span><br><span class="line">  <span class="keyword">if</span> (chosenNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"No live nodes contain block "</span> + block.getBlock() +</span><br><span class="line">        <span class="string">" after checking nodes = "</span> + Arrays.toString(nodes) +</span><br><span class="line">        <span class="string">", ignoredNodes = "</span> + ignoredNodes);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> String dnAddr =</span><br><span class="line">      chosenNode.getXferAddr(dfsClient.getConf().connectToDnViaHostname);</span><br><span class="line">  <span class="keyword">if</span> (DFSClient.LOG.isDebugEnabled()) &#123;</span><br><span class="line">    DFSClient.LOG.debug(<span class="string">"Connecting to datanode "</span> + dnAddr);</span><br><span class="line">  &#125;</span><br><span class="line">  InetSocketAddress targetAddr = NetUtils.createSocketAddr(dnAddr);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DNAddrPair(chosenNode, targetAddr, storageType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>chooseDataNode调用<code>getBestNodeDNAddrPair</code>在<em>block的locations中选择一个dn</em>，如果没有找到则抛出一个<em>IOException异常</em>，在chooseDataNode中捕获，在catch中校验重试次数是否超过<code>dfs.client.max.block.acquire.failures</code>，没有则清空deadNodes再次去获取该block的locations。依然失败则抛出异常。</p>
<p>chooseDataNode结束返回到blockSeekTo中，由BlockReaderFactory创建BlockReader对象，这里创建的BlockReader对象会根据<em>short circuit local read</em>还是<em>远程读</em>创建不同的BlockReader。BlockReaderFactory使用了Builder设计模式，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BlockReader <span class="title">build</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  BlockReader reader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  Preconditions.checkNotNull(configuration);</span><br><span class="line">  <span class="comment">// 检查是否开启了short circuit local read</span></span><br><span class="line">  <span class="comment">// short circuit local read 使用的就是 Unix Domain Socket技术，</span></span><br><span class="line">  <span class="comment">// 那为什么还要将conf.domainSocketDataTraffic作为一个备选方案</span></span><br><span class="line">  <span class="keyword">if</span> (conf.shortCircuitLocalReads &amp;&amp; allowShortCircuitLocalReads) &#123;</span><br><span class="line">    <span class="keyword">if</span> (clientContext.getUseLegacyBlockReaderLocal()) &#123;</span><br><span class="line">      reader = getLegacyBlockReaderLocal();</span><br><span class="line">      <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">          LOG.trace(<span class="keyword">this</span> + <span class="string">": returning new legacy block reader local."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reader;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      reader = getBlockReaderLocal();</span><br><span class="line">      <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">          LOG.trace(<span class="keyword">this</span> + <span class="string">": returning new block reader local."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reader;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过UNIX domain socket 得到一个remote block reader</span></span><br><span class="line">  <span class="comment">// 与short circuit local read 的区别？？？？</span></span><br><span class="line">  <span class="keyword">if</span> (conf.domainSocketDataTraffic) &#123;</span><br><span class="line">    reader = getRemoteBlockReaderFromDomain();</span><br><span class="line">    <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">        LOG.trace(<span class="keyword">this</span> + <span class="string">": returning new remote block reader using "</span> +</span><br><span class="line">            <span class="string">"UNIX domain socket on "</span> + pathInfo.getPath());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> reader;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Preconditions.checkState(!DFSInputStream.tcpReadsDisabledForTesting,</span><br><span class="line">      <span class="string">"TCP reads were disabled for testing, but we failed to "</span> +</span><br><span class="line">      <span class="string">"do a non-TCP read."</span>);</span><br><span class="line">  <span class="comment">// 返回远程BlockReader</span></span><br><span class="line">  <span class="keyword">return</span> getRemoteBlockReaderFromTcp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到BlockReader之后代码回到<code>readWithStrategy</code>中，然后进行<code>readBuffer</code>操作，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// corruptedBlockMap在readWithStrategy中被实例化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">readBuffer</span><span class="params">(ReaderStrategy reader, <span class="keyword">int</span> off, <span class="keyword">int</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;ExtendedBlock, Set&lt;DatanodeInfo&gt;&gt; corruptedBlockMap)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  IOException ioe;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* we retry current node only once. So this is set to true only here.</span></span><br><span class="line"><span class="comment">   * Intention is to handle one common case of an error that is not a</span></span><br><span class="line"><span class="comment">   * failure on datanode or client : when DataNode closes the connection</span></span><br><span class="line"><span class="comment">   * since client is idle. If there are other cases of "non-errors" then</span></span><br><span class="line"><span class="comment">   * then a datanode might be retried by setting this to true again.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">boolean</span> retryCurrentNode = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// retry as many times as seekToNewSource allows.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> reader.doRead(blockReader, off, len, readStatistics);</span><br><span class="line">    &#125; <span class="keyword">catch</span> ( ChecksumException ce ) &#123;</span><br><span class="line">      DFSClient.LOG.warn(<span class="string">"Found Checksum error for "</span></span><br><span class="line">          + getCurrentBlock() + <span class="string">" from "</span> + currentNode</span><br><span class="line">          + <span class="string">" at "</span> + ce.getPos());        </span><br><span class="line">      ioe = ce;</span><br><span class="line">      retryCurrentNode = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// we want to remember which block replicas we have tried</span></span><br><span class="line">      addIntoCorruptedBlockMap(getCurrentBlock(), currentNode,</span><br><span class="line">          corruptedBlockMap);</span><br><span class="line">    &#125; <span class="keyword">catch</span> ( IOException e ) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!retryCurrentNode) &#123;</span><br><span class="line">        DFSClient.LOG.warn(<span class="string">"Exception while reading from "</span></span><br><span class="line">            + getCurrentBlock() + <span class="string">" of "</span> + src + <span class="string">" from "</span></span><br><span class="line">            + currentNode, e);</span><br><span class="line">      &#125;</span><br><span class="line">      ioe = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> sourceFound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (retryCurrentNode) &#123;</span><br><span class="line">      <span class="comment">/* possibly retry the same node so that transient errors don't</span></span><br><span class="line"><span class="comment">       * result in application level failures (e.g. Datanode could have</span></span><br><span class="line"><span class="comment">       * closed the connection because the client is idle for too long).</span></span><br><span class="line"><span class="comment">       */</span> </span><br><span class="line">      sourceFound = seekToBlockSource(pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      addToDeadNodes(currentNode);</span><br><span class="line">      sourceFound = seekToNewSource(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!sourceFound) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ioe;</span><br><span class="line">    &#125;</span><br><span class="line">    retryCurrentNode = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>readBuffer是通过调用ByteArrayStrategy重写的doRead方法来read的，而<code>ByteArrayStrategy.doRead</code>又是调用<code>BlockReader.read</code>来进行真正的读操作。</p>
<p>doRead时readBuffer会捕获到ChecksumException和IOException异常，</p>
<ul>
<li>如果检测到<em>ChecksumException</em>异常，retryCurrentNode 变为fasle，将当前节点加入deadNodes，然后进行seekToNewSource</li>
<li>如果检测到<em>IOException</em>异常，并且retryCurrentNode为true，则进行seekToBlockSource<pre><code>如果retryCurrentNode为false，将当前节点加入deadNodes，然后进行seekToNewSource
</code></pre></li>
</ul>
<p>retryCurrentNode标识当前节点read失败之后是否进行重试，如果是ChecksumException失败，则不进行重试，如果是IOException失败，则进行重试，并且只重试一次。<em>因为可能存在由于client长时间没有任何动作，则dn关闭了连接导致IOException，此时进行重试</em>。<strong>此处进行重试并不是马上对该节点进行重试，只是不该节点标为dead，可以在随后的choseNode时可以被再次选择</strong>。</p>
<p>由seekToNewSource来选择再次read的节点，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">seekToNewSource</span><span class="params">(<span class="keyword">long</span> targetPos)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> markedDead = deadNodes.containsKey(currentNode);</span><br><span class="line">  addToDeadNodes(currentNode);</span><br><span class="line">  DatanodeInfo oldNode = currentNode;</span><br><span class="line">  DatanodeInfo newNode = blockSeekTo(targetPos);</span><br><span class="line">  <span class="keyword">if</span> (!markedDead) &#123;</span><br><span class="line">    <span class="comment">/* remove it from deadNodes. blockSeekTo could have cleared </span></span><br><span class="line"><span class="comment">     * deadNodes and added currentNode again. Thats ok. */</span></span><br><span class="line">    deadNodes.remove(oldNode);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!oldNode.getDatanodeUuid().equals(newNode.getDatanodeUuid())) &#123;</span><br><span class="line">    currentNode = newNode;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真正的read操作是<code>BlockReader.read</code>，BlockReader是在blockSeekTo中实例化的，此处是<em>远程read</em>，其实现是<code>RemoteBlockReader2.read</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RemoteBlockReader2.read</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> </span></span><br><span class="line"><span class="function">                             <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">  UUID randomId = <span class="keyword">null</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (curDataSlice == <span class="keyword">null</span> || curDataSlice.remaining() == <span class="number">0</span> &amp;&amp; bytesNeededToFinish &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    readNextPacket();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (curDataSlice.remaining() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// we're at EOF now</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果buf的len小于curDataSlice的长度，剩下的内容怎么读</span></span><br><span class="line">  <span class="keyword">int</span> nRead = Math.min(curDataSlice.remaining(), len);</span><br><span class="line">  <span class="comment">// 从curDataSlice中读取数据到buf中</span></span><br><span class="line">  curDataSlice.get(buf, off, nRead);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> nRead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readNextPacket</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">//Read packet headers.</span></span><br><span class="line">  packetReceiver.receiveNextPacket(in);</span><br><span class="line"></span><br><span class="line">  PacketHeader curHeader = packetReceiver.getHeader();</span><br><span class="line">  curDataSlice = packetReceiver.getDataSlice();</span><br><span class="line">  <span class="keyword">assert</span> curDataSlice.capacity() == curHeader.getDataLen();</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (curHeader.getDataLen() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// bytesPerChecksum 多少字节一个checkcum</span></span><br><span class="line">    <span class="comment">// curHeader.getDataLen得到数据data的长度，然后得出需要多少个chunks</span></span><br><span class="line">    <span class="keyword">int</span> chunks = <span class="number">1</span> + (curHeader.getDataLen() - <span class="number">1</span>) / bytesPerChecksum;</span><br><span class="line">    <span class="comment">// 得出checksum的长度</span></span><br><span class="line">    <span class="keyword">int</span> checksumsLen = chunks * checksumSize;</span><br><span class="line">    ...</span><br><span class="line">    lastSeqNo = curHeader.getSeqno();</span><br><span class="line">    <span class="keyword">if</span> (verifyChecksum &amp;&amp; curDataSlice.remaining() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// N.B.: the checksum error offset reported here is actually</span></span><br><span class="line">      <span class="comment">// relative to the start of the block, not the start of the file.</span></span><br><span class="line">      <span class="comment">// This is slightly misleading, but preserves the behavior from</span></span><br><span class="line">      <span class="comment">// the older BlockReader.</span></span><br><span class="line">      <span class="comment">// 利用checksum检查数据是否正确</span></span><br><span class="line">      checksum.verifyChunkedSums(curDataSlice,</span><br><span class="line">          packetReceiver.getChecksumSlice(),</span><br><span class="line">          filename, curHeader.getOffsetInBlock());</span><br><span class="line">    &#125;</span><br><span class="line">    bytesNeededToFinish -= curHeader.getDataLen();</span><br><span class="line">  &#125;    </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// First packet will include some data prior to the first byte</span></span><br><span class="line">  <span class="comment">// the user requested. Skip it.</span></span><br><span class="line">  <span class="keyword">if</span> (curHeader.getOffsetInBlock() &lt; startOffset) &#123;</span><br><span class="line">    <span class="keyword">int</span> newPos = (<span class="keyword">int</span>) (startOffset - curHeader.getOffsetInBlock());</span><br><span class="line">    curDataSlice.position(newPos);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we've now satisfied the whole client read, read one last packet</span></span><br><span class="line">  <span class="comment">// header, which should be empty</span></span><br><span class="line">  <span class="comment">// bytesNeededToFinish是表示还需要读多少字节，</span></span><br><span class="line">  <span class="comment">// 这个是在哪赋值的？怎么知道还有多少字节要读</span></span><br><span class="line">  <span class="keyword">if</span> (bytesNeededToFinish &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 读取结束</span></span><br><span class="line">    readTrailingEmptyPacket();</span><br><span class="line">    <span class="keyword">if</span> (verifyChecksum) &#123;</span><br><span class="line">      sendReadResult(Status.CHECKSUM_OK);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sendReadResult(Status.SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>read时packet是基本的传输单位，每个packet(默认每个packet为64K)由若干个chunk组成，每个chunk对应一个chunksum。</p>
<p>curDataSlice中存储这需要读取data的信息，初次读取packet时，curDataSlice为null，进行packet读取<code>readNextPacket</code>，对curDataSlice进行赋值（<em>也就是先把内容读取到packet中，此时curDataSlice就相当于一个packet</em>），并对packet中的数据调用<code>checksum.verifyChunkedSums</code>进行checksum检验。</p>
<p>最后由<code>curDataSlice.get(buf, off, nRead)</code>从curDataSlice读取一定长度的byte放入buf中。</p>
<p>则一次调用read流程结束，一次read只是从packet中读取一些byte，再次调用read会继续从curDataSlice中get一定长度的byte，直到<code>curDataSlice.remaining() == 0 &amp;&amp; bytesNeededToFinish &gt; 0</code>时，也就是当前packet内容读取完毕，然后再次调用readNextPacket进行读取block。</p>
<p>简单说下packet的数据结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Each packet looks like:</span></span><br><span class="line"><span class="comment">//   PLEN    HLEN      HEADER     CHECKSUMS  DATA</span></span><br><span class="line"><span class="comment">//   32-bit  16-bit   &lt;protobuf&gt;  &lt;variable length&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// PLEN:      Payload length</span></span><br><span class="line"><span class="comment">//            = length(PLEN) + length(CHECKSUMS) + length(DATA)</span></span><br><span class="line"><span class="comment">//            This length includes its own encoded length in</span></span><br><span class="line"><span class="comment">//            the sum for historical reasons.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// HLEN:      Header length</span></span><br><span class="line"><span class="comment">//            = length(HEADER)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// HEADER:    the actual packet header fields, encoded in protobuf</span></span><br><span class="line"><span class="comment">// CHECKSUMS: the crcs for the data chunk. May be missing if</span></span><br><span class="line"><span class="comment">//            checksums were not requested</span></span><br><span class="line"><span class="comment">// DATA       the actual block data</span></span><br></pre></td></tr></table></figure>
<p>HDFS一个文件由多个block构成。HDFS在进行block读写的时候是以packet(默认每个packet为64K)为单位进行的。每一个packet由若干个chunk（默认512Byte）组成。Chunk是进行数据校验的基本单位，对每一个chunk生成一个校验和(默认4Byte)并将校验和进行存储。在读取一个block的时候，数据传输的基本单位是packet，每个packet由若干个chunk组成。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="getRemoteBlockReaderFromTcp代码跟读"><a href="#getRemoteBlockReaderFromTcp代码跟读" class="headerlink" title="getRemoteBlockReaderFromTcp代码跟读"></a>getRemoteBlockReaderFromTcp代码跟读</h3><p>getRemoteBlockReaderFromTcp得到一个远程BlockReader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> BlockReader <span class="title">getRemoteBlockReaderFromTcp</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  BlockReader blockReader = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    BlockReaderPeer curPeer = <span class="keyword">null</span>;</span><br><span class="line">    Peer peer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//Get the next TCP-based peer-- either from the cache or by creating it.</span></span><br><span class="line">      curPeer = nextTcpPeer();</span><br><span class="line">      <span class="keyword">if</span> (curPeer == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> (curPeer.fromCache) remainingCacheTries--;</span><br><span class="line">      peer = curPeer.peer;</span><br><span class="line">      <span class="comment">// 通过peer得到某个block的blockReader</span></span><br><span class="line">      blockReader = getRemoteBlockReader(peer);</span><br><span class="line">      <span class="keyword">return</span> blockReader;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (blockReader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        IOUtils.cleanup(LOG, peer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> BlockReader <span class="title">getRemoteBlockReader</span><span class="params">(Peer peer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (conf.useLegacyBlockReader) &#123;</span><br><span class="line">    <span class="keyword">return</span> RemoteBlockReader.newBlockReader(fileName,</span><br><span class="line">        block, token, startOffset, length, conf.ioBufferSize,</span><br><span class="line">        verifyChecksum, clientName, peer, datanode,</span><br><span class="line">        clientContext.getPeerCache(), cachingStrategy);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> RemoteBlockReader2.newBlockReader(</span><br><span class="line">        fileName, block, token, startOffset, length,</span><br><span class="line">        verifyChecksum, clientName, peer, datanode,</span><br><span class="line">        clientContext.getPeerCache(), cachingStrategy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RemoteBlockReader2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BlockReader <span class="title">newBlockReader</span><span class="params">(String file,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   ExtendedBlock block,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Token&lt;BlockTokenIdentifier&gt; blockToken,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">long</span> startOffset, <span class="keyword">long</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">boolean</span> verifyChecksum,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   String clientName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Peer peer, DatanodeID datanodeID,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   PeerCache peerCache,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   CachingStrategy cachingStrategy)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// in and out will be closed when sock is closed (by the caller)</span></span><br><span class="line">  <span class="comment">// 使用Socket建立写入流，</span></span><br><span class="line">  <span class="keyword">final</span> DataOutputStream out = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">        peer.getOutputStream()));</span><br><span class="line">  <span class="comment">// 向DataNode发送读指令</span></span><br><span class="line">  <span class="comment">// 此处的readBlock与DataXceiver中的readBlock的区别是啥？这是一个rpc调用？？</span></span><br><span class="line">  <span class="comment">// Sender是client端，DataXceiver是Server端？？？</span></span><br><span class="line">  <span class="keyword">new</span> Sender(out).readBlock(block, blockToken, clientName, startOffset, len,</span><br><span class="line">      verifyChecksum, cachingStrategy);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Get bytes in block</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  DataInputStream in = <span class="keyword">new</span> DataInputStream(peer.getInputStream());</span><br><span class="line"></span><br><span class="line">  BlockOpResponseProto status = BlockOpResponseProto.parseFrom(</span><br><span class="line">      PBHelper.vintPrefixed(in));</span><br><span class="line">  checkSuccess(status, peer, block, file);</span><br><span class="line">  ReadOpChecksumInfoProto checksumInfo =</span><br><span class="line">    status.getReadOpChecksumInfo();</span><br><span class="line">  DataChecksum checksum = DataTransferProtoUtil.fromProto(</span><br><span class="line">      checksumInfo.getChecksum());</span><br><span class="line">  <span class="comment">//Warning when we get CHECKSUM_NULL?</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read the first chunk offset.</span></span><br><span class="line">  <span class="keyword">long</span> firstChunkOffset = checksumInfo.getChunkOffset();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( firstChunkOffset &lt; <span class="number">0</span> || firstChunkOffset &gt; startOffset ||</span><br><span class="line">      firstChunkOffset &lt;= (startOffset - checksum.getBytesPerChecksum())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"BlockReader: error in first chunk offset ("</span> +</span><br><span class="line">                          firstChunkOffset + <span class="string">") startOffset is "</span> +</span><br><span class="line">                          startOffset + <span class="string">" for file "</span> + file);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RemoteBlockReader2(file, block.getBlockPoolId(), block.getBlockId(),</span><br><span class="line">      checksum, verifyChecksum, startOffset, firstChunkOffset, len, peer,</span><br><span class="line">      datanodeID, peerCache);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="随机读"><a href="#随机读" class="headerlink" title="随机读"></a>随机读</h3><p>HDFS读文件包含两种，一种是最经常使用的顺序读，另一种是随机读。像MR任务，一般都会涉及到随机读。MR在提交作业时，已经确定了每个map和reduce要读取的文件，文件的偏移量，读取的长度，则只读取相应的split就行。</p>
<p>随机读的代码入口函数依然在<code>FSDataInputStream</code>中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FSDataInputStream.read</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">byte</span>[] buffer, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((PositionedReadable)in).read(position, buffer, offset, length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//DFSInputStream.read</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">byte</span>[] buffer, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// sanity checks</span></span><br><span class="line">  dfsClient.checkOpen();</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Stream closed"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  failures = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">long</span> filelen = getFileLength();</span><br><span class="line">  <span class="keyword">if</span> ((position &lt; <span class="number">0</span>) || (position &gt;= filelen)) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> realLen = length;</span><br><span class="line">  <span class="keyword">if</span> ((position + length) &gt; filelen) &#123;</span><br><span class="line">    realLen = (<span class="keyword">int</span>)(filelen - position);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// determine the block and byte range within the block</span></span><br><span class="line">  <span class="comment">// corresponding to position and realLen</span></span><br><span class="line">  List&lt;LocatedBlock&gt; blockRange = getBlockRange(position, realLen);</span><br><span class="line">  <span class="keyword">int</span> remaining = realLen;</span><br><span class="line">  Map&lt;ExtendedBlock,Set&lt;DatanodeInfo&gt;&gt; corruptedBlockMap </span><br><span class="line">    = <span class="keyword">new</span> HashMap&lt;ExtendedBlock, Set&lt;DatanodeInfo&gt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (LocatedBlock blk : blockRange) &#123;</span><br><span class="line">    <span class="keyword">long</span> targetStart = position - blk.getStartOffset();</span><br><span class="line">    <span class="keyword">long</span> bytesToRead = Math.min(remaining, blk.getBlockSize() - targetStart);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (dfsClient.isHedgedReadsEnabled()) &#123;</span><br><span class="line">        hedgedFetchBlockByteRange(blk, targetStart, targetStart + bytesToRead</span><br><span class="line">            - <span class="number">1</span>, buffer, offset, corruptedBlockMap);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fetchBlockByteRange(blk, targetStart, targetStart + bytesToRead - <span class="number">1</span>,</span><br><span class="line">            buffer, offset, corruptedBlockMap);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// Check and report if any block replicas are corrupted.</span></span><br><span class="line">      <span class="comment">// BlockMissingException may be caught if all block replicas are</span></span><br><span class="line">      <span class="comment">// corrupted.</span></span><br><span class="line">      reportCheckSumFailure(corruptedBlockMap, blk.getLocations().length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    remaining -= bytesToRead;</span><br><span class="line">    position += bytesToRead;</span><br><span class="line">    offset += bytesToRead;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">assert</span> remaining == <span class="number">0</span> : <span class="string">"Wrong number of bytes read."</span>;</span><br><span class="line">  <span class="keyword">if</span> (dfsClient.stats != <span class="keyword">null</span>) &#123;</span><br><span class="line">    dfsClient.stats.incrementBytesRead(realLen);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> realLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这两篇文章主要介绍了hdfs读文件的流程，整个流程为：<br>1) 得到一个文件系统的实例，通过getFileSystem得到<br>2) open一个文件输入流，open时根据指定的path调用rpc打开一个FSDataInputStream，在初始化输入流时，会将一部分block的locations信息读入内存进行缓存，默认是10个block。将输入流的实例返回给client。<em>内存中缓存的block已经是按照各个dn到client的距离进行排序之后的结果</em><br>3) 输入流实例化之后，调用read方法读取数据。(读分为顺序读和随机读)</p>
<ol>
<li>read时可以选择几种ReaderStrategy，本篇选择的是ByteArrayStrategy。</li>
<li>根据off和len进行读。通过off找到对应的block A(二分查找)，如果block A在之前的缓存中，则直接返回block A。如果block A不在之前的缓存中，则再次请求从nn请求一部分block，将新请求的blocks根据其中block在原缓存中的位置插入到缓存中，之后得到该off对应的block A。</li>
<li>通过block A选择离client最近的dn，<em>如果得到dn时发生IOException错误(当从locations中没有选择到合适的dn时，抛出IOException)</em>，则等待一段时间之后，进行重试，默认是重试3次。</li>
<li>得到dn之后，通过BlockRead进行读取数据，BlockRead根据是否short circuit local 和 remote实例化不同的BlockRead。</li>
<li><em>read数据时发生的错误为checksumException和IOException</em>，如果是ChecksumException则将dn放入deadNodes中，换个dn进行重读，如果是IOException则直接重读(<em>可能是连接断开了</em>)，不将dn放入deadNodes中。</li>
<li>本篇介绍的是RemoteBlockReader，读文件时是以packet为单位的，读取一个packet放入内存，对其中的chunk进行checksum校验。从内存中读取len的长度，如果读完则继续读取下一个packet。<em>读取完毕之后发送一个空packet。</em><strong>是block的最后一个packet还是？？</strong></li>
<li>读文件时还需要dn端的一些操作，主要类是DataXceiver，这个类随后再分析。</li>
</ol>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>何种情况下block会丢失</li>
<li>读取速度慢，某个node读取失败</li>
<li>怎么判断需要创建远程BlockReader还是本地BlockReader(是否还有本地读的概念，都是通过remote吗？)<br>仅由此来判断是否开启本地读还是远程读？  setRemotePeerFactory<br>allowShortCircuitLocalReads 当 当前文件正在构建中则为false</li>
<li>read某个block的dn时，出错，怎么办<br>看在哪出错？是在get block dn时还是在得到dn进行read时出错，<br><em>如果在get block的dn时出错</em>，重复3次依然出错，则抛出异常。<br><em>如果在得到dn之后，read时出错</em>，此时又分两种情况，如果是checksum错，换个dn重读，如果是IOException，则直接重试。</li>
<li>发送，数据是怎么发送的？？？   读的过程中有send嘛？</li>
<li>读取某个dn的block时失败，将此dn加入哪？或者dn死掉，。。<br>  加入deadNodes</li>
<li>这个deadNodes是谁维护的？只是本次读？<br>读一个block，一个deadNodes</li>
<li>In HDFS, why corrupted block(s) happens?<br> dfs.datanode.scan.period.hours</li>
<li>Sender(out).readBlock与DataXceiver中的readBlock的区别是啥？这是一个rpc调用？？<br>// Sender是client端，DataXceiver是Server端？？？</li>
</ul>
<h2 id="相关配置属性"><a href="#相关配置属性" class="headerlink" title="相关配置属性"></a>相关配置属性</h2><ul>
<li><p>io.file.buffer.size(4096)<br> The size of buffer for use in sequence files. The size of this buffer should probably be a multiple of hardware page size (4096 on Intel x86), and it determines how much data is buffered during read and write operations.</p>
</li>
<li><p>dfs.client.read.prefetch.size</p>
</li>
</ul>
<p>prefetchSize = conf.getLong(DFS_CLIENT_READ_PREFETCH_SIZE_KEY,<br>          10 * defaultBlockSize);</p>
<ul>
<li><p>dfs.client.<em>cache.drop</em>.behind.reads (vs dfs.datanode.<em>drop.cache</em>.behind.reads)</p>
<p> Just like dfs.datanode.drop.cache.behind.reads, this setting causes the page cache to be dropped behind HDFS reads, potentially freeing up more memory for other uses. Unlike dfs.datanode.drop.cache.behind.reads, this is a client-side setting rather than a setting for the entire datanode. If present, this setting will override the DataNode default. If the native libraries are not available to the DataNode, this configuration has no effect.</p>
<p> In some workloads, the data read from HDFS is known to be significantly large enough that it is unlikely to be useful to cache it in the operating system buffer cache. In this case, the DataNode may be configured to automatically purge all data from the buffer cache after it is delivered to the client. This behavior is automatically disabled for workloads which read only short sections of a block (e.g HBase random-IO workloads). This may improve performance for some workloads by freeing buffer cache space usage for more cacheable data. If the Hadoop native libraries are not available, this configuration has no effect.</p>
</li>
</ul>
<ul>
<li><p>dfs.client.cache.drop.behind.writes</p>
</li>
<li><p>dfs.client.cache.readahead (vs dfs.datanode.readahead.bytes)</p>
<p> When using remote reads, this setting causes the datanode to read ahead in the block file using posix_fadvise, potentially decreasing I/O wait times. Unlike dfs.datanode.readahead.bytes, this is a client-side setting rather than a setting for the entire datanode. If present, this setting will override the DataNode default. When using local reads, this setting determines how much readahead we do in BlockReaderLocal. If the native libraries are not available to the DataNode, this configuration has no effect.</p>
</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>您的肯定，是我装逼的最大的动力！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/path/to/wechat-reward-image/wechatpay.png" alt="混绅士 WeChat Pay">
          <p>微信打赏</p>
        </div>
      
      
    </div>
  </div>


      
    </div>

    <div>
      
        
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      混绅士
    </li>
    
    <!--add wordcount and min2 read by szw-->
    <li class="post-copyright-author">
      <strong>本文字数：</strong>
      16,413
    </li>
    <li class="post-copyright-author">
      <strong>阅读时长：</strong>
      95
    </li>

    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://bigdatadecode.club/HDFS read解析2之从文件流中read.html" title="HDFS read解析2之从文件流中read">http://bigdatadecode.club/HDFS read解析2之从文件流中read.html</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
    </li>
  </ul>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/BigData/" rel="tag"># BigData</a>
          
            <a href="/tags/Hadoop/" rel="tag"># Hadoop</a>
          
            <a href="/tags/HDFS/" rel="tag"># HDFS</a>
          
            <a href="/tags/read/" rel="tag"># read</a>
          
        </div>
      

       
        <h3> 相关推荐：</h3><ul class="related-posts"><li><a href="/常用Hadoop命令.html">常用Hadoop命令</a></li><li><a href="/HDFS read解析.html">HDFS read解析(一)之Open文件流</a></li><li><a href="/[译]Append Hflush Read设计文档.html">Append/Hflush/Read设计文档</a></li><li><a href="/HDFSCannotObtainBlockLengthForLocatedBlock.html">HDFS之Cannot obtain block length for LocatedBlock异常</a></li><li><a href="/HDFS权限.html">HDFS权限</a></li><li><a href="/HDFS中atime和mtime.html">HDFS中atime与mtime解析</a></li><li><a href="/Hadoop_get_NullPointerException.html">Hadoop get命令返回NullPointerException</a></li><li><a href="/再议HDFS写流程之pipeline.html">再议HDFS写流程之pipeline</a></li><li><a href="/Ozone感悟.html">Ozone感悟</a></li><li><a href="/[译]HDFS恢复过程2.html">HDFS恢复过程2</a></li></ul> 
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/NameNode内存解析及大小评估.html" rel="next" title="NameNode内存解析及大小评估">
                <i class="fa fa-chevron-left"></i> NameNode内存解析及大小评估
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/[译]HDFS恢复过程2.html" rel="prev" title="HDFS恢复过程2">
                HDFS恢复过程2 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>  
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>      
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "1",
        "bdMiniList": ["tsina", "weixin", "sqq", "douban", "qzone", "twi", "fbook"],
        "bdPic": ""
      },
      "image": {
        "viewList": ["tsina", "weixin", "sqq", "douban", "qzone", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      },
      "slide": {
        "bdImg": "5",
        "bdPos": "left",
        "bdTop": "100"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>       
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="混绅士">
          <p class="site-author-name" itemprop="name">混绅士</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">102</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">164</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <!-- <i class="fa  fa-fw fa-globe"></i> -->
              <!-- modify icon to fire by szw -->
              <i class="fa fa-fire fa-" aria-hidden="true"></i>
              热文推荐
            </div>
            <ul class="links-of-blogroll-list">
              
                <!-- delete li's class by szw -->
                <li>
                  <a href="http://bigdatadecode.club/Spark Streaming 消费kafka到HDFS.html" title="Spark Streaming 消费kafka到HDFS" target="_blank">Spark Streaming 消费kafka到HDFS</a>
                </li>
              
                <!-- delete li's class by szw -->
                <li>
                  <a href="http://bigdatadecode.club/HDFS write解析.html" title="HDFS write解析" target="_blank">HDFS write解析</a>
                </li>
              
                <!-- delete li's class by szw -->
                <li>
                  <a href="http://bigdatadecode.club/Spark编译与部署.html" title="Spark编译与部署" target="_blank">Spark编译与部署</a>
                </li>
              
                <!-- delete li's class by szw -->
                <li>
                  <a href="http://bigdatadecode.club/MapReduce源码解析--环形缓冲区.html" title="MapReduce源码解析--环形缓冲区" target="_blank">MapReduce源码解析--环形缓冲区</a>
                </li>
              
                <!-- delete li's class by szw -->
                <li>
                  <a href="http://bigdatadecode.club/Flume简介及初次使用.html" title="Flume简介及初次使用" target="_blank">Flume简介及初次使用</a>
                </li>
              
                <!-- delete li's class by szw -->
                <li>
                  <a href="http://bigdatadecode.club/实时抓取MySQL的更新数据到Hadoop.html" title="实时抓取MySQL的更新数据到Hadoop" target="_blank">实时抓取MySQL的更新数据到Hadoop</a>
                </li>
              
            </ul>
          </div>


        

        
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/[译]FSImage-protocol.html" title="Use protobuf to FSImage" target="_blank">Use protobuf to FSImage</a>
                  </li>
                
                  <li>
                    <a href="/Consistency-in-Distributed.html" title="分布式一致性协议" target="_blank">分布式一致性协议</a>
                  </li>
                
                  <li>
                    <a href="/cryptozombies-src-parse-2.html" title="cryptozombies源码解析二" target="_blank">cryptozombies源码解析二</a>
                  </li>
                
                  <li>
                    <a href="/cryptozombies-src-parse.html" title="cryptozombies源码解析一" target="_blank">cryptozombies源码解析一</a>
                  </li>
                
                  <li>
                    <a href="/Ozone感悟.html" title="Ozone感悟" target="_blank">Ozone感悟</a>
                  </li>
                
              </ul>
            </div>
          
 

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#HDFS-Read之从文件流中read"><span class="nav-number">1.</span> <span class="nav-text">HDFS Read之从文件流中read</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#补充"><span class="nav-number">2.</span> <span class="nav-text">补充</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#getRemoteBlockReaderFromTcp代码跟读"><span class="nav-number">2.1.</span> <span class="nav-text">getRemoteBlockReaderFromTcp代码跟读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#随机读"><span class="nav-number">2.2.</span> <span class="nav-text">随机读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#问题"><span class="nav-number">4.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#相关配置属性"><span class="nav-number">5.</span> <span class="nav-text">相关配置属性</span></a></li></ol></div>
            

          </div>

          <div class="post-toc-wrap sidebar-panel sidebar-panel-active" style="margin: 0 2px; text-align: left;">
            
              <div class="links-of-blogroll motion-element links-of-blogroll-inline">
                <div class="links-of-blogroll-title">
                  <!-- <i class="fa  fa-fw fa-globe"></i> -->
                  <!-- modify icon to fire by szw -->
                  <i class="fa fa-fire fa-" aria-hidden="true"></i>
                  热文推荐
                </div>
                <ul class="links-of-blogroll-list">
                  
                    <!-- delete li's class by szw -->
                    <li>
                      <a href="http://bigdatadecode.club/Spark Streaming 消费kafka到HDFS.html" title="Spark Streaming 消费kafka到HDFS" target="_blank">Spark Streaming 消费kafka到HDFS</a>
                    </li>
                  
                    <!-- delete li's class by szw -->
                    <li>
                      <a href="http://bigdatadecode.club/HDFS write解析.html" title="HDFS write解析" target="_blank">HDFS write解析</a>
                    </li>
                  
                    <!-- delete li's class by szw -->
                    <li>
                      <a href="http://bigdatadecode.club/Spark编译与部署.html" title="Spark编译与部署" target="_blank">Spark编译与部署</a>
                    </li>
                  
                    <!-- delete li's class by szw -->
                    <li>
                      <a href="http://bigdatadecode.club/MapReduce源码解析--环形缓冲区.html" title="MapReduce源码解析--环形缓冲区" target="_blank">MapReduce源码解析--环形缓冲区</a>
                    </li>
                  
                    <!-- delete li's class by szw -->
                    <li>
                      <a href="http://bigdatadecode.club/Flume简介及初次使用.html" title="Flume简介及初次使用" target="_blank">Flume简介及初次使用</a>
                    </li>
                  
                    <!-- delete li's class by szw -->
                    <li>
                      <a href="http://bigdatadecode.club/实时抓取MySQL的更新数据到Hadoop.html" title="实时抓取MySQL的更新数据到Hadoop" target="_blank">实时抓取MySQL的更新数据到Hadoop</a>
                    </li>
                  
                </ul>
              </div>
            
  
            
                <div class="links-of-blogroll motion-element links-of-blogroll-block">
                  <div class="links-of-blogroll-title">
                    <!-- modify icon to fire by szw -->
                    <i class="fa fa-history fa-" aria-hidden="true"></i>
                    近期文章
                  </div>
                  <ul class="links-of-blogroll-list">
                    
                    
                      <li>
                        <a href="/[译]FSImage-protocol.html" title="Use protobuf to FSImage" target="_blank">Use protobuf to FSImage</a>
                      </li>
                    
                      <li>
                        <a href="/Consistency-in-Distributed.html" title="分布式一致性协议" target="_blank">分布式一致性协议</a>
                      </li>
                    
                      <li>
                        <a href="/cryptozombies-src-parse-2.html" title="cryptozombies源码解析二" target="_blank">cryptozombies源码解析二</a>
                      </li>
                    
                      <li>
                        <a href="/cryptozombies-src-parse.html" title="cryptozombies源码解析一" target="_blank">cryptozombies源码解析一</a>
                      </li>
                    
                      <li>
                        <a href="/Ozone感悟.html" title="Ozone感悟" target="_blank">Ozone感悟</a>
                      </li>
                    
                  </ul>
                </div>
              
          </div>

        </section>
      <!--/noindex-->
      

      

    </div>

  </aside>



        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">混绅士</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


<!--add total count by szw-->
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共635.2k字</span>
</div>
        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user">本站访客数</i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye">本站总访问量</i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("nP29Qpe35cHgQTQIFL94dGoW-gzGzoHsz", "eVPY9SfyVH11gSsbPBEcAQM0");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

</body>
</html>
