<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Hadoop RPC 解析 | big data decode club</title><meta name="keywords" content="Hadoop,BigData,RPC"><meta name="author" content="混绅士"><meta name="copyright" content="混绅士"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="RPCRPC由四个模块组成：1、通信模块。两个相互协作的通信模块实现请求-应答协议,它们在客户和服务器之间传递请求和应答消息,一般不会对数据包进行任何处理。请求–应答协议的实现方式有同步方式和异步方式两种。同步模式下客户端程序一直阻塞到服务器端发送的应答请求到达本地; 而异步模式不同,客户端将请求发送到服务器端后,不必等待应答返回,可以做其他事情,待服务器端处理完请求后,主动通知客户端。在高并发应">
<meta property="og:type" content="article">
<meta property="og:title" content="Hadoop RPC 解析">
<meta property="og:url" content="http://yuanba.tech/Hadoop%20RPC%20%E8%A7%A3%E6%9E%90.html">
<meta property="og:site_name" content="big data decode club">
<meta property="og:description" content="RPCRPC由四个模块组成：1、通信模块。两个相互协作的通信模块实现请求-应答协议,它们在客户和服务器之间传递请求和应答消息,一般不会对数据包进行任何处理。请求–应答协议的实现方式有同步方式和异步方式两种。同步模式下客户端程序一直阻塞到服务器端发送的应答请求到达本地; 而异步模式不同,客户端将请求发送到服务器端后,不必等待应答返回,可以做其他事情,待服务器端处理完请求后,主动通知客户端。在高并发应">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2016-08-03T15:23:22.000Z">
<meta property="article:modified_time" content="2016-08-03T15:23:22.000Z">
<meta property="article:author" content="混绅士">
<meta property="article:tag" content="Hadoop">
<meta property="article:tag" content="BigData">
<meta property="article:tag" content="RPC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://yuanba.tech/Hadoop%20RPC%20%E8%A7%A3%E6%9E%90"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="27E5EbutCm"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Hadoop RPC 解析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2016-08-03 23:23:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="big data decode club" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/uploads/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">119</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">198</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Timeline</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">big data decode club</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Timeline</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Hadoop RPC 解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2016-08-03T15:23:22.000Z" title="发表于 2016-08-03 23:23:22">2016-08-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2016-08-03T15:23:22.000Z" title="更新于 2016-08-03 23:23:22">2016-08-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Hadoop/">Hadoop</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Hadoop RPC 解析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>RPC由四个模块组成：<br>1、通信模块。<br>两个相互协作的通信模块实现请求-应答协议,它们在客户和服务器之间传递请求和应答消息,一般不会对数据包进行任何处理。请求–应答协议的实现方式有同步方式和异步方式两种。同步模式下客户端程序一直阻塞到服务器端发送的应答请求到达本地; 而异步模式不同,客户端将请求发送到服务器端后,不必等待应答返回,可以做其他事情,待服务器端处理完请求后,主动通知客户端。在高并发应用场景中,一般采用异步模式以降低访问延迟和提高带宽利用率。<br>2、Stub 程序（代理程序）。<br>客户端和服务器端均包含Stub程序,可将之看做<strong>代理程序</strong>。它使得远程函数调用表现得跟本地调用一样,对用户程序完全透明。在客户端,它表现得就像一个本地程序,但不直接执行本地调用,而是将请求信息通过网络模块发送给服务器端。此外,当服务器发送应答后,它会解码对应结果。在服务器端,Stub程序依次进行解码请求消息中的参数、调用相应的服务过程和编码应答结果的返回值等处理。<br>3、调度程序。<br>调度程序接收来自通信模块的请求消息,并根据其中的标识选择一个Stub程序进行处理。通常客户端并发请求量比较大时,会采用线程池提高处理效率。<br>4、客户程序/服务过程。<br>请求的发出者和请求的处理者。</p>
<span id="more"></span>

<p>通常而言,一个 RPC请求从发送到获取处理结果,所经历的步骤如下所示。</p>
<ol>
<li>客户程序以本地方式通过系统产生的Stub程序调用客户程序; </li>
<li>该Stub程序将函数调用信息按照网络通信模块的要求封装成消息包,并交给通信模块发送到远程服务器端。 </li>
<li>远程服务器端接收此消息后,将此消息发送给相应的Stub程序;</li>
<li>Stub程序拆封消息,形成被调过程要求的形式,并调用对应函数;</li>
<li>被调用函数按照所获参数执行,并将结果返回给Stub程序;</li>
<li>Stub程序将此结果封装成消息,通过网络通信模块逐级地传送给客户程序。</li>
</ol>
<h2 id="Hadoop-RPC"><a href="#Hadoop-RPC" class="headerlink" title="Hadoop RPC"></a>Hadoop RPC</h2><p>Hadoop RPC主要分为四个部分,分别是序列化层、函数调用层、网络传输层和服务器端处理框架,具体实现机制如下:</p>
<p>序列化层。序列化主要作用是将结构化对象转为字节流以便于通过网络进行传输或写入持久存储,在RPC框架中,<br>          它主要用于将用户请求中的参数或者应答转化成字节流以便跨机器传输。Hadoop2.0之后，<br>          主要用Protocol Buffers和Apache Avro，Hadoop本身也提供了一套序列化框架，<br>          一个类只要实现Writable接口即可支持对象序列化与反序列化。<br>函数调用层。函数调用层主要功能是定位要调用的函数并执行该函数，<br>            Hadoop RPC采用了Java反射机制（<strong>服务器端</strong>）与动态代理（<strong>客户端</strong>）实现了函数调用。<br>网络传输层。网络传输层描述了Client与Server之间消息传输的方式，Hadoop RPC采用了<strong>基于TCP/IP的Socket机制</strong>。<br>服务器端处理框架。服务器端处理框架可被<strong>抽象为网络I/O模型</strong>，它描述了客户端与服务器端间信息交互方式,<br>                  它的设计直接决定着服务器端的并发处理能力,常见的网络 I/O 模型有阻塞式 I/O、非阻塞式 I/O、事件驱动 I/O 等,而Hadoop RPC采用了<strong>基于Reactor设计模式的事件驱动 I/O 模型（NIO）</strong>。</p>
<h3 id="Hadoop-RPC-Demo"><a href="#Hadoop-RPC-Demo" class="headerlink" title="Hadoop RPC Demo"></a>Hadoop RPC Demo</h3><p>使用Hadoop RPC前要先定义一个RPC协议，这个协议其实就是一个接口类，接口中的方法就是对外提供的远程调用方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hadoop中所有自定义 RPC 接口都需要继承 VersionedProtocol 接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyClientProtocol</span> <span class="keyword">extends</span> <span class="title">VersionedProtocol</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 版本号,默认情况下,不同版本号的 RPC Client 和 Server 之间不能相互通信</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> versionID = <span class="number">1L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">echo</span><span class="params">(String str)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span>  IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再声明一个类去实现这个协议，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientProtocolImpl</span> <span class="keyword">implements</span> <span class="title">MyClientProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// RPC 协议对外提供方法的具体实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">echo</span><span class="params">(String str)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面两个方法是从 VersionedProtocol 中重写的</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getProtocolVersion</span><span class="params">(String s, <span class="keyword">long</span> l)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MyClientProtocol.versionID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProtocolSignature <span class="title">getProtocolSignature</span><span class="params">(String s, <span class="keyword">long</span> l, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProtocolSignature(MyClientProtocol.versionID, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了RPC协议，再创建server端和client端就可以使用了，下面通过Hadoop RPC 创建server端。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">		<span class="comment">// 使用RPC类get一个sever  默认情况下使用 WritableRpcEngine，</span></span><br><span class="line">		<span class="comment">// 可以使用RPC.setProtocolEngine 设置序列号引擎</span></span><br><span class="line">		<span class="comment">// server 通过 Builder模式 得到一个server对象</span></span><br><span class="line">        RPC.Server server = <span class="keyword">new</span> RPC.Builder(conf).setProtocol(MyClientProtocol.class)</span><br><span class="line">                .setInstance(<span class="keyword">new</span> MyClientProtocolImpl()).setBindAddress(<span class="string">&quot;127.0.0.1&quot;</span>).setPort(<span class="number">9876</span>)</span><br><span class="line">                .setNumHandlers(<span class="number">10</span>).build();</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在就可以在client端调用RPC协议对外提供的接口方法了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">30000</span>; i++)&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    MyClientProtocol proxy = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    	<span class="comment">// 从RPC.getProxy方法的名字可以猜出client其实就是一个代理</span></span><br><span class="line">                    	<span class="comment">// Hadoop RPC客户端是通过java 动态代理实现远程调用的</span></span><br><span class="line">                        proxy = (MyClientProtocol) RPC.getProxy(MyClientProtocol.class, MyClientProtocol.versionID,</span><br><span class="line">                                <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9876</span>), conf);</span><br><span class="line">                        <span class="keyword">int</span> result = proxy.add(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">//                        System.out.println(result);</span></span><br><span class="line">                        String echoResult = proxy.echo(result + <span class="string">&quot;&quot;</span>); <span class="comment">// just for string</span></span><br><span class="line"><span class="comment">//                        System.out.println(echoResult);</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t.start();</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">        System.out.println(System.currentTimeMillis() - startTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果只是想写个demo，client不用写for循环，我写这个for循环是想测试下载server端设置不同的<strong>handler</strong>数对其性能的影响，但是通过上面的代码并没有达到我想要的结果。可能是我思路不对吧，有哪位大神看见了给我指点下。。。</p>
</blockquote>
<h2 id="Hadoop-RPC-源码解析"><a href="#Hadoop-RPC-源码解析" class="headerlink" title="Hadoop RPC 源码解析"></a>Hadoop RPC 源码解析</h2><p>通过上面的Demo，可以看出只有RPC协议是自己实现的，server和client都是通过RPC提供的接口get到的。则具体上面的Demo来看下RPC相关的源码。<br>与RPC相关的类在common中的ipc中，ipc是inter-process communication 的缩写<br>RPC主要向外提供了一些编程接口，用于get server 和 client，是对底层客户机–服务器网络模型的封装。<br><em>client可以通过RPC提供的getProxy和waitForProxy两种方法得到</em>，看下getProxy的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; protocol, <span class="keyword">long</span> clientVersion, InetSocketAddress addr, Configuration conf)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getProtocolProxy(protocol, clientVersion, addr, conf).getProxy();</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"><span class="comment">// getProtocolProxy 通过一些列的方法调用，基本都是方法的重写，最后定位到如下：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ProtocolProxy&lt;T&gt; <span class="title">getProtocolProxy</span><span class="params">(Class&lt;T&gt; protocol, <span class="keyword">long</span> clientVersion, InetSocketAddress addr, UserGroupInformation ticket, Configuration conf, SocketFactory factory, <span class="keyword">int</span> rpcTimeout, RetryPolicy connectionRetryPolicy, AtomicBoolean fallbackToSimpleAuth)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(UserGroupInformation.isSecurityEnabled()) &#123;</span><br><span class="line">        SaslRpcServer.init(conf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getProtocolEngine(protocol, conf).getProxy(protocol, clientVersion, addr, ticket, conf, factory, rpcTimeout, connectionRetryPolicy, fallbackToSimpleAuth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Hadoop2.0之后支持protocol buffer序列化，所以在原Hadoop RPC的基础上进行了修改，提出一个RpcEngine接口，以支持第三方序列化方法，hadoop本身只实现了protocol 和 Writable序列化的engine。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">synchronized</span> RpcEngine <span class="title">getProtocolEngine</span><span class="params">(Class&lt;?&gt; protocol, Configuration conf)</span> </span>&#123;</span><br><span class="line">    RpcEngine engine = (RpcEngine)PROTOCOL_ENGINES.get(protocol);</span><br><span class="line">    <span class="comment">// Hadoop 默认使用Writable序列化</span></span><br><span class="line">    <span class="keyword">if</span>(engine == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Class impl = conf.getClass(<span class="string">&quot;rpc.engine.&quot;</span> + protocol.getName(), WritableRpcEngine.class);</span><br><span class="line">        engine = (RpcEngine)ReflectionUtils.newInstance(impl, conf);</span><br><span class="line">        PROTOCOL_ENGINES.put(protocol, engine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> engine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用对应RpcEngine的getProxy方法，这里以WritableRPCEngine为例，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ProtocolProxy&lt;T&gt; <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; protocol, <span class="keyword">long</span> clientVersion, InetSocketAddress addr, UserGroupInformation ticket, Configuration conf, SocketFactory factory, <span class="keyword">int</span> rpcTimeout, RetryPolicy connectionRetryPolicy, AtomicBoolean fallbackToSimpleAuth)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(connectionRetryPolicy != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;Not supported: connectionRetryPolicy=&quot;</span> + connectionRetryPolicy);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//Static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)</span></span><br><span class="line">        <span class="comment">//返回代理类的一个实例，返回后的代理类可以当作被代理类使用</span></span><br><span class="line">        <span class="comment">//(可使用被代理类的在Subject接口中声明过的方法)。</span></span><br><span class="line">        <span class="comment">//InvocationHandler 是代理角色，具体方法的调用在这里invoke方法中</span></span><br><span class="line">        Object proxy = Proxy.newProxyInstance(protocol.getClassLoader(), <span class="keyword">new</span> Class[]&#123;protocol&#125;, <span class="keyword">new</span> WritableRpcEngine.Invoker(protocol, addr, ticket, conf, factory, rpcTimeout, fallbackToSimpleAuth));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProtocolProxy(protocol, proxy, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Proxy实例化时传进去的InvocationHandler的实现类是WritableRpcEngine的内部类Invoker，构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">(Class&lt;?&gt; protocol, InetSocketAddress address, UserGroupInformation ticket, Configuration conf, SocketFactory factory, <span class="keyword">int</span> rpcTimeout, AtomicBoolean fallbackToSimpleAuth)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.remoteId = ConnectionId.getConnectionId(address, protocol, ticket, rpcTimeout, conf);</span><br><span class="line">    <span class="keyword">this</span>.client = WritableRpcEngine.CLIENTS.getClient(conf, factory);</span><br><span class="line">    <span class="keyword">this</span>.fallbackToSimpleAuth = fallbackToSimpleAuth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当client端通过Proxy的实例化对象调用协议的相关接口时（即demo中<code>proxy.add(5, 6)</code>）,会调用WritableRpcEngine.Invoker中的invoke方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ObjectWritable value;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        value = (ObjectWritable)<span class="keyword">this</span>.client.call(RpcKind.RPC_WRITABLE, <span class="keyword">new</span> WritableRpcEngine.Invocation(method, args), <span class="keyword">this</span>.remoteId, <span class="keyword">this</span>.fallbackToSimpleAuth);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(traceScope != <span class="keyword">null</span>) &#123;</span><br><span class="line">            traceScope.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> value.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了Client类的call方法，<strong>WritableRpcEngine.Invocationclient实现了Writable接口，这里的作用是将method 和 args 进行序列化</strong>。client是在Invoker的构造方法中实例化的，call的具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Writable <span class="title">call</span><span class="params">(RpcKind rpcKind, Writable rpcRequest, Client.ConnectionId remoteId, <span class="keyword">int</span> serviceClass, AtomicBoolean fallbackToSimpleAuth)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 将远程调用信息封装成一个Client.Call对象 每个Call都有一个唯一的callId</span></span><br><span class="line">    Client.Call call = <span class="keyword">this</span>.createCall(rpcKind, rpcRequest);</span><br><span class="line">    <span class="comment">// 根据remoteId创建一个connection对象，并将call放到该对象的hashtable calls中</span></span><br><span class="line">    Client.Connection connection = <span class="keyword">this</span>.getConnection(remoteId, call, serviceClass, fallbackToSimpleAuth);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在call方法中先将远程调用信息封装成一个<code>Client.Call</code>对象，然后通过getConnection得到connection对象，将封装好的call对象放入connection对象的hashtable calls中，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Client.<span class="function">Connection <span class="title">getConnection</span><span class="params">(Client.ConnectionId remoteId, Client.Call call, <span class="keyword">int</span> serviceClass, AtomicBoolean fallbackToSimpleAuth)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.running.get()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;The client is stopped&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Client.Connection connection;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            Hashtable var6 = <span class="keyword">this</span>.connections;  <span class="comment">// connections 是个 hashtable</span></span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.connections) &#123;</span><br><span class="line">                <span class="comment">// 先从 connections中查找是否存在，不存在则创建</span></span><br><span class="line">                connection = (Client.Connection)<span class="keyword">this</span>.connections.get(remoteId);</span><br><span class="line">                <span class="keyword">if</span>(connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 这里new 只是对一些相关属性进行赋值，并没有真正的建立连接</span></span><br><span class="line">                    connection = <span class="keyword">new</span> Client.Connection(remoteId, serviceClass);</span><br><span class="line">                    <span class="keyword">this</span>.connections.put(remoteId, connection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(!connection.addCall(call)); <span class="comment">// 得到connection之后将call放入calls的hashtable中</span></span><br><span class="line">        <span class="comment">// 建立连接</span></span><br><span class="line">        connection.setupIOstreams(fallbackToSimpleAuth);</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>setupIOstreams</code>中建立连接，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Connect to the server and set up the I/O streams. It then sends</span></span><br><span class="line"><span class="comment"> * a header to the server and starts</span></span><br><span class="line"><span class="comment"> * the connection thread that waits for responses.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setupIOstreams</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    AtomicBoolean fallbackToSimpleAuth)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (socket != <span class="keyword">null</span> || shouldCloseConnection.get()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">      LOG.debug(<span class="string">&quot;Connecting to &quot;</span>+server);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Trace.isTracing()) &#123;</span><br><span class="line">      Trace.addTimelineAnnotation(<span class="string">&quot;IPC client connecting to &quot;</span> + server);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">short</span> numRetries = <span class="number">0</span>;</span><br><span class="line">    Random rand = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">// 建立socket进行连接     可见client是用socket进行通信</span></span><br><span class="line">      setupConnection();</span><br><span class="line">      InputStream inStream = NetUtils.getInputStream(socket);</span><br><span class="line">      OutputStream outStream = NetUtils.getOutputStream(socket);</span><br><span class="line">      <span class="comment">// Write the connection header - this is sent when connection is established</span></span><br><span class="line">      writeConnectionHeader(outStream); </span><br><span class="line">      <span class="keyword">if</span> (authProtocol == AuthProtocol.SASL) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 发送ping message，</span></span><br><span class="line">      <span class="comment">// The time after which a RPC will timeout.</span></span><br><span class="line">      <span class="comment">// If ping is not enabled (via ipc.client.ping), then the timeout value is the</span></span><br><span class="line">      <span class="comment">// same as the pingInterval.</span></span><br><span class="line">      <span class="comment">// If ping is enabled, then there is no timeout value.</span></span><br><span class="line">      <span class="keyword">if</span> (doPing) &#123;</span><br><span class="line">        inStream = <span class="keyword">new</span> PingInputStream(inStream);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.in = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(inStream));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// SASL may have already buffered the stream</span></span><br><span class="line">      <span class="keyword">if</span> (!(outStream <span class="keyword">instanceof</span> BufferedOutputStream)) &#123;</span><br><span class="line">        outStream = <span class="keyword">new</span> BufferedOutputStream(outStream);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.out = <span class="keyword">new</span> DataOutputStream(outStream);</span><br><span class="line">      <span class="comment">// 向内容中写入消息，这里面将 connectionContextHeader的序列化协议写死了，不知道为什么？？</span></span><br><span class="line">      <span class="comment">// RpcRequestHeaderProto connectionContextHeader = ProtoUtil</span></span><br><span class="line">      <span class="comment">//  .makeRpcRequestHeader(RpcKind.RPC_PROTOCOL_BUFFER,</span></span><br><span class="line">      <span class="comment">//      OperationProto.RPC_FINAL_PACKET, CONNECTION_CONTEXT_CALL_ID,</span></span><br><span class="line">      <span class="comment">//      RpcConstants.INVALID_RETRY_COUNT, clientId);</span></span><br><span class="line">      <span class="comment">// 这个方法与 writeConnectionHeader()的区别是什么 ，暂时还没有搞清。。。。。。。。</span></span><br><span class="line">      writeConnectionContext(remoteId, authMethod);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// update last activity time</span></span><br><span class="line">      touch();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (Trace.isTracing()) &#123;</span><br><span class="line">        Trace.addTimelineAnnotation(<span class="string">&quot;IPC client connected to &quot;</span> + server);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// start the receiver thread after the socket connection has been set</span></span><br><span class="line">      <span class="comment">// up</span></span><br><span class="line">      start();    <span class="comment">// 启动connection线程，等待接受server的response</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">      markClosed((IOException)t);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      markClosed(<span class="keyword">new</span> IOException(<span class="string">&quot;Couldn&#x27;t set up IO streams&quot;</span>, t));</span><br><span class="line">    &#125;</span><br><span class="line">    close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>setupConnection</code>方法进行socket连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setupConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">short</span> ioFailures = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">short</span> timeoutFailures = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建一个网络socket</span></span><br><span class="line">      <span class="keyword">this</span>.socket = socketFactory.createSocket();</span><br><span class="line">      <span class="keyword">this</span>.socket.setTcpNoDelay(tcpNoDelay);</span><br><span class="line">      <span class="keyword">this</span>.socket.setKeepAlive(<span class="keyword">true</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * Bind the socket to the host specified in the principal name of the</span></span><br><span class="line"><span class="comment">       * client, to ensure Server matching address of the client connection</span></span><br><span class="line"><span class="comment">       * to host name in principal passed.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      UserGroupInformation ticket = remoteId.getTicket();</span><br><span class="line">      <span class="keyword">if</span> (ticket != <span class="keyword">null</span> &amp;&amp; ticket.hasKerberosCredentials()) &#123;</span><br><span class="line">        KerberosInfo krbInfo = </span><br><span class="line">          remoteId.getProtocol().getAnnotation(KerberosInfo.class);</span><br><span class="line">        <span class="keyword">if</span> (krbInfo != <span class="keyword">null</span> &amp;&amp; krbInfo.clientPrincipal() != <span class="keyword">null</span>) &#123;</span><br><span class="line">          String host = </span><br><span class="line">            SecurityUtil.getHostFromPrincipal(remoteId.getTicket().getUserName());</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// If host name is a valid local address then bind socket to it</span></span><br><span class="line">          InetAddress localAddr = NetUtils.getLocalInetAddress(host);</span><br><span class="line">          <span class="keyword">if</span> (localAddr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.socket.bind(<span class="keyword">new</span> InetSocketAddress(localAddr, <span class="number">0</span>));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// server 在 connection的构造方法中进行赋值，</span></span><br><span class="line">      <span class="comment">// this.server = remoteId.getAddress();</span></span><br><span class="line">      <span class="comment">// 在connect中进行socket与ip的绑定连接</span></span><br><span class="line">      NetUtils.connect(<span class="keyword">this</span>.socket, server, connectionTimeout);</span><br><span class="line">      <span class="keyword">if</span> (rpcTimeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        pingInterval = rpcTimeout;  <span class="comment">// rpcTimeout overwrites pingInterval</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.socket.setSoTimeout(pingInterval);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ConnectTimeoutException toe) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ie) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建立连接之后，启动connection线程，运行<code>run</code>方法，等待server端的response。代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (LOG.isDebugEnabled())</span><br><span class="line">    LOG.debug(getName() + <span class="string">&quot;: starting, having connections &quot;</span> </span><br><span class="line">        + connections.size());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (waitForWork()) &#123;<span class="comment">//wait here for work - read or close connection</span></span><br><span class="line">      receiveRpcResponse();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="comment">// This truly is unexpected, since we catch IOException in receiveResponse</span></span><br><span class="line">    <span class="comment">// -- this is only to be really sure that we don&#x27;t leave a client hanging</span></span><br><span class="line">    <span class="comment">// forever.</span></span><br><span class="line">    LOG.warn(<span class="string">&quot;Unexpected error reading responses on connection &quot;</span> + <span class="keyword">this</span>, t);</span><br><span class="line">    markClosed(<span class="keyword">new</span> IOException(<span class="string">&quot;Error reading responses&quot;</span>, t));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  close();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (LOG.isDebugEnabled())</span><br><span class="line">    LOG.debug(getName() + <span class="string">&quot;: stopped, remaining connections &quot;</span></span><br><span class="line">        + connections.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getConnection</code>逻辑已经初步完结，现在回到<code>call</code>代码中，继续分析其代码，下面的关键代码是<code>connection.sendRpcRequest(call)</code>，发送call对象到server端，并进入阻塞状态等待server的response。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Writable <span class="title">call</span><span class="params">(RpcKind rpcKind, Writable rpcRequest, Client.ConnectionId remoteId, <span class="keyword">int</span> serviceClass, AtomicBoolean fallbackToSimpleAuth)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将远程调用信息发送给server端</span></span><br><span class="line">        connection.sendRpcRequest(call);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException var13) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;connection has been closed&quot;</span>, var13);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException var14) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        LOG.warn(<span class="string">&quot;interrupted waiting to send rpc request to server&quot;</span>, var14);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(var14);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">synchronized</span>(call) &#123;</span><br><span class="line">        <span class="comment">// 判断call是否完成，等待server端notify</span></span><br><span class="line">        <span class="keyword">while</span>(!call.done) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                 call.wait();   <span class="comment">// 当前线程blocking住，等待Connection线程中receiveRpcResponse调用call.notify</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException var12) &#123;</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(interrupted) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(call.error != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// get server 的结果</span></span><br><span class="line">            <span class="keyword">return</span> call.getRpcResponse();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendRpcRequest</span><span class="params">(<span class="keyword">final</span> Call call)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (shouldCloseConnection.get()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Serialize the call to be sent. This is done from the actual</span></span><br><span class="line">  <span class="comment">// caller thread, rather than the sendParamsExecutor thread,</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// so that if the serialization throws an error, it is reported</span></span><br><span class="line">  <span class="comment">// properly. This also parallelizes the serialization.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Format of a call on the wire:</span></span><br><span class="line">  <span class="comment">// 0) Length of rest below (1 + 2)</span></span><br><span class="line">  <span class="comment">// 1) RpcRequestHeader  - is serialized Delimited hence contains length</span></span><br><span class="line">  <span class="comment">// 2) RpcRequest</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Items &#x27;1&#x27; and &#x27;2&#x27; are prepared here. </span></span><br><span class="line">  <span class="keyword">final</span> DataOutputBuffer d = <span class="keyword">new</span> DataOutputBuffer();</span><br><span class="line">  RpcRequestHeaderProto header = ProtoUtil.makeRpcRequestHeader(</span><br><span class="line">      call.rpcKind, OperationProto.RPC_FINAL_PACKET, call.id, call.retry,</span><br><span class="line">      clientId);</span><br><span class="line">  header.writeDelimitedTo(d);</span><br><span class="line">  call.rpcRequest.write(d);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (sendRpcRequestLock) &#123;</span><br><span class="line">    Future&lt;?&gt; senderFuture = sendParamsExecutor.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">synchronized</span> (Connection.<span class="keyword">this</span>.out) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shouldCloseConnection.get()) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (LOG.isDebugEnabled())</span><br><span class="line">              LOG.debug(getName() + <span class="string">&quot; sending #&quot;</span> + call.id);</span><br><span class="line">     </span><br><span class="line">            <span class="keyword">byte</span>[] data = d.getData();</span><br><span class="line">            <span class="keyword">int</span> totalLength = d.getLength();</span><br><span class="line">            out.writeInt(totalLength); <span class="comment">// Total Length</span></span><br><span class="line">            out.write(data, <span class="number">0</span>, totalLength);<span class="comment">// RpcRequestHeader + RpcRequest</span></span><br><span class="line">            out.flush();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          <span class="comment">// exception at this point would leave the connection in an</span></span><br><span class="line">          <span class="comment">// unrecoverable state (eg half a call left on the wire).</span></span><br><span class="line">          <span class="comment">// So, close the connection, killing any outstanding calls</span></span><br><span class="line">          markClosed(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//the buffer is just an in-memory buffer, but it is still polite to</span></span><br><span class="line">          <span class="comment">// close early</span></span><br><span class="line">          IOUtils.closeStream(d);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 等待call发送完毕之后才退出该方法，回到call方法中继续执行</span></span><br><span class="line">      senderFuture.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">      Throwable cause = e.getCause();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// cause should only be a RuntimeException as the Runnable above</span></span><br><span class="line">      <span class="comment">// catches IOException</span></span><br><span class="line">      <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;unexpected checked exception&quot;</span>, cause);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看下server端的代码，server是通过RPC.Builder的build方法构建出来的，来看下build代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">build</span><span class="params">()</span> <span class="keyword">throws</span> IOException, HadoopIllegalArgumentException </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> getProtocolEngine(<span class="keyword">this</span>.protocol, <span class="keyword">this</span>.conf).getServer(</span><br><span class="line">      <span class="keyword">this</span>.protocol, <span class="keyword">this</span>.instance, <span class="keyword">this</span>.bindAddress, <span class="keyword">this</span>.port,</span><br><span class="line">      <span class="keyword">this</span>.numHandlers, <span class="keyword">this</span>.numReaders, <span class="keyword">this</span>.queueSizePerHandler,</span><br><span class="line">      <span class="keyword">this</span>.verbose, <span class="keyword">this</span>.conf, <span class="keyword">this</span>.secretManager, <span class="keyword">this</span>.portRangeConfig);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> RPC.<span class="function">Server <span class="title">getServer</span><span class="params">(Class&lt;?&gt; protocolClass,</span></span></span><br><span class="line"><span class="params"><span class="function">                    Object protocolImpl, String bindAddress, <span class="keyword">int</span> port,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">int</span> numHandlers, <span class="keyword">int</span> numReaders, <span class="keyword">int</span> queueSizePerHandler,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">boolean</span> verbose, Configuration conf,</span></span></span><br><span class="line"><span class="params"><span class="function">                    SecretManager&lt;? extends TokenIdentifier&gt; secretManager,</span></span></span><br><span class="line"><span class="params"><span class="function">                    String portRangeConfig)</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Server(protocolClass, protocolImpl, conf, bindAddress, port,</span><br><span class="line">      numHandlers, numReaders, queueSizePerHandler, verbose, secretManager,</span><br><span class="line">      portRangeConfig);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//在 Server的构造方法中，一追追溯到ipc.Server的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Server</span><span class="params">(String bindAddress, <span class="keyword">int</span> port,</span></span></span><br><span class="line"><span class="params"><span class="function">    Class&lt;? extends Writable&gt; rpcRequestClass, <span class="keyword">int</span> handlerCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> numReaders, <span class="keyword">int</span> queueSizePerHandler, Configuration conf,</span></span></span><br><span class="line"><span class="params"><span class="function">    String serverName, SecretManager&lt;? extends TokenIdentifier&gt; secretManager,</span></span></span><br><span class="line"><span class="params"><span class="function">    String portRangeConfig)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  ...  </span><br><span class="line">  <span class="comment">// Start the listener here and let it bind to the port</span></span><br><span class="line">  listener = <span class="keyword">new</span> Listener();</span><br><span class="line">  <span class="keyword">this</span>.port = listener.getAddress().getPort();    </span><br><span class="line">  connectionManager = <span class="keyword">new</span> ConnectionManager();</span><br><span class="line">  <span class="keyword">this</span>.rpcMetrics = RpcMetrics.create(<span class="keyword">this</span>, conf);</span><br><span class="line">  <span class="keyword">this</span>.rpcDetailedMetrics = RpcDetailedMetrics.create(<span class="keyword">this</span>.port);</span><br><span class="line">  <span class="keyword">this</span>.tcpNoDelay = conf.getBoolean(</span><br><span class="line">      CommonConfigurationKeysPublic.IPC_SERVER_TCPNODELAY_KEY,</span><br><span class="line">      CommonConfigurationKeysPublic.IPC_SERVER_TCPNODELAY_DEFAULT);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create the responder here</span></span><br><span class="line">  responder = <span class="keyword">new</span> Responder();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (secretManager != <span class="keyword">null</span> || UserGroupInformation.isSecurityEnabled()) &#123;</span><br><span class="line">    SaslRpcServer.init(conf);</span><br><span class="line">    saslPropsResolver = SaslPropertiesResolver.getInstance(conf);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.exceptionsHandler.addTerseExceptions(StandbyException.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ipc.Server的构造方法中会实例化<code>Listener</code>和<code>Responder</code>两个线程，先看下Listener的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Listener</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  address = <span class="keyword">new</span> InetSocketAddress(bindAddress, port);</span><br><span class="line">  <span class="comment">// Create a new server socket and set to non blocking mode</span></span><br><span class="line">  acceptChannel = ServerSocketChannel.open();</span><br><span class="line">  acceptChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Bind the server socket to the local host and port</span></span><br><span class="line">  bind(acceptChannel.socket(), address, backlogLength, conf, portRangeConfig);</span><br><span class="line">  port = acceptChannel.socket().getLocalPort(); <span class="comment">//Could be an ephemeral port</span></span><br><span class="line">  <span class="comment">// create a selector;</span></span><br><span class="line">  selector= Selector.open();</span><br><span class="line">  <span class="comment">// 创建reader数组，默认长度为1</span></span><br><span class="line">  readers = <span class="keyword">new</span> Reader[readThreads];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; readThreads; i++) &#123;</span><br><span class="line">    Reader reader = <span class="keyword">new</span> Reader(</span><br><span class="line">        <span class="string">&quot;Socket Reader #&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot; for port &quot;</span> + port);</span><br><span class="line">    readers[i] = reader;</span><br><span class="line">    reader.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register accepts on the server socket with the selector.</span></span><br><span class="line">  acceptChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">  <span class="keyword">this</span>.setName(<span class="string">&quot;IPC Server listener on &quot;</span> + port);</span><br><span class="line">  <span class="keyword">this</span>.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个Server只有一个Listener线程，在Listener线程中使用Java NIO来监听client发来的request连接，初始化Reader数组readers，Reader主要用于反序列化数据，生成服务器端的Call对象。Listener注册的事件是SelectionKey.OP_ACCEPT，Reader注册的事件是SelectionKey.OP_READ。<br>Server中还实例化了一个<code>Responder</code>线程，构造方法中只是得到一个Selector对象，Listener和Reader中也各自含有一个Selector对象，用来选择自己关心的事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Responder() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="keyword">this</span>.setName(<span class="string">&quot;IPC Server Responder&quot;</span>);</span><br><span class="line">  <span class="keyword">this</span>.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">  writeSelector = Selector.open(); <span class="comment">// create a selector</span></span><br><span class="line">  pending = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此Server初始化完毕，然后调用<code>start</code>方法，启动server，启动Server中<code>responder</code>、<code>listener</code>还有<code>handers</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  responder.start();</span><br><span class="line">  listener.start();</span><br><span class="line">  <span class="comment">//启动Hander线程，这个个数是初始化Server时通过setHander设置的</span></span><br><span class="line">  handlers = <span class="keyword">new</span> Handler[handlerCount];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; handlerCount; i++) &#123;</span><br><span class="line">    handlers[i] = <span class="keyword">new</span> Handler(i);</span><br><span class="line">    handlers[i].start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先来看下listener的run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LOG.info(Thread.currentThread().getName() + <span class="string">&quot;: starting&quot;</span>);</span><br><span class="line">  SERVER.set(Server.<span class="keyword">this</span>);  <span class="comment">// ThreadLocal&lt;Server&gt; SERVER    线程局部变量</span></span><br><span class="line">  connectionManager.startIdleScan();</span><br><span class="line">  <span class="keyword">while</span> (running) &#123;</span><br><span class="line">    SelectionKey key = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 得到selector  </span></span><br><span class="line">      getSelector().select();</span><br><span class="line">      Iterator&lt;SelectionKey&gt; iter = getSelector().selectedKeys().iterator();</span><br><span class="line">      <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        key = iter.next();</span><br><span class="line">        iter.remove();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (key.isValid()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.isAcceptable())</span><br><span class="line">              <span class="comment">// SelectionKey.OP_ACCEPT 发生后由doAccept来处理</span></span><br><span class="line">              doAccept(key);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        key = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">      <span class="comment">// we can run out of memory if we have too many threads</span></span><br><span class="line">      <span class="comment">// log the event and sleep for a minute and give </span></span><br><span class="line">      <span class="comment">// some thread(s) a chance to finish</span></span><br><span class="line">      LOG.warn(<span class="string">&quot;Out of Memory in server select&quot;</span>, e);</span><br><span class="line">      closeCurrentConnection(key, e);</span><br><span class="line">      connectionManager.closeIdle(<span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">60000</span>); &#125; <span class="keyword">catch</span> (Exception ie) &#123;&#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeCurrentConnection(key, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listener通过selector监听SelectionKey.OP_ACCEPT事件，<em>客户端Client.call中的getConnection会触发该事件</em>，当事件发生后调用<code>doAccept</code>，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doAccept</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> InterruptedException, IOException,  OutOfMemoryError </span>&#123;</span><br><span class="line">  ServerSocketChannel server = (ServerSocketChannel) key.channel();</span><br><span class="line">  SocketChannel channel;</span><br><span class="line">  <span class="keyword">while</span> ((channel = server.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">    channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    channel.socket().setTcpNoDelay(tcpNoDelay);</span><br><span class="line">    channel.socket().setKeepAlive(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// Listener 得到client的连接之后，交给Reader处理</span></span><br><span class="line">    <span class="comment">// 从readers数组中得到一个Reader</span></span><br><span class="line">    Reader reader = getReader();</span><br><span class="line">    <span class="comment">// Server 端的Connection不是一个线程，注意和Client的Connection的区别</span></span><br><span class="line">    <span class="comment">// Connection相当于hander</span></span><br><span class="line">    Connection c = connectionManager.register(channel);</span><br><span class="line">    <span class="comment">// 将当前Connection已经被建立连接，等待closeCurrentConnection关闭连接</span></span><br><span class="line">    key.attach(c);  <span class="comment">// so closeCurrentConnection can get the object</span></span><br><span class="line">    <span class="comment">// 将Connection放入Reader.pendingConnections，等待Reader处理</span></span><br><span class="line">    reader.addConnection(c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>reader.addConnection(c)</code>的代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addConnection</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  pendingConnections.put(conn);</span><br><span class="line">  <span class="comment">// 调用wakeup 是让线程从select()方法的阻塞中跳出来</span></span><br><span class="line">  <span class="comment">// 因为pendingConnections已经加入了新的Connection</span></span><br><span class="line">  readSelector.wakeup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程从<code>select()</code>中跳出来之后，继续运行<code>Reader.run()</code>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LOG.info(<span class="string">&quot;Starting &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    doRunLoop();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      readSelector.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">      LOG.error(<span class="string">&quot;Error closing read selector in &quot;</span> + Thread.currentThread().getName(), ioe);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doRunLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (running) &#123;</span><br><span class="line">    SelectionKey key = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// consume as many connections as currently queued to avoid</span></span><br><span class="line">      <span class="comment">// unbridled acceptance of connections that starves the select</span></span><br><span class="line">      <span class="keyword">int</span> size = pendingConnections.size();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=size; i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// pendingConnections 是一个 BlockingQueue</span></span><br><span class="line">        Connection conn = pendingConnections.take();</span><br><span class="line">        conn.channel.register(readSelector, SelectionKey.OP_READ, conn);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 此方法会阻塞，调用readSelector.wakeup()跳出阻塞</span></span><br><span class="line">      readSelector.select();</span><br><span class="line"></span><br><span class="line">      Iterator&lt;SelectionKey&gt; iter = readSelector.selectedKeys().iterator();</span><br><span class="line">      <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        key = iter.next();</span><br><span class="line">        iter.remove();</span><br><span class="line">        <span class="keyword">if</span> (key.isValid()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            doRead(key);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        key = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (running) &#123;                      <span class="comment">// unexpected -- log it</span></span><br><span class="line">        LOG.info(Thread.currentThread().getName() + <span class="string">&quot; unexpectedly interrupted&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      LOG.error(<span class="string">&quot;Error in Reader&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  Connection c = (Connection)key.attachment();</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;  </span><br><span class="line">  &#125;</span><br><span class="line">  c.setLastContact(Time.now());</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    count = c.readAndProcess();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException ieo) &#123;</span><br><span class="line">    LOG.info(Thread.currentThread().getName() + <span class="string">&quot;: readAndProcess caught InterruptedException&quot;</span>, ieo);</span><br><span class="line">    <span class="keyword">throw</span> ieo;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// a WrappedRpcServerException is an exception that has been sent</span></span><br><span class="line">    <span class="comment">// to the client, so the stacktrace is unnecessary; any other</span></span><br><span class="line">    <span class="comment">// exceptions are unexpected internal server errors and thus the</span></span><br><span class="line">    <span class="comment">// stacktrace should be logged</span></span><br><span class="line">    LOG.info(Thread.currentThread().getName() + <span class="string">&quot;: readAndProcess from client &quot;</span> +</span><br><span class="line">        c.getHostAddress() + <span class="string">&quot; threw exception [&quot;</span> + e + <span class="string">&quot;]&quot;</span>,</span><br><span class="line">        (e <span class="keyword">instanceof</span> WrappedRpcServerException) ? <span class="keyword">null</span> : e);</span><br><span class="line">    count = -<span class="number">1</span>; <span class="comment">//so that the (count &lt; 0) block is executed</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    closeConnection(c);</span><br><span class="line">    c = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    c.setLastContact(Time.now());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readAndProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> WrappedRpcServerException, IOException, InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">/* Read at most one RPC. If the header is not read completely yet</span></span><br><span class="line"><span class="comment">     * then iterate until we read first RPC or until there is no data left.</span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="keyword">int</span> count = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// this.dataLengthBuffer = ByteBuffer.allocate(4)</span></span><br><span class="line">    <span class="keyword">if</span> (dataLengthBuffer.remaining() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      count = channelRead(channel, dataLengthBuffer);       </span><br><span class="line">      <span class="keyword">if</span> (count &lt; <span class="number">0</span> || dataLengthBuffer.remaining() &gt; <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取RPC header RPC header一共4部分</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Write the connection header - this is sent when connection is established</span></span><br><span class="line"><span class="comment">     * +----------------------------------+</span></span><br><span class="line"><span class="comment">     * |  &quot;hrpc&quot; 4 bytes                  |   hrpc 在上面的if语句中读取     </span></span><br><span class="line"><span class="comment">     * +----------------------------------+</span></span><br><span class="line"><span class="comment">     * |  Version (1 byte)                |</span></span><br><span class="line"><span class="comment">     * +----------------------------------+</span></span><br><span class="line"><span class="comment">     * |  Service Class (1 byte)          |</span></span><br><span class="line"><span class="comment">     * +----------------------------------+</span></span><br><span class="line"><span class="comment">     * |  AuthProtocol (1 byte)           |      </span></span><br><span class="line"><span class="comment">     * +----------------------------------+</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!connectionHeaderRead) &#123;</span><br><span class="line">      <span class="comment">//Every connection is expected to send the header.</span></span><br><span class="line">      <span class="keyword">if</span> (connectionHeaderBuf == <span class="keyword">null</span>) &#123;</span><br><span class="line">        connectionHeaderBuf = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将 Version、Service Class、AuthProtocol读出 </span></span><br><span class="line">      count = channelRead(channel, connectionHeaderBuf);</span><br><span class="line">      <span class="keyword">if</span> (count &lt; <span class="number">0</span> || connectionHeaderBuf.remaining() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> version = connectionHeaderBuf.get(<span class="number">0</span>);</span><br><span class="line">      <span class="comment">// TODO we should add handler for service class later</span></span><br><span class="line">      <span class="keyword">this</span>.setServiceClass(connectionHeaderBuf.get(<span class="number">1</span>));</span><br><span class="line">      dataLengthBuffer.flip();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Check if it looks like the user is hitting an IPC port</span></span><br><span class="line">      <span class="comment">// with an HTTP GET - this is a common error, so we can</span></span><br><span class="line">      <span class="comment">// send back a simple string indicating as much.</span></span><br><span class="line">      <span class="keyword">if</span> (HTTP_GET_BYTES.equals(dataLengthBuffer)) &#123;</span><br><span class="line">        setupHttpRequestOnIpcPortResponse();</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (!RpcConstants.HEADER.equals(dataLengthBuffer)</span><br><span class="line">          || version != CURRENT_VERSION) &#123;</span><br><span class="line">        <span class="comment">//Warning is ok since this is not supposed to happen.</span></span><br><span class="line">        LOG.warn(<span class="string">&quot;Incorrect header or version mismatch from &quot;</span> + </span><br><span class="line">                 hostAddress + <span class="string">&quot;:&quot;</span> + remotePort +</span><br><span class="line">                 <span class="string">&quot; got version &quot;</span> + version + </span><br><span class="line">                 <span class="string">&quot; expected version &quot;</span> + CURRENT_VERSION);</span><br><span class="line">        setupBadVersionResponse(version);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// this may switch us into SIMPLE</span></span><br><span class="line">      authProtocol = initializeAuthContext(connectionHeaderBuf.get(<span class="number">2</span>));          </span><br><span class="line">      </span><br><span class="line">      dataLengthBuffer.clear();</span><br><span class="line">      connectionHeaderBuf = <span class="keyword">null</span>;</span><br><span class="line">      connectionHeaderRead = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 读完rpc head之后跳出此次循环</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取rpcrequest的内容</span></span><br><span class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">      dataLengthBuffer.flip();</span><br><span class="line">      dataLength = dataLengthBuffer.getInt();</span><br><span class="line">      checkDataLength(dataLength);</span><br><span class="line">      data = ByteBuffer.allocate(dataLength);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    count = channelRead(channel, data);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (data.remaining() == <span class="number">0</span>) &#123;</span><br><span class="line">      dataLengthBuffer.clear();</span><br><span class="line">      data.flip();</span><br><span class="line">      <span class="keyword">boolean</span> isHeaderRead = connectionContextRead;</span><br><span class="line">      <span class="comment">// 先进行授权然后进行内容的读取</span></span><br><span class="line">      processOneRpc(data.array());</span><br><span class="line">      data = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (!isHeaderRead) &#123;</span><br><span class="line">        <span class="comment">// 读取request内容时先进行授权，授权成功之后connectionContextRead变为true</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processOneRpc</span><span class="params">(<span class="keyword">byte</span>[] buf)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, WrappedRpcServerException, InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> callId = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> retry = RpcConstants.INVALID_RETRY_COUNT;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> DataInputStream dis =</span><br><span class="line">        <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> ByteArrayInputStream(buf));</span><br><span class="line">    <span class="keyword">final</span> RpcRequestHeaderProto header =</span><br><span class="line">        decodeProtobufFromStream(RpcRequestHeaderProto.newBuilder(), dis);</span><br><span class="line">    callId = header.getCallId();</span><br><span class="line">    retry = header.getRetryCount();</span><br><span class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">      LOG.debug(<span class="string">&quot; got #&quot;</span> + callId);</span><br><span class="line">    &#125;</span><br><span class="line">    checkRpcHeaders(header);</span><br><span class="line">    <span class="comment">// 第一次连接callId是CONNECTION_CONTEXT_CALL_ID的值为</span></span><br><span class="line">    <span class="comment">// -3，处理授权，验证通过后设置connectionContextRead的值为true</span></span><br><span class="line">    <span class="keyword">if</span> (callId &lt; <span class="number">0</span>) &#123; <span class="comment">// callIds typically used during connection setup</span></span><br><span class="line">      processRpcOutOfBandRequest(header, dis);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!connectionContextRead) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> WrappedRpcServerException(</span><br><span class="line">          RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,</span><br><span class="line">          <span class="string">&quot;Connection context not established&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 随后的连接处理逻辑  </span></span><br><span class="line">      processRpcRequest(header, dis);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (WrappedRpcServerException wrse) &#123; <span class="comment">// inform client of error</span></span><br><span class="line">    Throwable ioe = wrse.getCause();</span><br><span class="line">    <span class="keyword">final</span> Call call = <span class="keyword">new</span> Call(callId, retry, <span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">    setupResponse(authFailedResponse, call,</span><br><span class="line">        RpcStatusProto.FATAL, wrse.getRpcErrorCodeProto(), <span class="keyword">null</span>,</span><br><span class="line">        ioe.getClass().getName(), ioe.getMessage());</span><br><span class="line">    responder.doRespond(call);</span><br><span class="line">    <span class="keyword">throw</span> wrse;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processRpcRequest</span><span class="params">(RpcRequestHeaderProto header,</span></span></span><br><span class="line"><span class="params"><span class="function">     DataInputStream dis)</span> <span class="keyword">throws</span> WrappedRpcServerException,</span></span><br><span class="line"><span class="function">     InterruptedException </span>&#123;</span><br><span class="line">   Class&lt;? extends Writable&gt; rpcRequestClass = </span><br><span class="line">       getRpcRequestWrapper(header.getRpcKind());</span><br><span class="line">   ...</span><br><span class="line">   Writable rpcRequest;</span><br><span class="line">   <span class="keyword">try</span> &#123; <span class="comment">//Read the rpc request</span></span><br><span class="line">     rpcRequest = ReflectionUtils.newInstance(rpcRequestClass, conf);</span><br><span class="line">     <span class="comment">// 进行反序列化，从Writable流中读取数据</span></span><br><span class="line">     rpcRequest.readFields(dis);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// includes runtime exception from newInstance</span></span><br><span class="line">     ...</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 实例化Server端的Call对象，然后放入callQueue中，等待handler来处理</span></span><br><span class="line">   Call call = <span class="keyword">new</span> Call(header.getCallId(), header.getRetryCount(),</span><br><span class="line">       rpcRequest, <span class="keyword">this</span>, ProtoUtil.convert(header.getRpcKind()),</span><br><span class="line">       header.getClientId().toByteArray(), traceSpan);</span><br><span class="line"></span><br><span class="line">   callQueue.put(call);              <span class="comment">// queue the call; maybe blocked here</span></span><br><span class="line">   incRpcCount();  <span class="comment">// Increment the rpc count</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>至此Server端的接受请求阶段已经处理完成，下面由各个handler区共享队列callQueue中取出call进行处理。Handler有多个线程组成，则看Handler的run方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LOG.debug(Thread.currentThread().getName() + <span class="string">&quot;: starting&quot;</span>);</span><br><span class="line">  SERVER.set(Server.<span class="keyword">this</span>);</span><br><span class="line">  ByteArrayOutputStream buf = </span><br><span class="line">    <span class="keyword">new</span> ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);</span><br><span class="line">  <span class="keyword">while</span> (running) &#123;</span><br><span class="line">    TraceScope traceScope = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> Call call = callQueue.take(); <span class="comment">// pop the queue; maybe blocked here</span></span><br><span class="line">      <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">        LOG.debug(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + call + <span class="string">&quot; for RpcKind &quot;</span> + call.rpcKind);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!call.connection.channel.isOpen()) &#123;</span><br><span class="line">        LOG.info(Thread.currentThread().getName() + <span class="string">&quot;: skipped &quot;</span> + call);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      String errorClass = <span class="keyword">null</span>;</span><br><span class="line">      String error = <span class="keyword">null</span>;</span><br><span class="line">      RpcStatusProto returnStatus = RpcStatusProto.SUCCESS;</span><br><span class="line">      RpcErrorCodeProto detailedErr = <span class="keyword">null</span>;</span><br><span class="line">      Writable value = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      CurCall.set(call);</span><br><span class="line">      <span class="keyword">if</span> (call.traceSpan != <span class="keyword">null</span>) &#123;</span><br><span class="line">        traceScope = Trace.continueSpan(call.traceSpan);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Make the call as the user via Subject.doAs, thus associating</span></span><br><span class="line">        <span class="comment">// the call with the Subject</span></span><br><span class="line">        <span class="keyword">if</span> (call.connection.user == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 对call对象进行处理</span></span><br><span class="line">          value = call(call.rpcKind, call.connection.protocolName, call.rpcRequest, </span><br><span class="line">                       call.timestamp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          value = </span><br><span class="line">            call.connection.user.doAs</span><br><span class="line">              (<span class="keyword">new</span> PrivilegedExceptionAction&lt;Writable&gt;() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> Writable <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                   <span class="comment">// make the call</span></span><br><span class="line">                   <span class="keyword">return</span> call(call.rpcKind, call.connection.protocolName, </span><br><span class="line">                               call.rpcRequest, call.timestamp);</span><br><span class="line"></span><br><span class="line">                 &#125;</span><br><span class="line">               &#125;</span><br><span class="line">              );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">      CurCall.set(<span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">synchronized</span> (call.connection.responseQueue) &#123;</span><br><span class="line">        <span class="comment">// setupResponse() needs to be sync&#x27;ed together with </span></span><br><span class="line">        <span class="comment">// responder.doResponse() since setupResponse may use</span></span><br><span class="line">        <span class="comment">// SASL to encrypt response data and SASL enforces</span></span><br><span class="line">        <span class="comment">// its own message ordering.</span></span><br><span class="line">        setupResponse(buf, call, returnStatus, detailedErr, </span><br><span class="line">            value, errorClass, error);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Discard the large buf and reset it back to smaller size </span></span><br><span class="line">        <span class="comment">// to free up heap</span></span><br><span class="line">        <span class="keyword">if</span> (buf.size() &gt; maxRespSize) &#123;</span><br><span class="line">          LOG.warn(<span class="string">&quot;Large response size &quot;</span> + buf.size() + <span class="string">&quot; for call &quot;</span></span><br><span class="line">              + call.toString());</span><br><span class="line">          buf = <span class="keyword">new</span> ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理完之后将call放入responseQueue中</span></span><br><span class="line">        responder.doRespond(call);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (traceScope != <span class="keyword">null</span>) &#123;</span><br><span class="line">        traceScope.close();</span><br><span class="line">      &#125;</span><br><span class="line">      IOUtils.cleanup(LOG, traceScope);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  LOG.debug(Thread.currentThread().getName() + <span class="string">&quot;: exiting&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>handler中处理call的代码<code>value = call(call.rpcKind, call.connection.protocolName, call.rpcRequest, call.timestamp)</code>，实现是在<code>RPC.Server.call</code>中，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Writable <span class="title">call</span><span class="params">(RPC.RpcKind rpcKind, String protocol,</span></span></span><br><span class="line"><span class="params"><span class="function">    Writable rpcRequest, <span class="keyword">long</span> receiveTime)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// getPpcInvoker 得到序列化Engine      </span></span><br><span class="line">  <span class="keyword">return</span> getRpcInvoker(rpcKind).call(<span class="keyword">this</span>, protocol, rpcRequest,</span><br><span class="line">      receiveTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WritableRpcEngine.Server中cal的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Writable <span class="title">call</span><span class="params">(org.apache.hadoop.ipc.RPC.Server server,</span></span></span><br><span class="line"><span class="params"><span class="function">    String protocolName, Writable rpcRequest, <span class="keyword">long</span> receivedTime)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, RPC.VersionMismatch </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">    <span class="comment">// Invoke the protocol method</span></span><br><span class="line"> <span class="keyword">long</span> startTime = Time.now();</span><br><span class="line"> <span class="keyword">int</span> qTime = (<span class="keyword">int</span>) (startTime-receivedTime);</span><br><span class="line"> Exception exception = <span class="keyword">null</span>;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 得到Method</span></span><br><span class="line">    Method method =</span><br><span class="line">        protocolImpl.protocolClass.getMethod(call.getMethodName(),</span><br><span class="line">        call.getParameterClasses());</span><br><span class="line">    method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    server.rpcDetailedMetrics.init(protocolImpl.protocolClass);</span><br><span class="line">    <span class="comment">// 方法的调用，由协议的实现类执行方法    反射</span></span><br><span class="line">    Object value = </span><br><span class="line">        method.invoke(protocolImpl.protocolImpl, call.getParameters());</span><br><span class="line">    <span class="keyword">if</span> (server.verbose) log(<span class="string">&quot;Return: &quot;</span>+value);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ObjectWritable(method.getReturnType(), value);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>call执行完之后，返回到Handler的run方法中继续执行，将call交给<code>responder.doRespond</code>处理，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doRespond</span><span class="params">(Call call)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (call.connection.responseQueue) &#123;</span><br><span class="line">    <span class="comment">// 将call加入到responseQueue中，每个connection都有一个responseQueue</span></span><br><span class="line">    call.connection.responseQueue.addLast(call);</span><br><span class="line">    <span class="comment">// 当responseQueue的大小为1时，直接由Handler线程进行处理</span></span><br><span class="line">    <span class="comment">// 当responseQueue的大小大于1时，由Responder线程进行处理</span></span><br><span class="line">    <span class="keyword">if</span> (call.connection.responseQueue.size() == <span class="number">1</span>) &#123;</span><br><span class="line">      processResponse(call.connection.responseQueue, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求已经处理完成，如果responseQueue大小为1，则直接由Handler调用<code>processResponse</code>返回结果，如果responseQueue的大小大于1，则由Responder线程返回结果，先看下run代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LOG.info(Thread.currentThread().getName() + <span class="string">&quot;: starting&quot;</span>);</span><br><span class="line">  SERVER.set(Server.<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    doRunLoop();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRunLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> lastPurgeTime = <span class="number">0</span>;   <span class="comment">// last check for old calls.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (running) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      waitPending();     <span class="comment">// If a channel is being registered, wait.</span></span><br><span class="line">      writeSelector.select(PURGE_INTERVAL);</span><br><span class="line">      Iterator&lt;SelectionKey&gt; iter = writeSelector.selectedKeys().iterator();</span><br><span class="line">      <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = iter.next();</span><br><span class="line">        iter.remove();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (key.isValid() &amp;&amp; key.isWritable()) &#123;</span><br><span class="line">            <span class="comment">// 从名字来看是异步处理，但怎么体现出来的？</span></span><br><span class="line">              doAsyncWrite(key);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          LOG.info(Thread.currentThread().getName() + <span class="string">&quot;: doAsyncWrite threw exception &quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">long</span> now = Time.now();</span><br><span class="line">      <span class="keyword">if</span> (now &lt; lastPurgeTime + PURGE_INTERVAL) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      lastPurgeTime = now;</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// If there were some calls that have not been sent out for a</span></span><br><span class="line">      <span class="comment">// long time, discard them.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="keyword">if</span>(LOG.isDebugEnabled()) &#123;</span><br><span class="line">        LOG.debug(<span class="string">&quot;Checking for old call responses.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      ArrayList&lt;Call&gt; calls;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// get the list of channels from list of keys.</span></span><br><span class="line">      <span class="comment">// 得到所有的注册键的集合</span></span><br><span class="line">      <span class="keyword">synchronized</span> (writeSelector.keys()) &#123;</span><br><span class="line">        calls = <span class="keyword">new</span> ArrayList&lt;Call&gt;(writeSelector.keys().size());</span><br><span class="line">        iter = writeSelector.keys().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">          SelectionKey key = iter.next();</span><br><span class="line">          Call call = (Call)key.attachment();</span><br><span class="line">          <span class="comment">// 这里得到的list是什么？？？？ 没有处理完再次进入responseQueue的call</span></span><br><span class="line">          <span class="keyword">if</span> (call != <span class="keyword">null</span> &amp;&amp; key.channel() == call.connection.channel) &#123; </span><br><span class="line">            calls.add(call);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span>(Call call : calls) &#123;</span><br><span class="line">        doPurge(call, now);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// we can run out of memory if we have too many threads</span></span><br><span class="line">      <span class="comment">// log the event and sleep for a minute and give</span></span><br><span class="line">      <span class="comment">// some thread(s) a chance to finish</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      LOG.warn(<span class="string">&quot;Out of Memory in server select&quot;</span>, e);</span><br><span class="line">      <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">60000</span>); &#125; <span class="keyword">catch</span> (Exception ie) &#123;&#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      LOG.warn(<span class="string">&quot;Exception in Responder&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAsyncWrite</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Call call = (Call)key.attachment();</span><br><span class="line">  <span class="keyword">if</span> (call == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (key.channel() != call.connection.channel) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;doAsyncWrite: bad channel&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span>(call.connection.responseQueue) &#123;</span><br><span class="line">    <span class="keyword">if</span> (processResponse(call.connection.responseQueue, <span class="keyword">false</span>)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        key.interestOps(<span class="number">0</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">        <span class="comment">/* The Listener/reader might have closed the socket.</span></span><br><span class="line"><span class="comment">         * We don&#x27;t explicitly cancel the key, so not sure if this will</span></span><br><span class="line"><span class="comment">         * ever fire.</span></span><br><span class="line"><span class="comment">         * This warning could be removed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        LOG.warn(<span class="string">&quot;Exception while changing ops : &quot;</span> + e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Processes one response. Returns true if there are no more pending</span></span><br><span class="line"><span class="comment">// data for this channel.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">processResponse</span><span class="params">(LinkedList&lt;Call&gt; responseQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">boolean</span> inHandler)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> error = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">boolean</span> done = <span class="keyword">false</span>;       <span class="comment">// there is more data for this channel.</span></span><br><span class="line">  <span class="keyword">int</span> numElements = <span class="number">0</span>;</span><br><span class="line">  Call call = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (responseQueue) &#123;</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// If there are no items for this channel, then we are done</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      numElements = responseQueue.size();</span><br><span class="line">      <span class="keyword">if</span> (numElements == <span class="number">0</span>) &#123;</span><br><span class="line">        error = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;              <span class="comment">// no more data for this channel.</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Extract the first call</span></span><br><span class="line">      call = responseQueue.removeFirst();</span><br><span class="line">      SocketChannel channel = call.connection.channel;</span><br><span class="line">      <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">        LOG.debug(Thread.currentThread().getName() + <span class="string">&quot;: responding to &quot;</span> + call);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Send as much data as we can in the non-blocking fashion</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="keyword">int</span> numBytes = channelWrite(channel, call.rpcResponse);</span><br><span class="line">      <span class="keyword">if</span> (numBytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果call.rpcResponse写完了则将call.rpcResponse清空</span></span><br><span class="line">      <span class="comment">// 如果没有写完，则再将其放入responseQueue的连头</span></span><br><span class="line">      <span class="comment">// 当Handler没能将结果一次性发送到客户端时,会向该Selector对象注册SelectionKey.OP_WRITE事件</span></span><br><span class="line">      <span class="keyword">if</span> (!call.rpcResponse.hasRemaining()) &#123;</span><br><span class="line">        <span class="comment">//Clear out the response buffer so it can be collected</span></span><br><span class="line">        call.rpcResponse = <span class="keyword">null</span>;</span><br><span class="line">        call.connection.decRpcCount();</span><br><span class="line">        <span class="keyword">if</span> (numElements == <span class="number">1</span>) &#123;    <span class="comment">// last call fully processes.</span></span><br><span class="line">          done = <span class="keyword">true</span>;             <span class="comment">// no more data for this channel.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          done = <span class="keyword">false</span>;            <span class="comment">// more calls pending to be sent.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">          LOG.debug(Thread.currentThread().getName() + <span class="string">&quot;: responding to &quot;</span> + call</span><br><span class="line">              + <span class="string">&quot; Wrote &quot;</span> + numBytes + <span class="string">&quot; bytes.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// If we were unable to write the entire response out, then </span></span><br><span class="line">        <span class="comment">// insert in Selector queue. </span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        call.connection.responseQueue.addFirst(call);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (inHandler) &#123;</span><br><span class="line">          <span class="comment">// set the serve time when the response has to be sent later</span></span><br><span class="line">          call.timestamp = Time.now();</span><br><span class="line">          </span><br><span class="line">          incPending();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Wakeup the thread blocked on select, only then can the call </span></span><br><span class="line">            <span class="comment">// to channel.register() complete.</span></span><br><span class="line">            writeSelector.wakeup();</span><br><span class="line">            channel.register(writeSelector, SelectionKey.OP_WRITE, call);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">            <span class="comment">//Its ok. channel might be closed else where.</span></span><br><span class="line">            done = <span class="keyword">true</span>;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            decPending();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">          LOG.debug(Thread.currentThread().getName() + <span class="string">&quot;: responding to &quot;</span> + call</span><br><span class="line">              + <span class="string">&quot; Wrote partial &quot;</span> + numBytes + <span class="string">&quot; bytes.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      error = <span class="keyword">false</span>;              <span class="comment">// everything went off well</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (error &amp;&amp; call != <span class="keyword">null</span>) &#123;</span><br><span class="line">      LOG.warn(Thread.currentThread().getName()+<span class="string">&quot;, call &quot;</span> + call + <span class="string">&quot;: output error&quot;</span>);</span><br><span class="line">      done = <span class="keyword">true</span>;               <span class="comment">// error. no more data for this channel.</span></span><br><span class="line">      closeConnection(call.connection);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Server端返回结果的过程到此结束，接下来又回到了clinet端，由Connection线程接受Server的Response。代码在Connection中run方法中的receiveRpcResponse，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Receive a response.</span></span><br><span class="line"><span class="comment"> * Because only one receiver, so no synchronization on in.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">receiveRpcResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (shouldCloseConnection.get()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  touch();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> totalLen = in.readInt();</span><br><span class="line">    RpcResponseHeaderProto header = </span><br><span class="line">        RpcResponseHeaderProto.parseDelimitedFrom(in);</span><br><span class="line">    checkResponse(header);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> headerLen = header.getSerializedSize();</span><br><span class="line">    headerLen += CodedOutputStream.computeRawVarint32Size(headerLen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> callId = header.getCallId();</span><br><span class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled())</span><br><span class="line">      LOG.debug(getName() + <span class="string">&quot; got value #&quot;</span> + callId);</span><br><span class="line"></span><br><span class="line">    Call call = calls.get(callId);</span><br><span class="line">    RpcStatusProto status = header.getStatus();</span><br><span class="line">    <span class="keyword">if</span> (status == RpcStatusProto.SUCCESS) &#123;</span><br><span class="line">      Writable value = ReflectionUtils.newInstance(valueClass, conf);</span><br><span class="line">      value.readFields(in);                 <span class="comment">// read value</span></span><br><span class="line">      calls.remove(callId);</span><br><span class="line">      <span class="comment">// 将 value 值设置为call的Response</span></span><br><span class="line">      call.setRpcResponse(value);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// verify that length was correct</span></span><br><span class="line">      <span class="comment">// only for ProtobufEngine where len can be verified easily</span></span><br><span class="line">      <span class="keyword">if</span> (call.getRpcResponse() <span class="keyword">instanceof</span> ProtobufRpcEngine.RpcWrapper) &#123;</span><br><span class="line">        ProtobufRpcEngine.RpcWrapper resWrapper = </span><br><span class="line">            (ProtobufRpcEngine.RpcWrapper) call.getRpcResponse();</span><br><span class="line">        <span class="keyword">if</span> (totalLen != headerLen + resWrapper.getLength()) &#123; </span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RpcClientException(</span><br><span class="line">              <span class="string">&quot;RPC response length mismatch on rpc success&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123; <span class="comment">// Rpc Request failed</span></span><br><span class="line">      ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    markClosed(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setRpcResponse</span><span class="params">(Writable rpcResponse)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.rpcResponse = rpcResponse;</span><br><span class="line">  callComplete();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">callComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.done = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">// 通知在call中由connection.sendRpcRequest之后调用call.wait()的线程</span></span><br><span class="line">  notify();                                 <span class="comment">// notify caller</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>notify之后再次回到Client.call的线程中执行<code>call.getRpcResponse()</code>,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Writable <span class="title">getRpcResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> rpcResponse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码分析完毕，用文字总结下Hadoop RPC的大致流程：</p>
<blockquote>
<p>Client通过代理在invoke中调用client.call之后的流程</p>
</blockquote>
<ol>
<li>远程方法调用信息封装成Call对象，查看当前client与server是否已经建立connection，如果没有则创建一个Connection对象，否则直接get一个connection，将Call对象放到Connection对象中的哈希表calls中; </li>
<li>调用 Connection 类中的sendRpcRequest()方法将当前Call对象发送给Server端，并调用call.wait()阻塞线程; </li>
<li>Server端处理完RPC请求后,将结果通过网络返回给Client端,Client端通过Connection线程调用receiveRpcResponse()函数获取结果; </li>
<li>Client检查结果处理状态(成功还是失败),并将对应 Call 对象从哈希表calls中删除，将结果赋值给call.rpcResponse。 </li>
</ol>
<blockquote>
<p>Server</p>
</blockquote>
<ol>
<li><p>接收请求;该阶段主要任务是接收来自各个客户端的RPC请求,并将它们封装成固定的格式(Call类)放到一个共享队列(callQueue)中,以便进行后续处理。<br>该阶段内部又分为建立连接和接收请求两个子阶段,分别由Listener和Reader两种线程完成。整个Server<strong>只有一个</strong>Listener线程,统一负责监听来自客户端的连接请求,一旦有新的请求到达,它会采用轮询的方式从线程池中选择一个Reader线程进行处理,而Reader线程可同时存在多个,它们分别负责接收一部分客户端连接的RPC请求,至于每个Reader线程负责哪些客户端连接,完全由Listener决定,当前Listener只是采用了简单的轮询分配机制。Listener和Reader线程内部各自包含一个Selector对象,分别用于监听SelectionKey.OP_ACCEPT和SelectionKey.OP_READ 事件。对于Listener线程,主循环的实现体是监听是否有新的连接请求到达,并采用轮询策略选择一个Reader线程处理新连接;对于Reader线程,主循环的实现体是监听(它负责的那部分)客户端连接中是否有新的RPC请求到达,并将新的RPC请求封装成Call对象,放到共享队列callQueue 中。</p>
</li>
<li><p>处理请求;该阶段主要任务是从共享队列callQueue中获取Call对象,执行对应的函数调用,并将结果返回给客户端,这全部由<strong>Handler线程完成</strong>。Server 端可同时存在多个Handler线程,它们并行从_共享队列_中读取Call对象,经执行对应的函数调用后,将尝试着直接将结果返回给对应的客户端。但考虑到某些函数调用返回结果很大或者网络速度过慢,可能难以将结果一次性发送到客户端,此时Handler将尝试着将后续发送任务交给Responder线程。</p>
</li>
<li><p>返回结果;前面提到,每个Handler线程执行完函数调用后,会尝试着将执行结果返回给客户端,但对于特殊情况,比如函数调用返回结果过大或者网络异常情况(网速过慢),会将发送任务交给Responder线程。Server端<strong>仅存在一个</strong>Responder线程,它的内部包含一个Selector对象,用于监听SelectionKey.OP_WRITE事件。当Handler没能将结果一次性发送到客户端时,会向该Selector对象注册SelectionKey.OP_WRITE事件,进而由Responder 线程采用<em>异步方式</em>继续发送未发送完成的结果</p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="http://jomolangma.com/?p=130">http://jomolangma.com/?p=130</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">混绅士</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yuanba.tech/Hadoop%20RPC%20%E8%A7%A3%E6%9E%90.html">http://yuanba.tech/Hadoop%20RPC%20%E8%A7%A3%E6%9E%90.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yuanba.tech" target="_blank">big data decode club</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Hadoop/">Hadoop</a><a class="post-meta__tags" href="/tags/BigData/">BigData</a><a class="post-meta__tags" href="/tags/RPC/">RPC</a></div><div class="post_share"></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/path/to/wechat-reward-image/wechatpay.png" target="_blank"><img class="post-qr-code-img" src="/path/to/wechat-reward-image/wechatpay.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/YARN%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BAsyncDispatcher%E4%BA%8B%E4%BB%B6%E8%B0%83%E5%BA%A6%E5%99%A8.html"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">YARN源码分析之AsyncDispatcher事件调度器</div></div></a></div><div class="next-post pull-right"><a href="/NameNode%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8Acheckpoint%E5%88%86%E6%9E%90.html"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">NameNode元数据及checkpoint分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/Application-fail-RM-change.html" title="Application运行失败导致RM主备切换"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-11-27</div><div class="title">Application运行失败导致RM主备切换</div></div></a></div><div><a href="/HDFS%20HA%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90.html" title="HDFS HA机制解析"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2016-07-14</div><div class="title">HDFS HA机制解析</div></div></a></div><div><a href="/HDFS%20HA%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98%E5%92%8C%E7%A4%BA%E4%BE%8B%E5%9C%BA%E6%99%AF.html" title="HDFS HA相关的几个问题和示例场景"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2016-11-19</div><div class="title">HDFS HA相关的几个问题和示例场景</div></div></a></div><div><a href="/HDFS%20ReplicationMonitor%E5%89%AF%E6%9C%AC%E7%9B%91%E6%8E%A7%E7%BA%BF%E7%A8%8B%E8%A7%A3%E6%9E%90.html" title="HDFS ReplicationMonitor副本监控线程解析"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2016-08-01</div><div class="title">HDFS ReplicationMonitor副本监控线程解析</div></div></a></div><div><a href="/HDFS%20read%E8%A7%A3%E6%9E%90.html" title="HDFS read解析(一)之Open文件流"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2016-11-21</div><div class="title">HDFS read解析(一)之Open文件流</div></div></a></div><div><a href="/HDFS%20read%E8%A7%A3%E6%9E%902%E4%B9%8B%E4%BB%8E%E6%96%87%E4%BB%B6%E6%B5%81%E4%B8%ADread.html" title="HDFS read解析2之从文件流中read"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2016-11-15</div><div class="title">HDFS read解析2之从文件流中read</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/uploads/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">混绅士</div><div class="author-info__description">Any answers you can find in source code.</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">119</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">198</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC"><span class="toc-number">1.</span> <span class="toc-text">RPC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hadoop-RPC"><span class="toc-number">2.</span> <span class="toc-text">Hadoop RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hadoop-RPC-Demo"><span class="toc-number">2.1.</span> <span class="toc-text">Hadoop RPC Demo</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hadoop-RPC-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">Hadoop RPC 源码解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/golang-wasm.html" title="Golang开发wasm程序"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang开发wasm程序"/></a><div class="content"><a class="title" href="/golang-wasm.html" title="Golang开发wasm程序">Golang开发wasm程序</a><time datetime="2022-11-25T13:32:12.000Z" title="发表于 2022-11-25 21:32:12">2022-11-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/wasm-realtime.html" title="基于Wasm的轻量实时计算"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于Wasm的轻量实时计算"/></a><div class="content"><a class="title" href="/wasm-realtime.html" title="基于Wasm的轻量实时计算">基于Wasm的轻量实时计算</a><time datetime="2022-11-05T05:35:12.000Z" title="发表于 2022-11-05 13:35:12">2022-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/scratch-extensions-demo.html" title="scratch自定义扩展"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="scratch自定义扩展"/></a><div class="content"><a class="title" href="/scratch-extensions-demo.html" title="scratch自定义扩展">scratch自定义扩展</a><time datetime="2021-12-14T14:30:20.000Z" title="发表于 2021-12-14 22:30:20">2021-12-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/metabase-import-ide.html" title="metabase导入IDE调试"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="metabase导入IDE调试"/></a><div class="content"><a class="title" href="/metabase-import-ide.html" title="metabase导入IDE调试">metabase导入IDE调试</a><time datetime="2021-12-13T15:31:22.000Z" title="发表于 2021-12-13 23:31:22">2021-12-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/flink-connector-example.html" title="Flink Connector调研"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Flink Connector调研"/></a><div class="content"><a class="title" href="/flink-connector-example.html" title="Flink Connector调研">Flink Connector调研</a><time datetime="2021-11-10T14:30:20.000Z" title="发表于 2021-11-10 22:30:20">2021-11-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2016 - 2022 By 混绅士</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>