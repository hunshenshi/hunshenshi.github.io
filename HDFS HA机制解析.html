<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="google-site-verification" content="0hClWroWscvQbyOyRPhAZWjOZJ6g3SFCdO47yYakvdk">







  <meta name="baidu-site-verification" content="27E5EbutCm">







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hadoop,BigData,HDFS,HA,ZKFC,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="HA整体架构 从上图中，我们可以看出NameNode的高可用架构主要分为下面几个部分： Active NameNode和Standby NameNode：两台NameNode形成互备，一台处于Active状态，为主NameNode，另外一台处于Standby状态，为备NameNode，只有主NameNode才能对外提供读写服务。 主备切换控制器ZKFailoverController：ZKFail">
<meta name="keywords" content="Hadoop,BigData,HDFS,HA,ZKFC">
<meta property="og:type" content="article">
<meta property="og:title" content="HDFS HA机制解析">
<meta property="og:url" content="http://bigdatadecode.club/HDFS HA机制解析.html">
<meta property="og:site_name" content="big data decode club">
<meta property="og:description" content="HA整体架构 从上图中，我们可以看出NameNode的高可用架构主要分为下面几个部分： Active NameNode和Standby NameNode：两台NameNode形成互备，一台处于Active状态，为主NameNode，另外一台处于Standby状态，为备NameNode，只有主NameNode才能对外提供读写服务。 主备切换控制器ZKFailoverController：ZKFail">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://bigdatadecode.club/blogimgs/HDFS%20HA机制解析/ha架构图.png">
<meta property="og:updated_time" content="2016-07-13T16:16:11.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HDFS HA机制解析">
<meta name="twitter:description" content="HA整体架构 从上图中，我们可以看出NameNode的高可用架构主要分为下面几个部分： Active NameNode和Standby NameNode：两台NameNode形成互备，一台处于Active状态，为主NameNode，另外一台处于Standby状态，为备NameNode，只有主NameNode才能对外提供读写服务。 主备切换控制器ZKFailoverController：ZKFail">
<meta name="twitter:image" content="http://bigdatadecode.club/blogimgs/HDFS%20HA机制解析/ha架构图.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://bigdatadecode.club/HDFS HA机制解析.html">





  <title> HDFS HA机制解析 | big data decode club </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-80813521-1', 'auto');
  ga('send', 'pageview');
</script>








  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1260961002&web_id=1260961002" language="JavaScript"></script>
  </div>






  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">big data decode club</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">hunhun -- Any answers you can find in source code.</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://bigdatadecode.club/HDFS HA机制解析.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="混绅士">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="big data decode club">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                HDFS HA机制解析
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-14T00:16:11+08:00">
                2016-07-14
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2016-07-14T00:16:11+08:00">
                2016-07-14
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Hadoop/" itemprop="url" rel="index">
                    <span itemprop="name">Hadoop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/HDFS HA机制解析.html" class="leancloud_visitors" data-flag-title="HDFS HA机制解析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="HA整体架构"><a href="#HA整体架构" class="headerlink" title="HA整体架构"></a>HA整体架构</h2><p><img src="/blogimgs/HDFS HA机制解析/ha架构图.png" alt="HA整体架构图" title="HA整体架构图"></p>
<p>从上图中，我们可以看出NameNode的高可用架构主要分为下面几个部分：</p>
<p>Active NameNode和Standby NameNode：两台NameNode形成互备，一台处于Active状态，为主NameNode，另外一台处于Standby状态，为备NameNode，<strong>只有主NameNode才能对外提供读写服务</strong>。</p>
<p>主备切换控制器ZKFailoverController：ZKFailoverController作为独立的进程运行，对NameNode的主备切换进行总体控制（ZKFailoverController是抽象类，它的实现类是DFSZKFailoverController）。ZKFailoverController通过HealthMonitor线程能及时检测到NameNode的健康状况，在主NameNode故障时借助Zookeeper实现自动的主备选举和切换，当然NameNode目前也支持不依赖于Zookeeper的手动主备切换。</p>
<blockquote>
<p>为啥把监控分开<br>   显然，我们不能在NN进程内进行心跳等信息同步，最简单的原因，一次FullGC就可以让NN挂起十几分钟，所以，必须要有一个独立的短小精悍的watchdog来专门负责监控。这也是一个松耦合的设计，便于扩展或更改。</p>
</blockquote>
<p>Zookeeper集群：为主备切换控制器提供主备选举支持。</p>
<p>共享存储系统：共享存储系统是实现NameNode的高可用最为关键的部分，共享存储系统保存了NameNode在运行过程中所产生的HDFS的元数据。只有active namenode才能往共享存储系统中写数据，active NameNode和standby NameNode通过共享存储系统实现元数据同步。在进行主备切换的时候，新的主NameNode在确认元数据完全同步之后才能继续对外提供服务。</p>
<p>DataNode节点：除了通过共享存储系统共享HDFS的元数据信息之外，<strong>主NameNode和备NameNode还需要共享HDFS的数据块和DataNode之间的映射关系</strong>。<em>DataNode会同时向主NameNode和备NameNode上报数据块的位置信息，但只接收来自active namenode的读写命令</em>。</p>
<a id="more"></a>
<p>这里主要介绍通过<strong>隔离和Quorum Journal Manager(QJM)共享存储空间</strong>实现HDFS HA。</p>
<h2 id="隔离（Fencing）"><a href="#隔离（Fencing）" class="headerlink" title="隔离（Fencing）"></a>隔离（Fencing）</h2><p><strong>隔离(Fencing)是为了防止脑裂，就是保证在任何时候HDFS只有一个Active NN</strong>，主要包括三个方面：</p>
<ul>
<li>共享存储fencing：确保只有一个NN可以写入edits。QJM中每一个JournalNode中均有一个epochnumber，匹配epochnumber的QJM才有权限更新JN。当NN由standby状态切换成active状态时，会重新生成一个epoch number，并更新JN中的epochnumber，以至于以前的ActiveNN中的QJM中的epoch number和JN的epochnumber不匹配，故而原ActiveNN上的QJM没法往JN中写入数据（后面会介绍源码），即形成了fencing</li>
<li>客户端fencing：确保只有一个NN可以响应客户端的请求。</li>
<li>DataNode fencing：确保只有一个NN可以向DN下发命令，譬如删除块，复制块，等等。</li>
</ul>
<p>QJM的Fencing方案只能让原来的Active NN失去对JN的写权限，但是原来的Active NN还是可以响应客户端的请求，对DN进行读。对客户端和DataNode的fence是通过配置dfs.ha.fencing.methods实现的。Hadoop公共库中有两种Fencing实现：sshfence、shell<br>   sshfence：ssh到原Active NN上，使用fuser结束进程（通过tcp端口号定位进程pid，该方法比jps命令更准确）。<br>   shell: run an arbitrary shell command to fence the Active NameNode，即执行一个用户事先定义的shell命令（脚本）完成隔离。</p>
<h2 id="QJM共享存储"><a href="#QJM共享存储" class="headerlink" title="QJM共享存储"></a>QJM共享存储</h2><p>Qurom Journal Manager(QJM)是一个基于Paxos算法实现的HDFS 元数据共享存储的方案。QJM的基本原理就是用2N+1台JournalNode存储EditLog，每次写数据操作有大多数（&gt;=N+1）返回成功时即认为该次写成功，数据不会丢失。这个算法所能容忍的是最多有N台机器挂掉，如果多于N台挂掉，这个算法就失效了。这个原理是基于Paxos算法的。<br>用QJM的方式来实现HA的主要好处有：1）不需要配置额外的高共享存储，这样对于基于commodity hardware的云计算数据中心来说，降低了复杂度和维护成本；2）不在需要单独配置fencing实现，因为QJM本身内置了fencing的功能；3）不存在Single Point Of Failure；4）系统鲁棒性的程度是可配置的（QJM基于Paxos算法，所以如果配置2N+1台JournalNode组成的集群，能容忍最多N台机器挂掉）；5）QJM中存储日志的JournalNode不会因为其中一台的延迟而影响整体的延迟，而且也不会因为JournalNode的数量增多而影响性能（因为NN向JournalNode发送日志是并行的）。</p>
<h2 id="源码分析主备切换"><a href="#源码分析主备切换" class="headerlink" title="源码分析主备切换"></a>源码分析主备切换</h2><p>主备切换主要是通过<code>ZKFailoverController</code>实现的，是一个独立的进程，在hdfs启动脚本之中的进程名为<em>zkfc</em>。<code>ZKFailoverController</code>是一个抽象类，其实现类的<code>DFSZKFailoverController</code>，其内部有三个组件，分别为<em>HealthMonitor、ActiveStandbyElector和FailoverController</em>。其中HealthMonitor是一个独立的线程，循环的检测nn的状态，ActiveStandbyElector主要用来与zk保持心跳和通过创建临时节点进行节点的选举，FailoverController是进行状态转换。</p>
<p>zkfc的程序入口在<code>DFSZKFailoverController</code>中的main方法中，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  DFSZKFailoverController zkfc = DFSZKFailoverController.create(</span><br><span class="line">      parser.getConfiguration());</span><br><span class="line">  </span><br><span class="line">  System.exit(zkfc.run(parser.getRemainingArgs()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DFSZKFailoverController</code>通过create创建一个实例，然后调用run方法启动zkfc。create方法里构造了一个NNHAServiceTarget对象，并由此构建DFSZKFailoverController对象。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DFSZKFailoverController <span class="title">create</span><span class="params">(Configuration conf)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  NNHAServiceTarget localTarget = <span class="keyword">new</span> NNHAServiceTarget(</span><br><span class="line">      localNNConf, nsId, nnId);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DFSZKFailoverController(localNNConf, localTarget);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NNHAServiceTarget主要是用来存放目标nn的fence相关的属性，源码对类的解释是<em>One of the NN NameNodes acting as the target of an administrative command(e.g. failover) ,译：NNs中的一个nn作为管理命令的目标</em>。在其构造方法中对nsId、nnId、addr、zkfc addr和fencer进行赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NNHAServiceTarget</span><span class="params">(Configuration conf,</span></span></span><br><span class="line"><span class="function"><span class="params">    String nsId, String nnId)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">this</span>.addr = NetUtils.createSocketAddr(serviceAddr,</span><br><span class="line">      NameNode.DEFAULT_PORT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.autoFailoverEnabled = targetConf.getBoolean(</span><br><span class="line">      DFSConfigKeys.DFS_HA_AUTO_FAILOVER_ENABLED_KEY,</span><br><span class="line">      DFSConfigKeys.DFS_HA_AUTO_FAILOVER_ENABLED_DEFAULT);</span><br><span class="line">  <span class="keyword">if</span> (autoFailoverEnabled) &#123;</span><br><span class="line">    <span class="keyword">int</span> port = DFSZKFailoverController.getZkfcPort(targetConf);</span><br><span class="line">    <span class="keyword">if</span> (port != <span class="number">0</span>) &#123;</span><br><span class="line">      setZkfcPort(port);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.fencer = NodeFencer.create(targetConf,</span><br><span class="line">        DFSConfigKeys.DFS_HA_FENCE_METHODS_KEY);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (BadFencingConfigurationException e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.fenceConfigError = e;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.nnId = nnId;</span><br><span class="line">  <span class="keyword">this</span>.nsId = nsId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DFSZKFailoverController的对象zkfc创建成功之后，会执行run方法，run方法是在<code>ZKFailoverController</code>中实现的，<em>而run中又调用了doRun方法</em>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doRun</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> HadoopIllegalArgumentException, IOException, InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    initZK(); <span class="comment">// new ActiveStandbyElector，与zk建立连接</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (KeeperException ke) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ERR_CODE_NO_ZK;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在启动zkfc之前，要先对zk进行格式化</span></span><br><span class="line">  <span class="comment">// 格式化时输入参数，启动时不加参数</span></span><br><span class="line">  <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"-formatZK"</span>.equals(args[<span class="number">0</span>])) &#123;</span><br><span class="line">      <span class="keyword">boolean</span> force = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">boolean</span> interactive = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"-force"</span>.equals(args[i])) &#123;</span><br><span class="line">          force = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"-nonInteractive"</span>.equals(args[i])) &#123;</span><br><span class="line">          interactive = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          badArg(args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对zk格式化，默认会zk上创建/hadoop-ha节点</span></span><br><span class="line">      <span class="keyword">return</span> formatZK(force, interactive);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      badArg(args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  initRPC(); <span class="comment">// 初始化rpcServer，创建ZKFCRpcServer对象，使用的是hadoop rpc接口和PB序列化</span></span><br><span class="line">  initHM();  <span class="comment">// 启动HealthMonitor线程</span></span><br><span class="line">  startRPC(); <span class="comment">// 启动rpcServer</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    mainLoop(); <span class="comment">// 循环阻塞等待fatalError错误，然后退出zkfc进程</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    rpcServer.stopAndJoin();</span><br><span class="line">    elector.quitElection(<span class="keyword">true</span>); <span class="comment">// 关闭zk连接，退出选举</span></span><br><span class="line">    healthMonitor.shutdown();</span><br><span class="line">    healthMonitor.join();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先调用<code>initZK()</code>，与zk建立连接，与zk的连接是在<code>ActiveStandbyElector</code>类中，<code>ActiveStandbyElector</code>在构造函数中注册了一个回调函数<code>ElectorCallbacks</code>，而<code>ActiveStandbyElector</code>又实现了<code>StatCallback</code>和<code>StringCallback</code>，分别在调用<code>zkClient.exists</code>和<code>zkClient.create</code>之后通过<code>processResult</code>对其调用结果状态进行处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initZK</span><span class="params">()</span> <span class="keyword">throws</span> HadoopIllegalArgumentException, IOException,</span></span><br><span class="line"><span class="function">    KeeperException </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  elector = <span class="keyword">new</span> ActiveStandbyElector(zkQuorum,</span><br><span class="line">      zkTimeout, getParentZnode(), zkAcls, zkAuths,</span><br><span class="line">      <span class="keyword">new</span> ElectorCallbacks(), maxRetryNum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActiveStandbyElector</span><span class="params">(String zookeeperHostPorts,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> zookeeperSessionTimeout, String parentZnodeName, List&lt;ACL&gt; acl,</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;ZKAuthInfo&gt; authInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">    ActiveStandbyElectorCallback app, <span class="keyword">int</span> maxRetryNum)</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">    HadoopIllegalArgumentException, KeeperException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (app == <span class="keyword">null</span> || acl == <span class="keyword">null</span> || parentZnodeName == <span class="keyword">null</span></span><br><span class="line">      || zookeeperHostPorts == <span class="keyword">null</span> || zookeeperSessionTimeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HadoopIllegalArgumentException(<span class="string">"Invalid argument"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  zkHostPort = zookeeperHostPorts;</span><br><span class="line">  zkSessionTimeout = zookeeperSessionTimeout;</span><br><span class="line">  zkAcl = acl;</span><br><span class="line">  zkAuthInfo = authInfo;</span><br><span class="line">  appClient = app;</span><br><span class="line">  znodeWorkingDir = parentZnodeName;</span><br><span class="line">  <span class="comment">// 临时节点ActiveStandbyElectorLock，用于标识锁</span></span><br><span class="line">  zkLockFilePath = znodeWorkingDir + <span class="string">"/"</span> + LOCK_FILENAME;</span><br><span class="line">  <span class="comment">// 永久节点ActiveBreadCrumb，用于存放active信息</span></span><br><span class="line">  zkBreadCrumbPath = znodeWorkingDir + <span class="string">"/"</span> + BREADCRUMB_FILENAME;</span><br><span class="line">  <span class="keyword">this</span>.maxRetryNum = maxRetryNum;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// createConnection for future API calls</span></span><br><span class="line">  <span class="comment">// 创建zk连接</span></span><br><span class="line">  createConnection();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException, KeeperException </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  zkClient = getNewZooKeeper();</span><br><span class="line">  LOG.debug(<span class="string">"Created new connection for "</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> ZooKeeper <span class="title">getNewZooKeeper</span><span class="params">()</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">    KeeperException </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Unfortunately, the ZooKeeper constructor connects to ZooKeeper and</span></span><br><span class="line">  <span class="comment">// may trigger the Connected event immediately. So, if we register the</span></span><br><span class="line">  <span class="comment">// watcher after constructing ZooKeeper, we may miss that event. Instead,</span></span><br><span class="line">  <span class="comment">// we construct the watcher first, and have it block any events it receives</span></span><br><span class="line">  <span class="comment">// before we can set its ZooKeeper reference.</span></span><br><span class="line">  <span class="comment">// 不幸的是，zk的构造方法连接上zk之后，可能马上触发连接事件。</span></span><br><span class="line">  <span class="comment">// 因此如果构造zk之后注册watcher，可能不会捕获到连接事件。</span></span><br><span class="line">  <span class="comment">// 取而代之的方法是，先构造Watcher，在设置了zk的引用之前，使它阻塞所有的事件</span></span><br><span class="line">  watcher = <span class="keyword">new</span> WatcherWithClientRef();</span><br><span class="line">  ZooKeeper zk = <span class="keyword">new</span> ZooKeeper(zkHostPort, zkSessionTimeout, watcher);</span><br><span class="line">  <span class="comment">// 在watcher中设置zk的引用</span></span><br><span class="line">  watcher.setZooKeeperRef(zk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait for the asynchronous success/failure. This may throw an exception</span></span><br><span class="line">  <span class="comment">// if we don't connect within the session timeout.</span></span><br><span class="line">  watcher.waitForZKConnectionEvent(zkSessionTimeout);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (ZKAuthInfo auth : zkAuthInfo) &#123;</span><br><span class="line">    zk.addAuthInfo(auth.getScheme(), auth.getAuth());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> zk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>initZk主要是通过实例化ActiveStandbyElector，从而得到zkClient，并向其注册一个watcher，这里简单介绍下watcher的实现类<code>WatcherWithClientRef</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WatcherWithClientRef</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ZooKeeper zk;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Latch fired whenever any event arrives. This is used in order</span></span><br><span class="line"><span class="comment">   * to wait for the Connected event when the client is first created.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> CountDownLatch hasReceivedEvent = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Latch used to wait until the reference to ZooKeeper is set.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> CountDownLatch hasSetZooKeeper = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Waits for the next event from ZooKeeper to arrive.</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> connectionTimeoutMs zookeeper connection timeout in milliseconds</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> KeeperException if the connection attempt times out. This will</span></span><br><span class="line"><span class="comment">   * be a ZooKeeper ConnectionLoss exception code.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IOException if interrupted while connecting to ZooKeeper</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 接收连接是否连接成功 </span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">waitForZKConnectionEvent</span><span class="params">(<span class="keyword">int</span> connectionTimeoutMs)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> KeeperException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">// await() 如果hasReceivedEvent为0则立即返回true，</span></span><br><span class="line">    	<span class="comment">// 如果在connectionTimeoutMs内hasReceivedEvent依然不为0，线程依然阻塞则返回false</span></span><br><span class="line">    	<span class="comment">// 当调用countDown()之后，hasReceivedEvent的值会发生变化减1</span></span><br><span class="line">      <span class="keyword">if</span> (!hasReceivedEvent.await(connectionTimeoutMs, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">        LOG.error(<span class="string">"Connection timed out: couldn't connect to ZooKeeper in "</span></span><br><span class="line">            + connectionTimeoutMs + <span class="string">" milliseconds"</span>);</span><br><span class="line">        zk.close();</span><br><span class="line">        <span class="keyword">throw</span> KeeperException.create(Code.CONNECTIONLOSS);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      Thread.currentThread().interrupt();</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(</span><br><span class="line">          <span class="string">"Interrupted when connecting to zookeeper server"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setZooKeeperRef</span><span class="params">(ZooKeeper zk)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkState(<span class="keyword">this</span>.zk == <span class="keyword">null</span>,</span><br><span class="line">        <span class="string">"zk already set -- must be set exactly once"</span>);</span><br><span class="line">    <span class="keyword">this</span>.zk = zk;</span><br><span class="line">    hasSetZooKeeper.countDown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 接收到事件之后，hasReceivedEvent的值减1</span></span><br><span class="line">    hasReceivedEvent.countDown();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      hasSetZooKeeper.await(zkSessionTimeout, TimeUnit.MILLISECONDS);</span><br><span class="line">      <span class="comment">// 捕获到事件之后具体的处理逻辑</span></span><br><span class="line">      ActiveStandbyElector.<span class="keyword">this</span>.processWatchEvent(</span><br><span class="line">          zk, event);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      fatalError(</span><br><span class="line">          <span class="string">"Failed to process watcher event "</span> + event + <span class="string">": "</span> +</span><br><span class="line">          StringUtils.stringifyException(t));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WatcherWithClientRef在构造zk时被注册为默认watcher，主要监听连接或者断开事件。当调用initZk之后，watcher.process会对事件进行处理，连接、断开、过期的状态类型都是EventType.None。</p>
<p><code>initZK()</code>之后也就得到了zkClient，继续<code>doRun</code>，查看是否有参数<em>-formatZK</em>，有则执行formatZK，对zk进行格式化，然后结束程序。这里主要介绍对nn的FailoverController，是没有参数的情况，接下来是初始化rpc服务initRPC，zkfc的rpc类是<code>ZKFCRpcServer</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initRPC</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  InetSocketAddress bindAddr = getRpcAddressToBindTo();</span><br><span class="line">  rpcServer = <span class="keyword">new</span> ZKFCRpcServer(conf, bindAddr, <span class="keyword">this</span>, getPolicyProvider());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ZKFCRpcServer.class</span></span><br><span class="line">ZKFCRpcServer(Configuration conf,</span><br><span class="line">    InetSocketAddress bindAddr,</span><br><span class="line">    ZKFailoverController zkfc,</span><br><span class="line">    PolicyProvider policy) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="keyword">this</span>.zkfc = zkfc;</span><br><span class="line">  <span class="comment">// 使用protocol buffer序列化</span></span><br><span class="line">  RPC.setProtocolEngine(conf, ZKFCProtocolPB.class,</span><br><span class="line">      ProtobufRpcEngine.class);</span><br><span class="line">  ZKFCProtocolServerSideTranslatorPB translator =</span><br><span class="line">      <span class="keyword">new</span> ZKFCProtocolServerSideTranslatorPB(<span class="keyword">this</span>);</span><br><span class="line">  BlockingService service = ZKFCProtocolService</span><br><span class="line">      .newReflectiveBlockingService(translator);</span><br><span class="line">  <span class="comment">// 使用hadoop rpc接口得到rpc server</span></span><br><span class="line">  <span class="comment">// ZKFCProtocol是rpc协议，service是rpc协议的实现类</span></span><br><span class="line">  <span class="comment">// ZKFCProtocolPB是protobuf rpc接口的一个过渡类</span></span><br><span class="line">  <span class="keyword">this</span>.server = <span class="keyword">new</span> RPC.Builder(conf).setProtocol(ZKFCProtocolPB.class)</span><br><span class="line">      .setInstance(service).setBindAddress(bindAddr.getHostName())</span><br><span class="line">      .setPort(bindAddr.getPort()).setNumHandlers(HANDLER_COUNT)</span><br><span class="line">      .setVerbose(<span class="keyword">false</span>).build();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set service-level authorization security policy</span></span><br><span class="line">  <span class="keyword">if</span> (conf.getBoolean(</span><br><span class="line">      CommonConfigurationKeys.HADOOP_SECURITY_AUTHORIZATION, <span class="keyword">false</span>)) &#123;</span><br><span class="line">    server.refreshServiceAcl(conf, policy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是构造了一个zkfc的rpc server，此rpc使用protocol buffer序列化消息，hadoop rpc提供的接口来构造rpc server。rpc协议是在<code>ZKFCProtocol</code>接口中定义的，包含两个方法<code>cedeActive</code>和<code>gracefulFailover</code>，其接口的实现类是<code>ZKFCProtocolServerSideTranslatorPB</code>，消息格式传输的格式是在ZKFCProtocol.proto中定义的。有关hadoop rpc更详细的内容可以查看先前的博客<a href="http://bigdatadecode.club/Hadoop RPC 解析.html">Hadoop RPC 解析</a>。</p>
<p>initRPC之后开始调用initHM，初始化HealthMonitor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  healthMonitor = <span class="keyword">new</span> HealthMonitor(conf, localTarget);</span><br><span class="line">  <span class="comment">// 添加回调函数</span></span><br><span class="line">  healthMonitor.addCallback(<span class="keyword">new</span> HealthCallbacks());</span><br><span class="line">  healthMonitor.addServiceStateCallback(<span class="keyword">new</span> ServiceStateCallBacks());</span><br><span class="line">  healthMonitor.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先来看下HealthMonitor的构造函数，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">HealthMonitor(Configuration conf, HAServiceTarget target) &#123;</span><br><span class="line">  <span class="keyword">this</span>.targetToMonitor = target;</span><br><span class="line">  <span class="keyword">this</span>.conf = conf;</span><br><span class="line">  <span class="comment">// ha.health-monitor.sleep-after-disconnect.ms</span></span><br><span class="line">  <span class="keyword">this</span>.sleepAfterDisconnectMillis = conf.getLong(</span><br><span class="line">      HA_HM_SLEEP_AFTER_DISCONNECT_KEY,</span><br><span class="line">      HA_HM_SLEEP_AFTER_DISCONNECT_DEFAULT);</span><br><span class="line">  <span class="comment">// ha.health-monitor.check-interval.ms 隔多久去检查nn是否健康，默认是1000 </span></span><br><span class="line">  <span class="keyword">this</span>.checkIntervalMillis = conf.getLong(</span><br><span class="line">      HA_HM_CHECK_INTERVAL_KEY,</span><br><span class="line">      HA_HM_CHECK_INTERVAL_DEFAULT);</span><br><span class="line">  <span class="comment">// ha.health-monitor.connect-retry-interval.ms 默认是1000    </span></span><br><span class="line">  <span class="keyword">this</span>.connectRetryInterval = conf.getLong(</span><br><span class="line">      HA_HM_CONNECT_RETRY_INTERVAL_KEY,</span><br><span class="line">      HA_HM_CONNECT_RETRY_INTERVAL_DEFAULT);</span><br><span class="line">  <span class="comment">// ha.health-monitor.rpc-timeout.ms</span></span><br><span class="line">  <span class="keyword">this</span>.rpcTimeout = conf.getInt(</span><br><span class="line">      HA_HM_RPC_TIMEOUT_KEY,</span><br><span class="line">      HA_HM_RPC_TIMEOUT_DEFAULT);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.daemon = <span class="keyword">new</span> MonitorDaemon();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HealthMonitor构造完之后，添加回调类，然后将HealthMonitor线程作为一个<em>守护进程</em>去启动。查看其run方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MonitorDaemon.run HealthMonitor的内部类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (shouldRun) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">      <span class="comment">// 得到rpc的客户端，此时的rpc server是在nn中启动的rpc server</span></span><br><span class="line">      loopUntilConnected();</span><br><span class="line">      <span class="comment">// 对nn进行循环检查</span></span><br><span class="line">      doHealthChecks();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">      Preconditions.checkState(!shouldRun,</span><br><span class="line">          <span class="string">"Interrupted but still supposed to run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doHealthChecks</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (shouldRun) &#123;</span><br><span class="line">    HAServiceStatus status = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> healthy = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      status = proxy.getServiceStatus();</span><br><span class="line">      <span class="comment">// 健康状态检查，异常会抛出</span></span><br><span class="line">      proxy.monitorHealth();</span><br><span class="line">      healthy = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (HealthCheckFailedException e) &#123;</span><br><span class="line">      LOG.warn(<span class="string">"Service health check failed for "</span> + targetToMonitor</span><br><span class="line">          + <span class="string">": "</span> + e.getMessage());</span><br><span class="line">      enterState(State.SERVICE_UNHEALTHY);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      LOG.warn(<span class="string">"Transport-level exception trying to monitor health of "</span> +</span><br><span class="line">          targetToMonitor + <span class="string">": "</span> + t.getLocalizedMessage());</span><br><span class="line">      RPC.stopProxy(proxy);</span><br><span class="line">      proxy = <span class="keyword">null</span>;</span><br><span class="line">      enterState(State.SERVICE_NOT_RESPONDING);</span><br><span class="line">      Thread.sleep(sleepAfterDisconnectMillis);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (status != <span class="keyword">null</span>) &#123;</span><br><span class="line">      setLastServiceStatus(status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (healthy) &#123;</span><br><span class="line">      enterState(State.SERVICE_HEALTHY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 间隔checkIntervalMillis之后继续check healthy</span></span><br><span class="line">    Thread.sleep(checkIntervalMillis);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>健康状态的检测主要是在<code>doHealthChecks</code>中调用<code>monitorHealth</code>，其调用逻辑是NameNodeRpcServer.monitorHealth–&gt;NameNode.monitorHealth，该方法会调用<code>getNamesystem().checkAvailableResources()</code>去检查磁盘是否有足够的可用空间，不够则抛出<code>HealthCheckFailedException</code>异常，在<code>doHealthChecks</code>中被捕获，设置状态为_SERVICE_UNHEALTHY_，该方法也可能抛出别的异常被Throwable捕获，设置状态为_SERVICE_NOT_RESPONDING_。然后调用<code>enterState</code>进行状态的更新</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enterState</span><span class="params">(State newState)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (newState != state) &#123;</span><br><span class="line">    LOG.info(<span class="string">"Entering state "</span> + newState);</span><br><span class="line">    state = newState;</span><br><span class="line">    <span class="keyword">synchronized</span> (callbacks) &#123;</span><br><span class="line">      <span class="comment">// 调用在构造HealthMonitor时注册的回调类</span></span><br><span class="line">      <span class="keyword">for</span> (Callback cb : callbacks) &#123;</span><br><span class="line">        cb.enteredState(newState);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HealthCallbacks</span> <span class="keyword">implements</span> <span class="title">HealthMonitor</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enteredState</span><span class="params">(HealthMonitor.State newState)</span> </span>&#123;</span><br><span class="line">    setLastHealthState(newState);</span><br><span class="line">    <span class="comment">// 检查当前nn的状态，判断是否可用进行选举</span></span><br><span class="line">    recheckElectability();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recheckElectability</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Maintain lock ordering of elector -&gt; ZKFC</span></span><br><span class="line">  <span class="keyword">synchronized</span> (elector) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">boolean</span> healthy = lastHealthState == State.SERVICE_HEALTHY;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">long</span> remainingDelay = delayJoiningUntilNanotime - System.nanoTime(); </span><br><span class="line">      <span class="keyword">if</span> (remainingDelay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (healthy) &#123;</span><br><span class="line">          LOG.info(<span class="string">"Would have joined master election, but this node is "</span> +</span><br><span class="line">              <span class="string">"prohibited from doing so for "</span> +</span><br><span class="line">              TimeUnit.NANOSECONDS.toMillis(remainingDelay) + <span class="string">" more ms"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        scheduleRecheck(remainingDelay);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">switch</span> (lastHealthState) &#123;</span><br><span class="line">      <span class="keyword">case</span> SERVICE_HEALTHY:</span><br><span class="line">        elector.joinElection(targetToData(localTarget));</span><br><span class="line">        <span class="keyword">if</span> (quitElectionOnBadState) &#123;</span><br><span class="line">          quitElectionOnBadState = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">case</span> INITIALIZING:</span><br><span class="line">        LOG.info(<span class="string">"Ensuring that "</span> + localTarget + <span class="string">" does not "</span> +</span><br><span class="line">            <span class="string">"participate in active master election"</span>);</span><br><span class="line">        elector.quitElection(<span class="keyword">false</span>);</span><br><span class="line">        serviceState = HAServiceState.INITIALIZING;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">case</span> SERVICE_UNHEALTHY:</span><br><span class="line">      <span class="keyword">case</span> SERVICE_NOT_RESPONDING:</span><br><span class="line">        LOG.info(<span class="string">"Quitting master election for "</span> + localTarget +</span><br><span class="line">            <span class="string">" and marking that fencing is necessary"</span>);</span><br><span class="line">        elector.quitElection(<span class="keyword">true</span>);</span><br><span class="line">        serviceState = HAServiceState.INITIALIZING;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">case</span> HEALTH_MONITOR_FAILED:</span><br><span class="line">        fatalError(<span class="string">"Health monitor failed!"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unhandled state:"</span> + lastHealthState);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>recheckElectability</code>中匹配到nn的状态是<em>SERVICE_UNHEALTHY</em>或者<em>SERVICE_NOT_RESPONDING</em>则调用<code>elector.quitElection(true)</code>放弃选举</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// needFence为true则需要执行fence</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">quitElection</span><span class="params">(<span class="keyword">boolean</span> needFence)</span> </span>&#123;</span><br><span class="line">  LOG.info(<span class="string">"Yielding from election"</span>);</span><br><span class="line">  <span class="keyword">if</span> (!needFence &amp;&amp; state == State.ACTIVE) &#123;</span><br><span class="line">    <span class="comment">// If active is gracefully going back to standby mode, remove</span></span><br><span class="line">    <span class="comment">// our permanent znode so no one fences us.</span></span><br><span class="line">    tryDeleteOwnBreadCrumbNode();</span><br><span class="line">  &#125;</span><br><span class="line">  reset();</span><br><span class="line">  wantToBeInElection = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  state = State.INIT;</span><br><span class="line">  terminateConnection();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">terminateConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (zkClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LOG.debug(<span class="string">"Terminating ZK connection for "</span> + <span class="keyword">this</span>);</span><br><span class="line">  ZooKeeper tempZk = zkClient;</span><br><span class="line">  zkClient = <span class="keyword">null</span>;</span><br><span class="line">  watcher = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    tempZk.close();</span><br><span class="line">  &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">    LOG.warn(e);</span><br><span class="line">  &#125;</span><br><span class="line">  zkConnectionState = ConnectionState.TERMINATED;</span><br><span class="line">  wantToBeInElection = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>放弃选举其实就是调用ActiveStandbyElector的quitElection，将zkClinet关闭，zk连接关闭之后，之前创建的临时节点<code>ActiveStandbyElectorLock</code>被删除，此时standby节点上的ActiveStandbyElector通过watcher监听到<em>NodeDeleted</em>事件进行选举抢锁（只有standby节点上的watcher能监听到NodeDeleted事件，因为active节点上的watcher随着zkClinet的关闭已经消失了，无法进行监听）。</p>
<p>active节点上的ActiveStandbyElector退出选举之后，HealthMonitor线程继续check nn，等到active nn恢复正常之后重新进行选举。而standby节点上的watcher监听到NodeDeleted事件，由watcher.process处理事件，在process中又调用了<code>ActiveStandbyElector.this.processWatchEvent</code>，下面看下processWatchEvent的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">processWatchEvent</span><span class="params">(ZooKeeper zk, WatchedEvent event)</span> </span>&#123;</span><br><span class="line">  Event.EventType eventType = event.getType();</span><br><span class="line">  <span class="keyword">if</span> (isStaleClient(zk)) <span class="keyword">return</span>;</span><br><span class="line">  LOG.debug(<span class="string">"Watcher event type: "</span> + eventType + <span class="string">" with state:"</span></span><br><span class="line">      + event.getState() + <span class="string">" for path:"</span> + event.getPath()</span><br><span class="line">      + <span class="string">" connectionState: "</span> + zkConnectionState</span><br><span class="line">      + <span class="string">" for "</span> + <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (eventType == Event.EventType.None) &#123;</span><br><span class="line">    <span class="comment">// the connection state has changed</span></span><br><span class="line">    <span class="keyword">switch</span> (event.getState()) &#123;</span><br><span class="line">    <span class="keyword">case</span> SyncConnected:</span><br><span class="line">      LOG.info(<span class="string">"Session connected."</span>);</span><br><span class="line">      <span class="comment">// if the listener was asked to move to safe state then it needs to</span></span><br><span class="line">      <span class="comment">// be undone</span></span><br><span class="line">      ConnectionState prevConnectionState = zkConnectionState;</span><br><span class="line">      zkConnectionState = ConnectionState.CONNECTED;</span><br><span class="line">      <span class="keyword">if</span> (prevConnectionState == ConnectionState.DISCONNECTED &amp;&amp;</span><br><span class="line">          wantToBeInElection) &#123;</span><br><span class="line">        monitorActiveStatus();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Disconnected:</span><br><span class="line">      LOG.info(<span class="string">"Session disconnected. Entering neutral mode..."</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ask the app to move to safe state because zookeeper connection</span></span><br><span class="line">      <span class="comment">// is not active and we dont know our state</span></span><br><span class="line">      zkConnectionState = ConnectionState.DISCONNECTED;</span><br><span class="line">      enterNeutralMode();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Expired:</span><br><span class="line">      <span class="comment">// the connection got terminated because of session timeout</span></span><br><span class="line">      <span class="comment">// call listener to reconnect</span></span><br><span class="line">      LOG.info(<span class="string">"Session expired. Entering neutral mode and rejoining..."</span>);</span><br><span class="line">      enterNeutralMode();</span><br><span class="line">      reJoinElection(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SaslAuthenticated:</span><br><span class="line">      LOG.info(<span class="string">"Successfully authenticated to ZooKeeper using SASL."</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      fatalError(<span class="string">"Unexpected Zookeeper watch event state: "</span></span><br><span class="line">          + event.getState());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// a watch on lock path in zookeeper has fired. so something has changed on</span></span><br><span class="line">  <span class="comment">// the lock. ideally we should check that the path is the same as the lock</span></span><br><span class="line">  <span class="comment">// path but trusting zookeeper for now</span></span><br><span class="line">  String path = event.getPath();</span><br><span class="line">  <span class="keyword">if</span> (path != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (eventType) &#123;</span><br><span class="line">    <span class="keyword">case</span> NodeDeleted:</span><br><span class="line">      <span class="keyword">if</span> (state == State.ACTIVE) &#123;</span><br><span class="line">        enterNeutralMode();</span><br><span class="line">      &#125;</span><br><span class="line">      joinElectionInternal();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> NodeDataChanged:</span><br><span class="line">      monitorActiveStatus();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      LOG.debug(<span class="string">"Unexpected node event: "</span> + eventType + <span class="string">" for path: "</span> + path);</span><br><span class="line">      monitorActiveStatus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// some unexpected error has occurred</span></span><br><span class="line">  fatalError(<span class="string">"Unexpected watch error from Zookeeper"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匹配到<code>NodeDeleted</code>事件，然后执行<code>joinElectionInternal</code>去创建临时节点，进行抢锁,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">joinElectionInternal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Preconditions.checkState(appData != <span class="keyword">null</span>,</span><br><span class="line">      <span class="string">"trying to join election without any app data"</span>);</span><br><span class="line">  <span class="keyword">if</span> (zkClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!reEstablishSession()) &#123;</span><br><span class="line">      fatalError(<span class="string">"Failed to reEstablish connection with ZooKeeper"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  createRetryCount = <span class="number">0</span>;</span><br><span class="line">  wantToBeInElection = <span class="keyword">true</span>;</span><br><span class="line">  createLockNodeAsync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createLockNodeAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  zkClient.create(zkLockFilePath, appData, zkAcl, CreateMode.EPHEMERAL,</span><br><span class="line">      <span class="keyword">this</span>, zkClient);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是否创建成功的结果是在<code>processResult</code>中进行捕获的，此时的<code>ActiveStandbyElector.processResult</code>是实现StringCallback接口需要重写的方法，该类中还有个同名的方法，是实现StatCallback接口需要重写的方法。先来看下捕获create结果的processResult代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * interface implementation of Zookeeper callback for create</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    String name)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  Code code = Code.get(rc);</span><br><span class="line">  <span class="keyword">if</span> (isSuccess(code)) &#123;</span><br><span class="line">    <span class="comment">// we successfully created the znode. we are the leader. start monitoring</span></span><br><span class="line">    <span class="comment">// 创建成功，则进行角色的转变</span></span><br><span class="line">    <span class="keyword">if</span> (becomeActive()) &#123;</span><br><span class="line">      monitorActiveStatus();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      reJoinElectionAfterFailureToBecomeActive();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 节点已存在</span></span><br><span class="line">  <span class="keyword">if</span> (isNodeExists(code)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (createRetryCount == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// znode exists and we did not retry the operation. so a different</span></span><br><span class="line">      <span class="comment">// instance has created it. become standby and monitor lock.</span></span><br><span class="line">      becomeStandby();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if we had retried then the znode could have been created by our first</span></span><br><span class="line">    <span class="comment">// attempt to the server (that we lost) and this node exists response is</span></span><br><span class="line">    <span class="comment">// for the second attempt. verify this case via ephemeral node owner. this</span></span><br><span class="line">    <span class="comment">// will happen on the callback for monitoring the lock.</span></span><br><span class="line">    monitorActiveStatus();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  fatalError(errorMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果创建成功则将当前节点转换为active，执行<code>becomeActive</code>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">becomeActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Stat oldBreadcrumbStat = fenceOldActive();</span><br><span class="line">    writeBreadCrumbNode(oldBreadcrumbStat);</span><br><span class="line">    </span><br><span class="line">    LOG.debug(<span class="string">"Becoming active for "</span> + <span class="keyword">this</span>);</span><br><span class="line">    appClient.becomeActive();</span><br><span class="line">    state = State.ACTIVE;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    LOG.warn(<span class="string">"Exception handling the winning of election"</span>, e);</span><br><span class="line">    <span class="comment">// Caller will handle quitting and rejoining the election.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为防止脑裂，在变为active之前，先检查下是否需要fence，判断是否需要fence的依据是zk上是否有<em>breadcrumb</em>节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Stat <span class="title">fenceOldActive</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">  <span class="keyword">byte</span>[] data;</span><br><span class="line">  LOG.info(<span class="string">"Checking for any old active which needs to be fenced..."</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  	<span class="comment">// 读取当前zk中节点的内容</span></span><br><span class="line">    data = zkDoWithRetries(<span class="keyword">new</span> ZKAction&lt;<span class="keyword">byte</span>[]&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">byte</span>[] run() <span class="keyword">throws</span> KeeperException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> zkClient.getData(zkBreadCrumbPath, <span class="keyword">false</span>, stat);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (KeeperException ke) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isNodeDoesNotExist(ke.code())) &#123;</span><br><span class="line">      LOG.info(<span class="string">"No old node to fence"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If we failed to read for any other reason, then likely we lost</span></span><br><span class="line">    <span class="comment">// our session, or we don't have permissions, etc. In any case,</span></span><br><span class="line">    <span class="comment">// we probably shouldn't become active, and failing the whole</span></span><br><span class="line">    <span class="comment">// thing is the best bet.</span></span><br><span class="line">    <span class="keyword">throw</span> ke;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LOG.info(<span class="string">"Old node exists: "</span> + StringUtils.byteToHexString(data));</span><br><span class="line">  <span class="comment">// appData是当前节点加入选举时的节点信息，也就是standby节点的信息</span></span><br><span class="line">  <span class="keyword">if</span> (Arrays.equals(data, appData)) &#123;</span><br><span class="line">    LOG.info(<span class="string">"But old node has our own data, so don't need to fence it."</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  	<span class="comment">// 当前zk节点的信息与APPData的信息不符，进行fence</span></span><br><span class="line">    appClient.fenceOldActive(data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当前zk的ActiveBreadCrumb节点记录的是active节点的信息，与appData（记录的是standby节点的信息）不一样，则进行fenceOldActive操作，fenceOldActive调用的是在ActiveStandbyElector初始化时注册的回调类里的方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ElectorCallbacks.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fenceOldActive</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">  ZKFailoverController.<span class="keyword">this</span>.fenceOldActive(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ZKFailoverController.class</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fenceOldActive</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">  HAServiceTarget target = dataToTarget(data);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    doFence(target);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    recordActiveAttempt(<span class="keyword">new</span> ActiveAttemptRecord(<span class="keyword">false</span>, <span class="string">"Unable to fence old active: "</span> + StringUtils.stringifyException(t)));</span><br><span class="line">    Throwables.propagate(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doFence</span><span class="params">(HAServiceTarget target)</span> </span>&#123;</span><br><span class="line">  LOG.info(<span class="string">"Should fence: "</span> + target);</span><br><span class="line">  <span class="comment">// 由FailoverController进行切换，如果没有切换成功则进行fence</span></span><br><span class="line">  <span class="keyword">boolean</span> gracefulWorked = <span class="keyword">new</span> FailoverController(conf,</span><br><span class="line">      RequestSource.REQUEST_BY_ZKFC).tryGracefulFence(target);</span><br><span class="line">  <span class="keyword">if</span> (gracefulWorked) &#123;</span><br><span class="line">    <span class="comment">// It's possible that it's in standby but just about to go into active,</span></span><br><span class="line">    <span class="comment">// no? Is there some race here?</span></span><br><span class="line">    LOG.info(<span class="string">"Successfully transitioned "</span> + target + <span class="string">" to standby "</span> +</span><br><span class="line">        <span class="string">"state without fencing"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    target.checkFencingConfigured();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (BadFencingConfigurationException e) &#123;</span><br><span class="line">    LOG.error(<span class="string">"Couldn't fence old active "</span> + target, e);</span><br><span class="line">    recordActiveAttempt(<span class="keyword">new</span> ActiveAttemptRecord(<span class="keyword">false</span>, <span class="string">"Unable to fence old active"</span>));</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用NodeFencer类，进行fence</span></span><br><span class="line">  <span class="keyword">if</span> (!target.getFencer().fence(target)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to fence "</span> + target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>doFence</code>时先调用FailoverController.tryGracefulFence进行状态的转换，该方法通过rpc最终调用<em>NameNode.transitionToStandby()</em>方法，通过<code>state.setState(haContext, STANDBY_STATE)</code>将状态设置为standby，如果设置失败则调用NodeFencer类的fence方法进行强制fence。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">fence</span><span class="params">(HAServiceTarget fromSvc)</span> </span>&#123;</span><br><span class="line">  LOG.info(<span class="string">"====== Beginning Service Fencing Process... ======"</span>);</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 可以设置多个fence method，以回车分隔</span></span><br><span class="line">  <span class="keyword">for</span> (FenceMethodWithArg method : methods) &#123;</span><br><span class="line">    LOG.info(<span class="string">"Trying method "</span> + (++i) + <span class="string">"/"</span> + methods.size() +<span class="string">": "</span> + method);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">// SshFenceByTcpPort 和 ShellCommandFencer 实现了tryFence的具体逻辑</span></span><br><span class="line">      <span class="keyword">if</span> (method.method.tryFence(fromSvc, method.arg)) &#123;</span><br><span class="line">        LOG.info(<span class="string">"====== Fencing successful by method "</span> + method + <span class="string">" ======"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fenceOldActive成功之后则调用<code>writeBreadCrumbNode</code>将当前standby节点的信息写入zk中，通过回调类<code>ElectorCallbacks</code>的becomeActive方法将standby节点变为active。状态转变的过程是通过rpc最终调用NameNode的transitionToActive方法将ACTIVE_STATE设置为当前节点的状态。切换成功之后则进入监控，调用<code>monitorActiveStatus</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">monitorActiveStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> wantToBeInElection;</span><br><span class="line">  LOG.debug(<span class="string">"Monitoring active leader for "</span> + <span class="keyword">this</span>);</span><br><span class="line">  statRetryCount = <span class="number">0</span>;</span><br><span class="line">  monitorLockNodeAsync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">monitorLockNodeAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  zkClient.exists(zkLockFilePath, </span><br><span class="line">      watcher, <span class="keyword">this</span>,</span><br><span class="line">      zkClient);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>zkClient.exists将WatcherWithClientRef注册为watcher，监听ActiveStandbyElectorLock znode的状态，exists的执行结果在processResult中捕获，此处的processResult是ActiveStandbyElector实现StatCallback接口需要重写的方法。先来看下捕获exists结果的processResult代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * interface implementation of Zookeeper callback for monitor (exists)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    Stat stat)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  Code code = Code.get(rc);</span><br><span class="line">  <span class="keyword">if</span> (isSuccess(code)) &#123;</span><br><span class="line">    <span class="comment">// the following owner check completes verification in case the lock znode</span></span><br><span class="line">    <span class="comment">// creation was retried</span></span><br><span class="line">    <span class="keyword">if</span> (stat.getEphemeralOwner() == zkClient.getSessionId()) &#123;</span><br><span class="line">      <span class="comment">// we own the lock znode. so we are the leader</span></span><br><span class="line">      <span class="keyword">if</span> (!becomeActive()) &#123;</span><br><span class="line">        reJoinElectionAfterFailureToBecomeActive();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// we dont own the lock znode. so we are a standby.</span></span><br><span class="line">      becomeStandby();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the watch set by us will notify about changes</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isNodeDoesNotExist(code)) &#123;</span><br><span class="line">    <span class="comment">// the lock znode disappeared before we started monitoring it</span></span><br><span class="line">    enterNeutralMode();</span><br><span class="line">    joinElectionInternal();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时状态已经切换完成，原active节点循环进行<code>doHealthChecks</code>，当节点恢复正常之后则调用ActiveStandbyElector.joinElection恢复选举。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">joinElection</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> HadoopIllegalArgumentException </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HadoopIllegalArgumentException(<span class="string">"data cannot be null"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (wantToBeInElection) &#123;</span><br><span class="line">    LOG.info(<span class="string">"Already in election. Not re-connecting."</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将节点信息写入appData中</span></span><br><span class="line">  appData = <span class="keyword">new</span> <span class="keyword">byte</span>[data.length];</span><br><span class="line">  System.arraycopy(data, <span class="number">0</span>, appData, <span class="number">0</span>, data.length);</span><br><span class="line"></span><br><span class="line">  LOG.debug(<span class="string">"Attempting active election for "</span> + <span class="keyword">this</span>);</span><br><span class="line">  joinElectionInternal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个HA的故障转移到此分析完毕</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要分析了HA模式下，active与standby进行切换的流程，其大致流程是active nn通过HealthMonitor线程(ha.health-monitor.check-interval.ms 默认1000)检测到<em>磁盘空间不足</em>或者<em>rpc调用没有响应</em>，捕获到<em>SERVICE_UNHEALTHY</em>或者<em>SERVICE_NOT_RESPONDING</em>状态，将退出选举，关闭zk连接，此时zk上<em>ActiveStandbyElectorLock</em>临时节点自动删除，standby节点上的watcher监听到NODEDELETED事件，进行抢锁，去zk上创建ActiveStandbyElectorLock节点，<em>创建成功之后进行状态的转换becomActive</em>，在becomeActive时会判断zk上是否存有原active节点创建的<em>ActiveBreadCrumb</em>节点，如果有则进行fence操作，先由<em>FailoverController</em>执行gracefullFence，如果不成功则执行NodeFence的fence方法(fence method有两个，分别是SSHFence和ShellFence)，fence成功之后将当前节点的信息写入ActiveBreadCrumb节点，并将当前节点的状态转换为active。</p>
<p>原active节点的HealthMonitor线程一直循环检测nn的健康状况，等到nn健康之后再将其加入选举，加入选举也就是创建于zk的连接。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>您的肯定，是我装逼的最大的动力！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/path/to/wechat-reward-image/wechatpay.png" alt="混绅士 WeChat Pay">
          <p>微信打赏</p>
        </div>
      
      
    </div>
  </div>


      
    </div>

    <div>
      
        
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      混绅士
    </li>
    
    <!--add wordcount and min2 read by szw-->
    <li class="post-copyright-author">
      <strong>本文字数：</strong>
      17,297
    </li>
    <li class="post-copyright-author">
      <strong>阅读时长：</strong>
      99
    </li>

    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://bigdatadecode.club/HDFS HA机制解析.html" title="HDFS HA机制解析">http://bigdatadecode.club/HDFS HA机制解析.html</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
    </li>
  </ul>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Hadoop/" rel="tag"># Hadoop</a>
          
            <a href="/tags/BigData/" rel="tag"># BigData</a>
          
            <a href="/tags/HDFS/" rel="tag"># HDFS</a>
          
            <a href="/tags/HA/" rel="tag"># HA</a>
          
            <a href="/tags/ZKFC/" rel="tag"># ZKFC</a>
          
        </div>
      

       
        <h3> 相关推荐：</h3><ul class="related-posts"><li><a href="/HDFS HA相关的几个问题和示例场景.html">HDFS HA相关的几个问题和示例场景</a></li><li><a href="/Hadoop-Ozone.html">Hadoop小文件利器Ozone调研</a></li><li><a href="/HDFSCannotObtainBlockLengthForLocatedBlock.html">HDFS之Cannot obtain block length for LocatedBlock异常</a></li><li><a href="/HDFS中atime和mtime.html">HDFS中atime与mtime解析</a></li><li><a href="/HDFS权限.html">HDFS权限</a></li><li><a href="/Hadoop_get_NullPointerException.html">Hadoop get命令返回NullPointerException</a></li><li><a href="/Ozone感悟.html">Ozone感悟</a></li><li><a href="/[译]HDFS恢复过程2.html">HDFS恢复过程2</a></li><li><a href="/my-book.html">姗姗来迟的果实</a></li><li><a href="/常用Hadoop命令.html">常用Hadoop命令</a></li></ul> 
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/hexo启动4000端口无法访问.html" rel="next" title="hexo启动4000端口无法访问">
                <i class="fa fa-chevron-left"></i> hexo启动4000端口无法访问
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/HDFS ReplicationMonitor副本监控线程解析.html" rel="prev" title="HDFS ReplicationMonitor副本监控线程解析">
                HDFS ReplicationMonitor副本监控线程解析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>  
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>      
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "1",
        "bdMiniList": ["tsina", "weixin", "sqq", "douban", "qzone", "twi", "fbook"],
        "bdPic": ""
      },
      "image": {
        "viewList": ["tsina", "weixin", "sqq", "douban", "qzone", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      },
      "slide": {
        "bdImg": "5",
        "bdPos": "left",
        "bdTop": "100"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>       
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="混绅士">
          <p class="site-author-name" itemprop="name">混绅士</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">112</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">181</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <!-- <i class="fa  fa-fw fa-globe"></i> -->
              <!-- modify icon to fire by szw -->
              <i class="fa fa-fire fa-" aria-hidden="true"></i>
              热文推荐
            </div>
            <ul class="links-of-blogroll-list">
              
                <!-- delete li's class by szw -->
                <li>
                  <a href="http://bigdatadecode.club/Spark Streaming 消费kafka到HDFS.html" title="Spark Streaming 消费kafka到HDFS" target="_blank">Spark Streaming 消费kafka到HDFS</a>
                </li>
              
                <!-- delete li's class by szw -->
                <li>
                  <a href="http://bigdatadecode.club/HDFS write解析.html" title="HDFS write解析" target="_blank">HDFS write解析</a>
                </li>
              
                <!-- delete li's class by szw -->
                <li>
                  <a href="http://bigdatadecode.club/Spark编译与部署.html" title="Spark编译与部署" target="_blank">Spark编译与部署</a>
                </li>
              
                <!-- delete li's class by szw -->
                <li>
                  <a href="http://bigdatadecode.club/MapReduce源码解析--环形缓冲区.html" title="MapReduce源码解析--环形缓冲区" target="_blank">MapReduce源码解析--环形缓冲区</a>
                </li>
              
                <!-- delete li's class by szw -->
                <li>
                  <a href="http://bigdatadecode.club/Flume简介及初次使用.html" title="Flume简介及初次使用" target="_blank">Flume简介及初次使用</a>
                </li>
              
                <!-- delete li's class by szw -->
                <li>
                  <a href="http://bigdatadecode.club/实时抓取MySQL的更新数据到Hadoop.html" title="实时抓取MySQL的更新数据到Hadoop" target="_blank">实时抓取MySQL的更新数据到Hadoop</a>
                </li>
              
            </ul>
          </div>


        

        
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/my-book.html" title="姗姗来迟的果实" target="_blank">姗姗来迟的果实</a>
                  </li>
                
                  <li>
                    <a href="/android-app-timeup.html" title="坑娃-防沉迷App" target="_blank">坑娃-防沉迷App</a>
                  </li>
                
                  <li>
                    <a href="/elasticsearch-op.html" title="elasticsearch运维踩坑" target="_blank">elasticsearch运维踩坑</a>
                  </li>
                
                  <li>
                    <a href="/golang-point-address.html" title="golang指针*和取址&傻傻分不清楚" target="_blank">golang指针*和取址&傻傻分不清楚</a>
                  </li>
                
                  <li>
                    <a href="/golang-cache2go-sec.html" title="golang随波逐流之cache2go知识点解读" target="_blank">golang随波逐流之cache2go知识点解读</a>
                  </li>
                
              </ul>
            </div>
          
 

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#HA整体架构"><span class="nav-number">1.</span> <span class="nav-text">HA整体架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#隔离（Fencing）"><span class="nav-number">2.</span> <span class="nav-text">隔离（Fencing）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QJM共享存储"><span class="nav-number">3.</span> <span class="nav-text">QJM共享存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码分析主备切换"><span class="nav-number">4.</span> <span class="nav-text">源码分析主备切换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>

          <div class="post-toc-wrap sidebar-panel sidebar-panel-active" style="margin: 0 2px; text-align: left;">
            
              <div class="links-of-blogroll motion-element links-of-blogroll-inline">
                <div class="links-of-blogroll-title">
                  <!-- <i class="fa  fa-fw fa-globe"></i> -->
                  <!-- modify icon to fire by szw -->
                  <i class="fa fa-fire fa-" aria-hidden="true"></i>
                  热文推荐
                </div>
                <ul class="links-of-blogroll-list">
                  
                    <!-- delete li's class by szw -->
                    <li>
                      <a href="http://bigdatadecode.club/Spark Streaming 消费kafka到HDFS.html" title="Spark Streaming 消费kafka到HDFS" target="_blank">Spark Streaming 消费kafka到HDFS</a>
                    </li>
                  
                    <!-- delete li's class by szw -->
                    <li>
                      <a href="http://bigdatadecode.club/HDFS write解析.html" title="HDFS write解析" target="_blank">HDFS write解析</a>
                    </li>
                  
                    <!-- delete li's class by szw -->
                    <li>
                      <a href="http://bigdatadecode.club/Spark编译与部署.html" title="Spark编译与部署" target="_blank">Spark编译与部署</a>
                    </li>
                  
                    <!-- delete li's class by szw -->
                    <li>
                      <a href="http://bigdatadecode.club/MapReduce源码解析--环形缓冲区.html" title="MapReduce源码解析--环形缓冲区" target="_blank">MapReduce源码解析--环形缓冲区</a>
                    </li>
                  
                    <!-- delete li's class by szw -->
                    <li>
                      <a href="http://bigdatadecode.club/Flume简介及初次使用.html" title="Flume简介及初次使用" target="_blank">Flume简介及初次使用</a>
                    </li>
                  
                    <!-- delete li's class by szw -->
                    <li>
                      <a href="http://bigdatadecode.club/实时抓取MySQL的更新数据到Hadoop.html" title="实时抓取MySQL的更新数据到Hadoop" target="_blank">实时抓取MySQL的更新数据到Hadoop</a>
                    </li>
                  
                </ul>
              </div>
            
  
            
                <div class="links-of-blogroll motion-element links-of-blogroll-block">
                  <div class="links-of-blogroll-title">
                    <!-- modify icon to fire by szw -->
                    <i class="fa fa-history fa-" aria-hidden="true"></i>
                    近期文章
                  </div>
                  <ul class="links-of-blogroll-list">
                    
                    
                      <li>
                        <a href="/my-book.html" title="姗姗来迟的果实" target="_blank">姗姗来迟的果实</a>
                      </li>
                    
                      <li>
                        <a href="/android-app-timeup.html" title="坑娃-防沉迷App" target="_blank">坑娃-防沉迷App</a>
                      </li>
                    
                      <li>
                        <a href="/elasticsearch-op.html" title="elasticsearch运维踩坑" target="_blank">elasticsearch运维踩坑</a>
                      </li>
                    
                      <li>
                        <a href="/golang-point-address.html" title="golang指针*和取址&傻傻分不清楚" target="_blank">golang指针*和取址&傻傻分不清楚</a>
                      </li>
                    
                      <li>
                        <a href="/golang-cache2go-sec.html" title="golang随波逐流之cache2go知识点解读" target="_blank">golang随波逐流之cache2go知识点解读</a>
                      </li>
                    
                  </ul>
                </div>
              
          </div>

        </section>
      <!--/noindex-->
      

      

    </div>

  </aside>



        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">混绅士</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


<!--add total count by szw-->
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共679.7k字</span>
</div>
        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user">本站访客数</i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye">本站总访问量</i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("nP29Qpe35cHgQTQIFL94dGoW-gzGzoHsz", "eVPY9SfyVH11gSsbPBEcAQM0");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

</body>
</html>
