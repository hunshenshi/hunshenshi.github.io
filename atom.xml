<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>big data decode club</title>
  
  <subtitle>hunhun -- Any answers you can find in source code.</subtitle>
  <link href="http://yuanba.tech/atom.xml" rel="self"/>
  
  <link href="http://yuanba.tech/"/>
  <updated>2023-08-05T19:58:12.000Z</updated>
  <id>http://yuanba.tech/</id>
  
  <author>
    <name>混绅士</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IoTeX本地standalone模式及合约部署</title>
    <link href="http://yuanba.tech/iotex-standalone.html"/>
    <id>http://yuanba.tech/iotex-standalone.html</id>
    <published>2023-08-05T19:58:12.000Z</published>
    <updated>2023-08-05T19:58:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>BlockChain众所周知信奉的是<code>天下没有免费的午餐</code>，任何操作都是要收费的。此时如果你想进行些测试相关的内容或者只是想了解学习下，就不太方便进行操作。<br>所以这里记录下IoTeX如何本地部署standalone模式，并且使用Remix进行合约部署。</p><blockquote><p>其实现在docker技术已比较普及，IoTeX也提供了很多docker容器，也可以直接使用，这里由于个人原因采用从源码的方式进行部署</p></blockquote><h2 id="本地部署standalone"><a href="#本地部署standalone" class="headerlink" title="本地部署standalone"></a>本地部署standalone</h2><p>从github上clone源码 <code>git clone git@github.com:iotexproject/iotex-core.git</code>，进入repo目录，执行<code>make run</code>。<br>这里大概率会报错，内容是缺少某个文件，报错内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2023-08-03T18:14:33.725+0800ERRORfactory/statedb.go:99Failed to execute state factory creation option 0x49a7520: failed to open kvstore patch, /var/data/trie.db.patch: open /var/data/trie.db.patch: no such file or directory&#123;&quot;ioAddr&quot;: &quot;io1ppjspvypu7e3y93vg9tc3csauf097ht5zl69tq&quot;&#125;</span><br></pre></td></tr></table></figure><p>该文件需要从另一个repo中获取，将其仓库clone到本地<code>git@github.com:iotexproject/iotex-bootstrap.git</code>，将 <code>trie.db.patch</code> 复制到 <code>/var/data</code> 目录中，再次执行 <code>make run</code> 即可。</p><p>如果没有报什么错，就代表启动成功了，启动成功之后会自动挖块，块的高度会发生变化。</p><h2 id="Remix链接本地IoTeX私链进行合约部署"><a href="#Remix链接本地IoTeX私链进行合约部署" class="headerlink" title="Remix链接本地IoTeX私链进行合约部署"></a>Remix链接本地IoTeX私链进行合约部署</h2><p>Remix可以使用在线模式也可以进行本地模式，这里直接使用在线模式，在<code>deploy</code>中选择<code>metamask</code>模式。<br><img src="/blogimgs/iotex-standalone/remix-contract.png" alt="Remix链接MetaMask" title="Remix链接MetaMask"></p><p>然后会跳转到<code>MetaMask</code>页面，添加一个本地standalone网络即可<br><img src="/blogimgs/iotex-standalone/standalone-network.png" alt="Standalone网络" title="Standalone网络"></p><blockquote><p>添加standalone网络时，要先将standalone节点运行起来</p></blockquote><p>此时细心的你会发现Remix虽然连上了本地私链，但是账号余额显示是0，依然不能进行合约部署，接下来就是给账户增加余额，一种简单粗暴的方式就是将其<code>MetaMask</code>中的账户地址设置为<code>genesis</code>地址，<strong>不过这里有一点需要注意，设置genesis地址之后，需要删除原先运行的数据，默认是在<code>/var/data</code>目录下。</strong> 删除之后再次启动standalone就会发现已有余额了，可用随便造了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;BlockChain众所周知信奉的是&lt;code&gt;天下没有免费的午餐&lt;/code&gt;，任何操作都是要收费的。此时如果你想进行些测试相关的内容或者只是想了解学习下，就不太方便进行操作。&lt;br&gt;所以这里记录下IoTeX如何本地部署standalone模式，并且使用Remix进行合约</summary>
      
    
    
    
    <category term="BlockChain" scheme="http://yuanba.tech/categories/BlockChain/"/>
    
    
    <category term="BlockChain" scheme="http://yuanba.tech/tags/BlockChain/"/>
    
    <category term="IoTeX" scheme="http://yuanba.tech/tags/IoTeX/"/>
    
    <category term="Remix" scheme="http://yuanba.tech/tags/Remix/"/>
    
    <category term="Contract" scheme="http://yuanba.tech/tags/Contract/"/>
    
  </entry>
  
  <entry>
    <title>说浅不浅的谈下CA认证</title>
    <link href="http://yuanba.tech/golang-ca-demo.html"/>
    <id>http://yuanba.tech/golang-ca-demo.html</id>
    <published>2023-01-04T14:53:12.000Z</published>
    <updated>2023-01-09T14:26:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>当Http协议变成Https协议时需要CA证书，简单场景下只需在Nginx上配置CA证书即可，后端服务无需更改。<br>但是当不存在类似Nginx的服务时，就需要后端服务进行调整，加载CA证书，使其支持Https协议。</p><p>本篇文章主要介绍下Golang如何进行CA认证。</p><span id="more"></span><h2 id="CA证书生成"><a href="#CA证书生成" class="headerlink" title="CA证书生成"></a>CA证书生成</h2><p>因为<code>go 1.15</code>之后废弃了<code>CommonName</code>，所以在生成证书时有所区别，为了方便证书的生成，针对不同的证书制定不同的配置文件。</p><h3 id="生成CA根证书"><a href="#生成CA根证书" class="headerlink" title="生成CA根证书"></a>生成CA根证书</h3><p>进入ca根证书所在目录，这里是<code>./ca/</code></p><ol><li>新建ca.conf文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[ req ]</span><br><span class="line">default_bits       = 4096</span><br><span class="line">distinguished_name = req_distinguished_name</span><br><span class="line"></span><br><span class="line">[ req_distinguished_name ]</span><br><span class="line">countryName                 = GB</span><br><span class="line">countryName_default         = BeiJing</span><br><span class="line">stateOrProvinceName         = State or Province Name (full name)</span><br><span class="line">stateOrProvinceName_default = BeiJing</span><br><span class="line">localityName                = Locality Name (eg, city)</span><br><span class="line">localityName_default        = BeiJing</span><br><span class="line">organizationName            = Organization Name (eg, company)</span><br><span class="line">organizationName_default    = Step</span><br><span class="line">commonName                  = localhost</span><br><span class="line">commonName_max              = 64</span><br><span class="line">commonName_default          = localhost</span><br></pre></td></tr></table></figure><ol start="2"><li>生成CA密钥</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out ca.key 4096</span><br></pre></td></tr></table></figure><ol start="3"><li>生成CA证书</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -days 365 -subj &quot;/C=GB/L=Beijing/O=github/CN=localhost&quot; -key ca.key -out ca.crt -config ca.conf</span><br></pre></td></tr></table></figure><h3 id="生成服务端证书"><a href="#生成服务端证书" class="headerlink" title="生成服务端证书"></a>生成服务端证书</h3><p>进入server证书存放目录，这里是<code>./server/</code></p><ol><li>新建server.conf文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[ req ]</span><br><span class="line">default_bits       = 2048</span><br><span class="line">distinguished_name = req_distinguished_name</span><br><span class="line"></span><br><span class="line">[ req_distinguished_name ]</span><br><span class="line">countryName                 = Country Name (2 letter code)</span><br><span class="line">countryName_default         = CN</span><br><span class="line">stateOrProvinceName         = State or Province Name (full name)</span><br><span class="line">stateOrProvinceName_default = BeiJing</span><br><span class="line">localityName                = Locality Name (eg, city)</span><br><span class="line">localityName_default        = BeiJing</span><br><span class="line">organizationName            = Organization Name (eg, company)</span><br><span class="line">organizationName_default    = Step</span><br><span class="line">commonName                  = CommonName (e.g. server FQDN or YOUR name)</span><br><span class="line">commonName_max              = 64</span><br><span class="line">commonName_default          = XXX(自定义,客户端需要此字段做匹配)</span><br><span class="line">[ req_ext ]</span><br><span class="line">subjectAltName = @alt_names</span><br><span class="line">[alt_names]</span><br><span class="line">DNS.1   = localhost</span><br><span class="line">IP      = 127.0.0.1</span><br></pre></td></tr></table></figure><ol start="2"><li>生成server端密钥</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out server.key 2048</span><br></pre></td></tr></table></figure><ol start="3"><li>生成CSR</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new  -subj &quot;/C=GB/L=Beijing/O=github/CN=localhost&quot; -key server.key -out server.csr -config server.conf</span><br></pre></td></tr></table></figure><ol start="4"><li>根据根证书生成服务端证书</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -sha256 -CA ca.crt -CAkey ../ca/ca.key -CAcreateserial -days 365 -in server.csr -out server.crt -extensions req_ext -extfile server.conf</span><br></pre></td></tr></table></figure><h3 id="生成客户端证书"><a href="#生成客户端证书" class="headerlink" title="生成客户端证书"></a>生成客户端证书</h3><p>进入client证书存放目录，这里是<code>./client/</code></p><ol><li>生成client端密钥</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out client.key 2048</span><br></pre></td></tr></table></figure><ol start="2"><li>生成CSR</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -subj &quot;/C=GB/L=Beijing/O=github/CN=localhost&quot;  -key client.key -out client.csr </span><br></pre></td></tr></table></figure><ol start="3"><li>根据根证书生成客户端证书</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -sha256 -CA ca.crt -CAkey ../ca/ca.key -CAcreateserial -days 365 -in client.csr -out client.crt</span><br></pre></td></tr></table></figure><p>根证书、服务器端证书和客户端证书生成之后就可以配置CA认证了，客户端证书只有在双向认证时才需要，服务器端证书和根证书是开启CA认证必须的文件。</p><h2 id="CA认证Demo"><a href="#CA认证Demo" class="headerlink" title="CA认证Demo"></a>CA认证Demo</h2><p>Golang在代码层次开启CA认证功能，需要加载相应证书，根据加载的证书分为单向认证和双向认证。</p><h3 id="单向认证"><a href="#单向认证" class="headerlink" title="单向认证"></a>单向认证</h3><p>单向认证是在server端加载server证书和CA认证中心的根证书，开启CA认证，核心代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载CA, 添加进 caCertPool</span></span><br><span class="line">caCert, err := ioutil.ReadFile(dir + <span class="string">&quot;/ca/ca.crt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;try to load ca err&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">caCertPool := x509.NewCertPool()</span><br><span class="line">caCertPool.AppendCertsFromPEM(caCert)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载服务端证书(生产环境当中, 证书是第三方进行签名的, 而非自定义CA)</span></span><br><span class="line">srvCert, err := tls.LoadX509KeyPair(dir+<span class="string">&quot;/server/server.crt&quot;</span>, dir+<span class="string">&quot;/server/server.key&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;try to load key &amp; crt err&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 配置tls加载证书</span></span><br><span class="line">config := &amp;tls.Config&#123;</span><br><span class="line">Certificates: []tls.Certificate&#123;srvCert&#125;, </span><br><span class="line">CipherSuites: []<span class="keyword">uint16</span>&#123;</span><br><span class="line">tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,</span><br><span class="line">tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动https server</span></span><br><span class="line">server := &amp;http.Server&#123;</span><br><span class="line">Addr:      <span class="string">&quot;:1443&quot;</span>,</span><br><span class="line">Handler:   mux,</span><br><span class="line">TLSConfig: config,</span><br><span class="line">ErrorLog:  log.New(os.Stdout, <span class="string">&quot;&quot;</span>, log.Lshortfile|log.Ldate|log.Ltime),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http2.ConfigureServer(server, &amp;http2.Server&#123;&#125;)</span><br><span class="line"></span><br><span class="line">err = server.ListenAndServeTLS(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;ListenAndServeTLS err&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在浏览器中输入<code>https://localhost:1443/</code>，由于服务端证书是自有认证中心生成的，浏览器中并没有该服务端证书的根证书，所以浏览器会报错，报错内容如下：</p><p><img src="/blogimgs/golang-ca/dan.png"><br>然后点击最下方的<code>继续浏览localhost</code>即可访问。</p><h3 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h3><p>双向认证开启后，客户端在请求时需携带客户端证书和根证书，服务端还需开启验证客户端证书配置，相关代码如下：</p><p>服务端只需修改tls.config，增加客户端证书验证配置，然后重启服务即可。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 配置tls加载证书</span></span><br><span class="line">config := &amp;tls.Config&#123;</span><br><span class="line">Certificates: []tls.Certificate&#123;srvCert&#125;, </span><br><span class="line">ClientCAs:          caCertPool,                </span><br><span class="line">InsecureSkipVerify: <span class="literal">true</span>,                       </span><br><span class="line">ClientAuth: tls.RequireAndVerifyClientCert,     </span><br><span class="line">CipherSuites: []<span class="keyword">uint16</span>&#123;</span><br><span class="line">tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,</span><br><span class="line">tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端加载客户端证书，这里直接使用golang写了个客户端，也可以使用<code>curl</code>访问。核心代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载CA证书(生产环境不需要这一步)</span></span><br><span class="line">caCrt, err := ioutil.ReadFile(dir + <span class="string">&quot;/ca/ca.crt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;try to load ca err, &quot;</span> + err.Error())</span><br><span class="line">&#125;</span><br><span class="line">caCertPool := x509.NewCertPool()</span><br><span class="line">caCertPool.AppendCertsFromPEM(caCrt)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载客户端证书</span></span><br><span class="line">cliCert, err := tls.LoadX509KeyPair(dir+<span class="string">&quot;/client/client.crt&quot;</span>, dir+<span class="string">&quot;/client/client.key&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;try to load key &amp; key err, &quot;</span> + err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config := &amp;tls.Config&#123;</span><br><span class="line">Certificates: []tls.Certificate&#123;cliCert&#125;, </span><br><span class="line">RootCAs:            caCertPool,  </span><br><span class="line">InsecureSkipVerify: <span class="literal">false</span>,       </span><br><span class="line">ServerName:         <span class="string">&quot;localhost&quot;</span>, </span><br><span class="line">&#125;</span><br><span class="line">config.BuildNameToCertificate()</span><br><span class="line"></span><br><span class="line">client = &amp;http.Client&#123;</span><br><span class="line">Transport: &amp;http.Transport&#123;</span><br><span class="line">TLSClientConfig: config,</span><br><span class="line">&#125;,</span><br><span class="line">Timeout: <span class="number">10</span> * time.Second,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时如果在浏览器中访问<code>https://localhost:1443/</code>，会无法访问，而且也不能忽略证书，因为服务端要求认证客户端证书，而浏览器中又没有客户端证书，所以无法访问，页面显示如下：</p><p><img src="/blogimgs/golang-ca/error.png"></p><p>到此，关于CA认证的简单使用就结束了，熟悉了单向认证和双向认证的使用效果。<br>但是我调研CA认证需要解决的场景是多个客户端向服务端发送数据，服务端验证客户端证书是否合法，<strong>比较不同的是多个客户端的证书并不是由同一个认证中心颁发的</strong>，这就需要服务端在接收到客户端请求时，根据客户端的证书去动态的加载对应认证中心生成的服务端证书。</p><h2 id="动态加载证书"><a href="#动态加载证书" class="headerlink" title="动态加载证书"></a>动态加载证书</h2><p>这个场景的需求有两个：</p><ol><li>验证客户端的证书</li><li>验证客户端证书时需加载对应的服务端证书<br>要想满足<strong>需求1则必须开启双向认证</strong>，其次要想加载对应的服务端证书就得根据客户端的证书动态加载服务端证书，动态加载的功能通过<code>GetConfigForClient</code>和<code>ServerName</code>来实现。其核心代码如下：</li></ol><p>服务端也是只需修改tls.config即可，如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">config := &amp;tls.Config&#123;</span><br><span class="line"><span class="comment">// 加载server自己的证书</span></span><br><span class="line">Certificates: []tls.Certificate&#123;srvCert&#125;, <span class="comment">// 服务器证书</span></span><br><span class="line"></span><br><span class="line">CipherSuites: []<span class="keyword">uint16</span>&#123;</span><br><span class="line">tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,</span><br><span class="line">tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">GetConfigForClient: <span class="function"><span class="keyword">func</span><span class="params">(info *tls.ClientHelloInfo)</span> <span class="params">(*tls.Config, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> info.ServerName == <span class="string">&quot;localhost&quot;</span> &#123;</span><br><span class="line">srvCert, _ = tls.LoadX509KeyPair(dir+<span class="string">&quot;/server/server.crt&quot;</span>, dir+<span class="string">&quot;/server/server.key&quot;</span>)</span><br><span class="line"></span><br><span class="line">caCert, err := ioutil.ReadFile(dir + <span class="string">&quot;/ca/ca.crt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;try to load ca err&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">caCertPool.AppendCertsFromPEM(caCert)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> info.ServerName == <span class="string">&quot;localhost1&quot;</span> &#123;</span><br><span class="line">srvCert, _ = tls.LoadX509KeyPair(dir+<span class="string">&quot;/server1/server.crt&quot;</span>, dir+<span class="string">&quot;/server1/server.key&quot;</span>)</span><br><span class="line"></span><br><span class="line">caCert, err := ioutil.ReadFile(dir + <span class="string">&quot;/ca1/ca.crt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;try to load ca err&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">caCertPool.AppendCertsFromPEM(caCert)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">serverConf := &amp;tls.Config&#123;</span><br><span class="line">GetCertificate: <span class="function"><span class="keyword">func</span><span class="params">(hi *tls.ClientHelloInfo)</span> <span class="params">(*tls.Certificate, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;srvCert, <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br><span class="line">ClientAuth:         tls.RequireAndVerifyClientCert,</span><br><span class="line">ClientCAs:          caCertPool,</span><br><span class="line">InsecureSkipVerify: <span class="literal">true</span>,</span><br><span class="line"><span class="comment">//VerifyPeerCertificate: getClientValidator(hi),</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> serverConf, <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端通过<code>GetConfigForClient</code>从<code>ClientHelloInfo</code>中获取客户端请求中的<code>ServerName</code>，根据其加载不同的服务端证书即可。</p><p>在客户端，则需要不同的客户端加载各自的证书即可，需要注意的就是在<code>tls.Config</code>中的<code>ServerName</code>属性配置自己向CA认证中心时申请证书时所标注的<code>CommonName</code>，服务端就是根据<code>ServerName</code>加载对应的服务端证书的(同样生成服务端证书时CommonName需与ServerName一致)。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">config := &amp;tls.Config&#123;</span><br><span class="line">Certificates: []tls.Certificate&#123;cliCert&#125;, </span><br><span class="line">RootCAs:            caCertPool,  </span><br><span class="line">InsecureSkipVerify: <span class="literal">false</span>,       </span><br><span class="line">ServerName:         <span class="string">&quot;localhost&quot;</span>, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样服务端就可以认证不同的客户端证书了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当Http协议变成Https协议时需要CA证书，简单场景下只需在Nginx上配置CA证书即可，后端服务无需更改。&lt;br&gt;但是当不存在类似Nginx的服务时，就需要后端服务进行调整，加载CA证书，使其支持Https协议。&lt;/p&gt;
&lt;p&gt;本篇文章主要介绍下Golang如何进行CA认证。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="http://yuanba.tech/categories/Golang/"/>
    
    
    <category term="Golang" scheme="http://yuanba.tech/tags/Golang/"/>
    
    <category term="CA" scheme="http://yuanba.tech/tags/CA/"/>
    
    <category term="Https" scheme="http://yuanba.tech/tags/Https/"/>
    
  </entry>
  
  <entry>
    <title>RxGo常用算子手册</title>
    <link href="http://yuanba.tech/rxgo-examples.html"/>
    <id>http://yuanba.tech/rxgo-examples.html</id>
    <published>2022-12-02T13:32:12.000Z</published>
    <updated>2022-12-02T15:12:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>ReactiveX简称为Rx，是基于事件流的一个异步编程API，其中事件流被称为Observable，事件流需要被Observer订阅才有意义。</p><p>Rx有多种编程语言实现，RxJava/RxJS/Rx.NET/RxClojure/RxSwift。其中RxGo是Rx的Go语言实现。</p><p>下面就来介绍下RxGo中常用的算子使用样例。</p><span id="more"></span><h2 id="Observable-amp-Observe"><a href="#Observable-amp-Observe" class="headerlink" title="Observable &amp; Observe"></a>Observable &amp; Observe</h2><p>RxGO中事件流被抽象成<code>Observable</code>，<code>Observable</code>中的事件需要被订阅之后才能被消费，使用<code>Observe</code>进行订阅。<br>下面是段创建事件流和订阅的代码段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">observable := rxgo.Just(<span class="string">&quot;Hello, World!&quot;</span>)()</span><br><span class="line">ch := observable.Observe()</span><br><span class="line">item := &lt;-ch</span><br><span class="line">fmt.Println(item.V)</span><br></pre></td></tr></table></figure><h2 id="Transforming算子"><a href="#Transforming算子" class="headerlink" title="Transforming算子"></a>Transforming算子</h2><blockquote><p>Buffer</p></blockquote><p>根据某个规则将<code>Observable</code>中的事件缓存下来然后一起发送出去。这个规则可以是根据<em>事件的条数</em>(<code>BufferWithCount</code>)或者根据<em>时间间隔</em>(<code>BufferWithTime</code>)，当然也可以根据时间间隔和事件条数(<code>BufferWithTimeOrCount</code>)。</p><p>下面的样例是根据事件条数的缓存规则进行发送事件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/reactivex/rxgo/v2&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Create the producer</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> rxgo.Item, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> time.Tick(time.Second) &#123;</span><br><span class="line">ch &lt;- rxgo.Of(i)</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">observable := rxgo.FromChannel(ch).BufferWithCount(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item := <span class="keyword">range</span> observable.Observe() &#123;</span><br><span class="line">fmt.Println(item.V)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每秒向channel中发送一个数字，<code>Observable</code>缓存3个，然后发出，输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0 1 2]</span><br><span class="line">[3 4 5]</span><br><span class="line">[6 7 8]</span><br><span class="line">[9 10 11]</span><br></pre></td></tr></table></figure><p>观察输出的内容可以看出<code>item.V</code>是一个<code>[]interface&#123;&#125;</code>，如果不使用<code>Buffer</code>算子的话，<code>item.V</code>是一个<code>interface&#123;&#125;</code>，所以<code>Buffer</code>算子其后再接其他算子的时候需要注意其事件是一个<code>Slice</code>，而不再是一个普通的<code>interface&#123;&#125;</code></p><blockquote><p>FlatMap</p></blockquote><p><code>FlatMap</code>是将<code>Observable</code>中的事件解析成一个<code>Observable</code>，代码示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/reactivex/rxgo/v2&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">observable := rxgo.Just(<span class="string">&quot;Hello, World!&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;Golang World&quot;</span>)().FlatMap(<span class="function"><span class="keyword">func</span><span class="params">(item rxgo.Item)</span> <span class="title">rxgo</span>.<span class="title">Observable</span></span> &#123;</span><br><span class="line">obs := rxgo.Just(strings.Split(item.V.(<span class="keyword">string</span>), <span class="string">&quot; &quot;</span>))()</span><br><span class="line"><span class="keyword">return</span> obs</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item := <span class="keyword">range</span> observable.Observe() &#123;</span><br><span class="line">fmt.Println(item.V)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FlatMap</code>将每个事件根据<code>&quot; &quot;</code>进行拆分成一个<code>slice</code>，并将其封装成一个<code>Observable</code>发送出去。其输出内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hello,</span><br><span class="line">World!</span><br><span class="line">World</span><br><span class="line">Golang</span><br><span class="line">World</span><br></pre></td></tr></table></figure><blockquote><p>Map </p></blockquote><p><code>Map</code>是将<code>Observable</code>中的一个事件封装成另一个事件，发送出去。使用方式较为简单，其示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">observable := rxgo.Just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)().</span><br><span class="line">Map(<span class="function"><span class="keyword">func</span><span class="params">(_ context.Context, i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> i.(<span class="keyword">int</span>) * <span class="number">10</span>, <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>输出如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">20</span><br><span class="line">30</span><br></pre></td></tr></table></figure><blockquote><p>Scan</p></blockquote><p>对<code>Observable</code>中的一个事件apply一个function，并将其处理的结果发送出去，其使用方式类似<code>Reduce</code>算子，示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/reactivex/rxgo/v2&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">observable := rxgo.Just(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>)().</span><br><span class="line">Scan(<span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, i <span class="keyword">interface</span>&#123;&#125;, i2 <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i2, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s,%s&quot;</span>, i.(<span class="keyword">string</span>), i2.(<span class="keyword">string</span>)), <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item := <span class="keyword">range</span> observable.Observe() &#123;</span><br><span class="line">fmt.Println(item.V)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例是将目前发送过的事件进行拼接，然后进行发送。其输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">a,b</span><br><span class="line">a,b,c</span><br><span class="line">a,b,c,d</span><br></pre></td></tr></table></figure><blockquote><p>GroupByDynamic</p></blockquote><p>根据规则将<code>Observable</code>中的事件进行分组(<em>分组个数没有限制</em>)，然后将其分组结果封装成<code>GroupedObservables</code>发送出去。示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/reactivex/rxgo/v2&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">observable := rxgo.Range(<span class="number">0</span>, <span class="number">24</span>).GroupByDynamic(<span class="function"><span class="keyword">func</span><span class="params">(item rxgo.Item)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> strconv.Itoa(item.V.(<span class="keyword">int</span>) % <span class="number">2</span>)</span><br><span class="line">&#125;, rxgo.WithBufferedChannel(<span class="number">12</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> observable.Observe() &#123;</span><br><span class="line">groupedObservable := i.V.(rxgo.GroupedObservable)</span><br><span class="line">key := groupedObservable.Key</span><br><span class="line">fmt.Printf(<span class="string">&quot;New observable: %s\n&quot;</span>, key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> groupedObservable.Observe() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;key: %s, item: %v\n&quot;</span>, key, i.V)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GroupByDynamic</code>中的<code>func</code>定义了分组的规则<code>strconv.Itoa(item.V.(int) % 2)</code>，也就是说分组的key就是<code>strconv.Itoa(item.V.(int) % 2)</code>，<code>Observe</code>之后从channel中接收<code>GroupedObservable</code>，然后再进行数据获取。其输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">New observable: 0</span><br><span class="line">key: 0, item: 0</span><br><span class="line">...</span><br><span class="line">key: 0, item: 22</span><br><span class="line">New observable: 1</span><br><span class="line">key: 1, item: 1</span><br><span class="line">...</span><br><span class="line">key: 1, item: 23</span><br></pre></td></tr></table></figure><p>不过这里有个buff需要注意下，<code>GroupByDynamic</code>中传入了<code>rxgo.WithBufferedChannel(12)</code>，这个buff是用来做什么的呢？长度又是怎么定义的呢？</p><p>通过源码可得知这个buff是一个channel，是用来存储<em>分组</em>中的元素的。在上面的例子中如果buff的长度设置的小于12，其程序会被block住。之所以会被block住是因为当前程序从<code>Observe</code>中订阅数据是串行的，只消费了0号分组中buff中的数据，而1号分组中buff的数据并没有消费，其channel已填满数据，无法再写入数据，所以程序被block住了。</p><p>所以这个长度之所以是12，是因为24个数，分2组，每组12个，buff的长度又正好是12个，串行消费数据并不会造成channel阻塞。</p><p>但是实际使用过程中并不能准备评估每组的个数，那这个buff又该怎么设置呢？</p><p>解决方法是协程来订阅<code>GroupedObservable</code>，调整后的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/reactivex/rxgo/v2&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">observable := rxgo.Range(<span class="number">0</span>, <span class="number">24</span>).GroupByDynamic(<span class="function"><span class="keyword">func</span><span class="params">(item rxgo.Item)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> item.V.(<span class="keyword">int</span>) &lt;= <span class="number">5</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> item.V.(<span class="keyword">int</span>) &lt;= <span class="number">11</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;2&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> item.V.(<span class="keyword">int</span>) &lt;= <span class="number">17</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> item.V.(<span class="keyword">int</span>) &lt;= <span class="number">23</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;2&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;3&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;, rxgo.WithBufferedChannel(<span class="number">2</span>)) </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> observable.Observe() &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">groupedObservable := i.V.(rxgo.GroupedObservable)</span><br><span class="line">key := groupedObservable.Key</span><br><span class="line">fmt.Printf(<span class="string">&quot;New observable: %s\n&quot;</span>, key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> groupedObservable.Observe() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;key: %s, item: %v\n&quot;</span>, key, i.V)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Hour)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用协程来订阅<code>GroupedObservable</code>，每个分组中的数据都能被及时消费掉，并不会造成buff阻塞，所以这里buff只是设置成<code>rxgo.WithBufferedChannel(2)</code>。</p><blockquote><p>Window</p></blockquote><p><code>Window</code>算子较为简单，根据事件个数或者时间间隔将窗口中的事件发送到一个<code>Observable</code>中。其中<code>Window</code>算子与<code>Buffer</code>算子效果上类似，只是<code>Window</code>是将窗口中的事件封装成一个<code>Observable</code>，而<code>Buffer</code>算子是将缓存中的事件当成一个新的事件发出。</p><p><code>Window</code>算子示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/reactivex/rxgo/v2&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">observe := rxgo.Just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)().WindowWithCount(<span class="number">2</span>).Observe()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item := <span class="keyword">range</span> observe &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;new obs...&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> item.V.(rxgo.Observable).Observe() &#123;</span><br><span class="line">fmt.Println(i.V)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出的结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new obs...</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">new obs...</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">new obs...</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="Filtering算子"><a href="#Filtering算子" class="headerlink" title="Filtering算子"></a>Filtering算子</h2><blockquote><p>Filter </p></blockquote><p><code>Filter</code>算子用于过滤符合条件的事件，使用方式较为简单，其代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">observable := rxgo.Just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)().</span><br><span class="line">Filter(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> i != <span class="number">2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Combining算子"><a href="#Combining算子" class="headerlink" title="Combining算子"></a>Combining算子</h2><blockquote><p>Join</p></blockquote><p><code>Join</code>是将两个<code>Observable</code>中规定时间间隔中的事件进行笛卡尔积处理，示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/reactivex/rxgo/v2&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">observable := rxgo.Just(</span><br><span class="line"><span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span>&#123;<span class="string">&quot;tt&quot;</span>: <span class="number">1</span>, <span class="string">&quot;V&quot;</span>: <span class="number">1</span>&#125;,</span><br><span class="line"><span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span>&#123;<span class="string">&quot;tt&quot;</span>: <span class="number">4</span>, <span class="string">&quot;V&quot;</span>: <span class="number">2</span>&#125;,</span><br><span class="line"><span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span>&#123;<span class="string">&quot;tt&quot;</span>: <span class="number">7</span>, <span class="string">&quot;V&quot;</span>: <span class="number">3</span>&#125;,</span><br><span class="line">)().Join(<span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, l <span class="keyword">interface</span>&#123;&#125;, r <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">&quot;l&quot;</span>: l,</span><br><span class="line"><span class="string">&quot;r&quot;</span>: r,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;, rxgo.Just(</span><br><span class="line"><span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span>&#123;<span class="string">&quot;tt&quot;</span>: <span class="number">2</span>, <span class="string">&quot;V&quot;</span>: <span class="number">5</span>&#125;,</span><br><span class="line"><span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span>&#123;<span class="string">&quot;tt&quot;</span>: <span class="number">3</span>, <span class="string">&quot;V&quot;</span>: <span class="number">6</span>&#125;,</span><br><span class="line"><span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span>&#123;<span class="string">&quot;tt&quot;</span>: <span class="number">5</span>, <span class="string">&quot;V&quot;</span>: <span class="number">7</span>&#125;,</span><br><span class="line">)(), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123; </span><br><span class="line"><span class="keyword">return</span> time.Unix(<span class="number">0</span>, i.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span>)[<span class="string">&quot;tt&quot;</span>]*<span class="number">1000000</span>)</span><br><span class="line">&#125;, rxgo.WithDuration(<span class="number">2</span>*time.Millisecond))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item := <span class="keyword">range</span> observable.Observe() &#123;</span><br><span class="line">fmt.Println(fmt.Sprintf(<span class="string">&quot;item:%v&quot;</span>, item.V))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Join</code>算子是将固定时间间隔中的事件进行处理，这个间隔是由<code>rxgo.WithDuration(2*time.Millisecond)</code>控制的，时间获取方式是又第三个参数<code>func(i interface&#123;&#125;) time.Time</code>方法决定的。</p><p>两条流中的事件是否进行join，是事件根据<code>func(i interface&#123;&#125;) time.Time</code>获取时间，两者时间的差值是否在<code>rxgo.WithDuration(2*time.Millisecond)</code>中，如果再则join。</p><p>上例中左流中的<code>&quot;tt&quot;: 1</code>与右流中的<code>&quot;tt&quot;: 2</code>和<code>&quot;tt&quot;: 3</code>进行join，不与<code>&quot;tt&quot;: 5</code>进行join是因为<code>5-1=4&gt;rxgo.WithDuration(2*time.Millisecond)</code>。</p><p>其输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">item:map[l:map[V:1 tt:1] r:map[V:5 tt:2]]</span><br><span class="line">item:map[l:map[V:1 tt:1] r:map[V:6 tt:3]]</span><br><span class="line">item:map[l:map[V:2 tt:4] r:map[V:5 tt:2]]</span><br><span class="line">item:map[l:map[V:2 tt:4] r:map[V:6 tt:3]]</span><br><span class="line">item:map[l:map[V:2 tt:4] r:map[V:7 tt:5]]</span><br><span class="line">item:map[l:map[V:3 tt:7] r:map[V:7 tt:5]]</span><br></pre></td></tr></table></figure><h2 id="Mathematical和Aggregate算子"><a href="#Mathematical和Aggregate算子" class="headerlink" title="Mathematical和Aggregate算子"></a>Mathematical和Aggregate算子</h2><blockquote><p>Average</p></blockquote><p>计算<code>Observable</code>中事件的平均值，示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observable := rxgo.Just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)().AverageInt() <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure><p>实际使用中，由于<code>Observable</code>都是<code>Hot Observable</code>，所以<code>Average</code>类的算子(<code>Count</code>,<code>Max</code>,<code>Min</code>,<code>Sum</code>)往往结合<code>Group</code>算子和<code>Window</code>算子结合使用。<br>将上面<code>Group</code>的算子中的<code>range groupedObservable.Observe()</code>代码改成<code>groupedObservable.AverageInt().Observe()</code>，就是一个具体的<code>Average</code>算子。</p><blockquote><p>Reduce</p></blockquote><p><code>Reduce</code>对<code>Observable</code>中的每个事件apply一个function，并将其<em>最后一个事件</em>发送出去，与<code>Scan</code>算子的区别是<code>Scan</code>算子是将其所有事件发出，而<code>Reduce</code>只发出最后一个事件。示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/reactivex/rxgo/v2&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">observable := rxgo.Just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)().</span><br><span class="line">Reduce(<span class="function"><span class="keyword">func</span><span class="params">(_ context.Context, acc <span class="keyword">interface</span>&#123;&#125;, elem <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> acc == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> elem, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> acc.(<span class="keyword">int</span>) + elem.(<span class="keyword">int</span>), <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item := <span class="keyword">range</span> observable.Observe() &#123;</span><br><span class="line">fmt.Println(fmt.Sprintf(<span class="string">&quot;item:%v&quot;</span>, item.V))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item:6</span><br></pre></td></tr></table></figure><p>对比下<code>Scan</code>算子，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/reactivex/rxgo/v2&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">observable := rxgo.Just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)().</span><br><span class="line">Scan(<span class="function"><span class="keyword">func</span><span class="params">(_ context.Context, acc <span class="keyword">interface</span>&#123;&#125;, elem <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> acc == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> elem, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> acc.(<span class="keyword">int</span>) + elem.(<span class="keyword">int</span>), <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item := <span class="keyword">range</span> observable.Observe() &#123;</span><br><span class="line">fmt.Println(fmt.Sprintf(<span class="string">&quot;item:%v&quot;</span>, item.V))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">item:1</span><br><span class="line">item:3</span><br><span class="line">item:6</span><br></pre></td></tr></table></figure><p>对比之后发现<code>Reduce</code>算子只输出了6，而<code>Scan</code>算子输出了1、3、6。</p><p><code>Reduce</code>算子也往往结合<code>Group</code>算子一起使用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ReactiveX简称为Rx，是基于事件流的一个异步编程API，其中事件流被称为Observable，事件流需要被Observer订阅才有意义。&lt;/p&gt;
&lt;p&gt;Rx有多种编程语言实现，RxJava/RxJS/Rx.NET/RxClojure/RxSwift。其中RxGo是Rx的Go语言实现。&lt;/p&gt;
&lt;p&gt;下面就来介绍下RxGo中常用的算子使用样例。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="http://yuanba.tech/categories/Golang/"/>
    
    
    <category term="Golang" scheme="http://yuanba.tech/tags/Golang/"/>
    
    <category term="RxGo" scheme="http://yuanba.tech/tags/RxGo/"/>
    
    <category term="Stream" scheme="http://yuanba.tech/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>Golang开发wasm程序</title>
    <link href="http://yuanba.tech/golang-wasm.html"/>
    <id>http://yuanba.tech/golang-wasm.html</id>
    <published>2022-11-25T13:32:12.000Z</published>
    <updated>2022-11-25T15:12:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>wasm以小巧安全的特性受到广泛的关注，但是他也有很多的局限性。<br>这些局限性可以通过<code>Host Function</code>进行扩展，使得<em>wasm</em>与<em>host</em>能够进行交互，完成更多的功能。</p><p><code>Host Function</code>需要<code>import</code>到wasm中，同样wasm中的function需要<code>export</code>到host中才能调用。</p><p>本篇主要记录下在Golang下，<code>wasm function</code>如何与<code>host function</code>进行交互。</p><span id="more"></span><h2 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h2><ol><li>使用wazero或者wasmtime-go作为wasm的runtime</li><li>Tinygo编译Golang为wasm文件</li></ol><h2 id="为什么需要Host-Function"><a href="#为什么需要Host-Function" class="headerlink" title="为什么需要Host Function"></a>为什么需要<code>Host Function</code></h2><p><code>Host Function</code>指在<code>Host</code>程序里定义的方法。某些方面wasm还不太完善，比如默认情况下不能在终端上打印信息，比如<code>fmt.Println(&quot;Hello&quot;)</code>，此时就可以在<code>host</code>程序中创建一个<code>Print(string)</code>方法，让wasm调用这个<code>Print(string)</code>方法。</p><p>在Golang中需要wasm runtime将<code>Host Function</code>(比如<code>Print(string)</code>)加载到wasm中即可运行，这个操作从wasm角度看，为<code>import</code>。</p><p><img src="/blogimgs/golang-wasm/print-import.png"></p><h2 id="show-me-code"><a href="#show-me-code" class="headerlink" title="show me code"></a>show me code</h2><p><em>wasm</em>与<em>host</em>进行交互涉及到<code>import</code>和<code>export</code>操作，通过代码具体展示何时使用<code>import</code>和<code>export</code>，以及在tinygo中又该如何使用。</p><h3 id="1-Golang创建wasm模块"><a href="#1-Golang创建wasm模块" class="headerlink" title="1. Golang创建wasm模块"></a>1. Golang创建wasm模块</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export add </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="keyword">uint32</span>, y <span class="keyword">uint32</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1标记的空<code>main</code>函数是tinygo编译wasm时需要的</li><li>2标记的是将<code>add</code>方法导出到<code>host</code>，这样就可以在host程序中调用wasm模块</li></ul><p>使用tinygo将golang编译为wasm模块<br><code>tinygo build -o hello.wasm -scheduler=none --no-debug -target wasi ./hello.go</code></p><h3 id="2-编写host程序调用wasm模块"><a href="#2-编写host程序调用wasm模块" class="headerlink" title="2. 编写host程序调用wasm模块"></a>2. 编写<code>host</code>程序调用wasm模块</h3><p><code>host</code>模块是用<code>Wazero</code>runtime编写，首先创建一个WebAssembly Runtime，然后实例化一个WebAssembly module，这样<code>host</code>程序就能调用<code>wasm function</code>了。代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;context&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/tetratelabs/wazero&quot;</span></span><br><span class="line">  <span class="string">&quot;github.com/tetratelabs/wazero/wasi_snapshot_preview1&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ctx := context.Background()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">  r := wazero.NewRuntimeWithConfig(</span><br><span class="line">    ctx, wazero.NewRuntimeConfig().</span><br><span class="line">    WithWasmCore2())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">defer</span> r.Close(ctx) </span><br><span class="line"></span><br><span class="line">  _, err := wasi_snapshot_preview1.Instantiate(ctx, r)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Panicln(err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">  helloWasm, err := os.ReadFile(<span class="string">&quot;./hello.wasm&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Panicln(err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">  mod, err := r.InstantiateModuleFromBinary(ctx, helloWasm)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Panicln(err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">  addWasmModuleFunction := mod.ExportedFunction(<span class="string">&quot;add&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line">  result, err := addWasmModuleFunction.Call(ctx, <span class="number">20</span>, <span class="number">22</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Panicln(err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;result:&quot;</span>, result[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1标记的是创建一个WebAssembly Runtime</li><li>2标记的是加载一个wasm模块</li><li>3标记的是实例化一个WebAssembly module</li><li>4标记的是获取一个<code>wasm function</code> <strong>add</strong>的引用</li><li>5标记的是在host程序中调用wasm</li></ul><p>然后可以像运行正常Go程序那样执行<code>go run main.go</code>，输出是<code>result: 42</code></p><p>这个基础例子展示了wasm模块的常规用法，主要展示了host程序如何调用wasm模块。</p><ol><li>但是wasm模块如何调用<code>host function</code>呢？</li><li>在Go编写的wasm模块中，使用<code>export</code>关键字标记host程序可调用的<code>wasm function</code>，那<code>host function</code>又是如何标记被wasm模块调用的呢？</li></ol><p>带着这两个疑问看下面这一节内容。</p><h2 id="export-import-傻傻分不清楚"><a href="#export-import-傻傻分不清楚" class="headerlink" title="export import 傻傻分不清楚"></a>export import 傻傻分不清楚</h2><p>上面说wasm局限性时提到无法在终端打印信息，需要在<code>host function</code>中定义一个<code>Print(string)</code>方法，然后在wasm模块中调用，现在就在<code>host</code>程序中定义一个在终端打印数字的方法<code>hostLogUint32</code>。</p><blockquote><p>hostLogUint32</p></blockquote><p>wasm模块调用<code>host function</code>需要在host程序中和wasm中都进行改动</p><ul><li>host程序中的改动</li></ul><ol><li>定义一个<code>logUint32</code>方法</li><li>export <code>logUint32</code>方法到Wasm runtime种，为了方便标记<code>logUint32</code> export的名字为<code>hostLogUint32</code></li></ol><ul><li>wasm程序中的改动</li></ul><ol><li>import <code>hostLogUint32</code>方法</li><li>在wasm模块中调用<code>hostLogUint32</code>方法在终端打印一个数字</li></ol><p><img src="/blogimgs/golang-wasm/hostLogUint32.png"></p><p>看下具体的代码改动，在<code>main.go</code>中添加<code>logUint32</code>方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logUint32</span><span class="params">(value <span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;🤖:&quot;</span>, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在runtime中export <code>logUint32</code>方法为<code>hostLogUint32</code>，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_, errEnv := wasmRuntime.NewModuleBuilder(<span class="string">&quot;env&quot;</span>).</span><br><span class="line">  ExportFunction(<span class="string">&quot;hostLogUint32&quot;</span>, logUint32).</span><br><span class="line">  Instantiate(ctx, wasmRuntime)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> errEnv != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Panicln(<span class="string">&quot;env/host function(s) error:&quot;</span>, errEnv)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在wasm模块中import <code>hostLogUint32</code>，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//export hostLogUint32</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hostLogUint32</span><span class="params">(value <span class="keyword">uint32</span>)</span></span></span><br></pre></td></tr></table></figure><p><strong>这里是不是有人开始疑惑了，不是说好import嘛，怎么还是export呀？？？我当时可是困扰了好久好久。。。</strong><br><strong>这里<code>//export hostLogUint32</code>其实是wasm模块import <code>host function</code>，可以注意到这里的<code>hostLogUint32</code>并没有方法体，这个可以用来区分是export还是import</strong></p><p>最后就是在wasm模块中调用<code>host function</code>了，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export hostLogUint32</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hostLogUint32</span><span class="params">(value <span class="keyword">uint32</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export add</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="keyword">uint32</span>, y <span class="keyword">uint32</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">  res := x + y</span><br><span class="line">  hostLogUint32(res)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序准备好之后就可以运行，由于wasm模块也发生了变化，所以需要重新编译wasm文件，执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tinygo build -o hello.wasm -scheduler=none --no-debug -target wasi ./hello.go</span><br><span class="line"></span><br><span class="line">go run main.go</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出如下</span></span><br><span class="line">🤖: 42         # from the Wasm module</span><br><span class="line">result: 42     # from the host program</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>写这篇文章的主要目的其实想理解tinygo中export的用法，因为在参考wasm相关教程中<code>host function</code>需要import到wasm中才能使用，但是tinygo中并没有提供<code>import</code>关键字，这使我一度怀疑代码有问题，为了消除疑虑所以才查找了很多资料。</p><p>我的理解是tinygo中的<code>export</code>关键字有时间充当将wasm模块中的方法export到host的功能，有时也充当将<code>host function</code>中的方法import到wasm模块的功能，那这两种场景如何区分呢？是看带有<code>export</code>关键字的方法是否有<code>方法体</code>，如何有就是<code>export</code>，没有则是<code>import</code>。这个结果从<code>hostLogUint32</code>的解析图中可以猜想到，我们还可以将编译之后的wasm文件进行反编译进行验证。</p><p>wasm文件反编译使用的是<code>wasm-decompile</code>命令，具体命令为<code>wasm-decompile log.wasm -o log.dcmp</code>，查看<code>log.dcmp</code>文件可看到import和export标注的方法。</p><p><a href="https://www.wasm.builders/k33g_org/extend-wasm-with-host-functions-thanks-to-wazero-3n0n">参考</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;wasm以小巧安全的特性受到广泛的关注，但是他也有很多的局限性。&lt;br&gt;这些局限性可以通过&lt;code&gt;Host Function&lt;/code&gt;进行扩展，使得&lt;em&gt;wasm&lt;/em&gt;与&lt;em&gt;host&lt;/em&gt;能够进行交互，完成更多的功能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Host Function&lt;/code&gt;需要&lt;code&gt;import&lt;/code&gt;到wasm中，同样wasm中的function需要&lt;code&gt;export&lt;/code&gt;到host中才能调用。&lt;/p&gt;
&lt;p&gt;本篇主要记录下在Golang下，&lt;code&gt;wasm function&lt;/code&gt;如何与&lt;code&gt;host function&lt;/code&gt;进行交互。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="http://yuanba.tech/categories/Golang/"/>
    
    
    <category term="Wasm" scheme="http://yuanba.tech/tags/Wasm/"/>
    
    <category term="Golang" scheme="http://yuanba.tech/tags/Golang/"/>
    
    <category term="Tinygo" scheme="http://yuanba.tech/tags/Tinygo/"/>
    
  </entry>
  
  <entry>
    <title>基于Wasm的轻量实时计算</title>
    <link href="http://yuanba.tech/wasm-realtime.html"/>
    <id>http://yuanba.tech/wasm-realtime.html</id>
    <published>2022-11-05T05:35:12.000Z</published>
    <updated>2022-11-05T05:35:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着各行各业对实时计算的需求越来越强烈，实时计算领域的竞争也越来越激烈，呈现百花齐放的状态。</p><p>虽说Flink在实时计算领域已坐稳老大哥，但是却也阻挡不了其它实时计算框架在某些细分领域发光。</p><p>本篇主要介绍几款基于wasm的轻量实时计算框架，比如Redpanda、InfinyOn。</p><span id="more"></span><h2 id="wasm是什么"><a href="#wasm是什么" class="headerlink" title="wasm是什么"></a>wasm是什么</h2><p>wasm是WebAssembly的简称，就是一个可移植、体积小、加载快并且兼容Web的全新格式。网上也有很多相关的介绍，可以参考下。</p><h2 id="Redpanda"><a href="#Redpanda" class="headerlink" title="Redpanda"></a>Redpanda</h2><p>来自官方的描述：<em>Redpanda is a Kafka®-compatible streaming data platform that is up to 10x faster and 6x more hardware-efficient. It is also JVM-free, ZooKeeper®-free, Jepsen-tested and source available.</em><br>Redpanda是一个实时数据平台，完全兼容kafka，并且没有外部依赖，比如zookeeper。它是用<code>C++</code>编写，所以也没有<code>JVM</code>。</p><p>由官方的描述可知它主要是对标kafka，其核心功能也就是消息队列。不过它还可以对数据进行实时处理，个人感觉其整体功能有点类似Plusar。</p><p>由于它完全兼容kafka，所以它也有topic、partition、replication这些概念，而且使用方式也与kafka一样，就不再赘述了。这里主要介绍下实时处理也就是<code>Data Transforms</code>功能</p><h3 id="Data-Transforms"><a href="#Data-Transforms" class="headerlink" title="Data Transforms"></a>Data Transforms</h3><p><code>Data Transforms</code>是Redpanda用于实时数据处理的模块，其基于<code>wasm</code>实现。基于<code>wasm</code>实现的好处是用户可以使用自己熟悉的语言(可编译为wasm)开发数据处理逻辑，然后将其编译为<code>wasm</code>文件并注册部署到Redpanda中，就可以对数据进行实时处理，对用户及其友好。</p><p>上面是我个人的理解，下面是官方给出的亮点：</p><ol><li>易用: 用户只需使用wasm支持的语言编写TransForm逻辑，然后将其注册到Redpand中就可以了，无需关kafka的依赖库。</li><li>高效: Transform代码会推送到集群中的所有节点中，Redpanda节点会像调用RPC那样调用这些本地代码。</li><li>简单: Transform管理较简单，只需将其注册到Redpanda即可，其会存储在一个单独的topic中，由Redpanda自己管理。</li></ol><h3 id="Data-Transforms架构"><a href="#Data-Transforms架构" class="headerlink" title="Data Transforms架构"></a>Data Transforms架构</h3><p>Data Transforms由4部分组成，分别是<code>客户端工具</code>、<code>存储和Transform code</code>、<code>Routing streams</code>和<code>执行引擎</code>。</p><p><img src="/blogimgs/wasm-realtime/arch.png" title="架构图"></p><blockquote><p>客户端工具(Client-side tooling)</p></blockquote><p>客户端工具<code>rpk</code>可以生成一个标准工程模版，开发者只需填充数据转换逻辑即可。还可通过<code>rpk</code>进行部署、更新<code>wasm</code>文件。</p><blockquote><p>存储和Transform code(Storage and distribution of scripts)</p></blockquote><p>Redpanda核心是一个可线性扩展、支持事务的存储引擎，底层使用raft协议保证数据副本之间的一致性。Redpanda完全支持kafka协议，所以也是按照topic、partition和replication进行存储的，同样也支持压缩存储。</p><p>开发者注册的<code>.wasm</code>文件存在一个单独的内置topic中，其topic也是支持压缩的。<code>wasm</code>文件通过名字来区分，相同名字的wasm根据时间顺序进行更新，压缩时会将历史版本移除。</p><blockquote><p>Routing streams(pacemaker)</p></blockquote><p>Routing streams主要用来将数据根据规则路由给不同的transform进行处理，这个组件被称为<code>pacemaker</code>。它是整个系统的核心，它需要在保证高效的前提下还需要保证数据的顺序性。其整个工作流包含3步：</p><ol><li>并行从<code>input</code>中读取数据</li><li>每个协处理器通过RPC调用<code>wasm</code>执行引擎执行传过来的数据和相关的元数据</li><li>将执行结果和offset写入结果topic中</li></ol><p><img src="/blogimgs/wasm-realtime/pacemaker.png" title="pacemaker工作流"><br>需要注意的是在单个协处理器中只有在第3步执行结束之后，第1步才能再次被执行，否则结果中的数据就会乱序。</p><p>peacemaker中还会记录每个transform处理的offset状态，以便当处理失败时已记录的offset处进行重放，以保证幂等性。</p><blockquote><p>执行引擎(execution engine)</p></blockquote><p>执行引擎有两种，一种是同步函数调用，另一种是基于异步的状态转换。</p><ul><li>同步执行引擎<br>同步执行引擎主要应用在一些简单的数据过滤、数据加密等较为纯粹的数据处理场景下，<code>wasm</code>文件就像调用同步函数那样被执行。其架构如图：</li></ul><p><img src="/blogimgs/wasm-realtime/sync.png" title="同步执行引擎"></p><ul><li>异步执行引擎<br>异步执行引擎主要用于在transform时需要外部依赖或者一些状态的场景中。因为在这些情况下<code>wasm</code>的执行时长是不受控制的，容易造成阻塞，所以在异步执行引擎中会新建一个与原topic分区一摸一样的子分区，这样将producer、transform和consumer解偶，提升数据处理能力。其架构如图：</li></ul><p><img src="/blogimgs/wasm-realtime/async.png" title="异步执行引擎"></p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p><a href="https://redpanda.com/blog/change-data-capture-postgres-debezium-kafka-connect">这里</a>是官方的一个demo，从pg中通过cdc将数据传入Redpanda中，流程较为简单，而且都是基于docker环境的，就不再重复了。</p><!--https://www.youtube.com/watch?v=skzWrp8eU-Yhttps://redpanda.com/blog/data-transformation-engine-with-wasm-runtimehttps://redpanda.com/blog/wasm-architecture--><h2 id="fluvio"><a href="#fluvio" class="headerlink" title="fluvio"></a>fluvio</h2><p>fluvio出自InfinyOn，它也是开源的，可对数据进行实时聚合、关联和可编程。</p><p><img src="/blogimgs/wasm-realtime/fluvio.png" title="fluvio"></p><p>分为4部分，分别为<code>SmartModules</code>、<code>Data Streams</code>、<code>Immutable Store</code>和<code>Clients &amp; Connectors</code>。</p><ul><li><code>SmartModules</code>是可编程模块，可以实时对数据进行清洗、过滤和计算，是用<code>Rust</code>编写然后编译为<code>wasm</code>进行执行。</li><li><code>Data Streams</code>是分布式模块，支持冗余和自动恢复。</li><li><code>Immutable Store</code>是一个持久不变的存储层，用于持久化数据</li><li><code>Clients &amp; Connectors</code>包含一些封装好的API，可以进行生产数据和消费数据，还包括一些已封装好的connector用于连接一些常见数据源，比如pgsql</li></ul><h3 id="fluvio架构"><a href="#fluvio架构" class="headerlink" title="fluvio架构"></a>fluvio架构</h3><p>fluvio由2个组件组成，分别为<code>Streaming Controller(SC)</code>和<code>Streaming Processing Units(SPU)</code>，采用master/worker形式，其架构如图：</p><p><img src="/blogimgs/wasm-realtime/fluvio-arch.png" title="fluvio架构图"></p><p>SC负责SPU的生命周期，包括整个集群各个节点的拓扑图和分布式数据流相关的优化。SPU负责实时数据。SC和SPU是相互独立的，每个服务都可单独重启、升级。</p><h3 id="SmartModules"><a href="#SmartModules" class="headerlink" title="SmartModules"></a>SmartModules</h3><p>SmartModules是开发者可编程的模块，开发者使用Rust语言进行开发，然后将其编译为wasm提交给fluvio，就允许开发者直接控制数据流。<br>目前官方提供的类型有<code>Filter</code>、<code>Map</code>，<code>FilterMap</code>，<code>ArrayMap</code>和<code>Aggregate</code>，不过官方还提供了一个Hub，方便开发者贡献自己的SmartModules和下载所需的非官方SmartModules</p><p>官方也提供了一些Demo，都比较简单，感兴趣的可以自行查看。</p><!-- https://www.infinyon.com/blog/2021/08/smartmodule-aggregates/https://www.infinyon.com/blog/2021/08/smartmodule-map-use-cases/https://www.infinyon.com/blog/2021/06/smartmodule-filters/--><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这两个实时框架都是基于消息队列之上的，都是通过<code>wasm</code>将数据处理功能开发给开发者，其功能有点像Plusar，只不过Plusar是用java语言开发的，其数据处理能力并没有使用<code>wasm</code>，而是使用的是原生java语言，个人感觉可能是因为java语言受众比较广吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着各行各业对实时计算的需求越来越强烈，实时计算领域的竞争也越来越激烈，呈现百花齐放的状态。&lt;/p&gt;
&lt;p&gt;虽说Flink在实时计算领域已坐稳老大哥，但是却也阻挡不了其它实时计算框架在某些细分领域发光。&lt;/p&gt;
&lt;p&gt;本篇主要介绍几款基于wasm的轻量实时计算框架，比如Redpanda、InfinyOn。&lt;/p&gt;</summary>
    
    
    
    <category term="Realtime, BigData" scheme="http://yuanba.tech/categories/Realtime-BigData/"/>
    
    
    <category term="Wasm" scheme="http://yuanba.tech/tags/Wasm/"/>
    
    <category term="Redpanda" scheme="http://yuanba.tech/tags/Redpanda/"/>
    
    <category term="InfinyOn" scheme="http://yuanba.tech/tags/InfinyOn/"/>
    
    <category term="Pulsar" scheme="http://yuanba.tech/tags/Pulsar/"/>
    
    <category term="Realtime" scheme="http://yuanba.tech/tags/Realtime/"/>
    
  </entry>
  
  <entry>
    <title>scratch自定义扩展</title>
    <link href="http://yuanba.tech/scratch-extensions-demo.html"/>
    <id>http://yuanba.tech/scratch-extensions-demo.html</id>
    <published>2021-12-14T14:30:20.000Z</published>
    <updated>2021-12-14T16:10:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>今日想搞一搞scratch，使用过程中发现官方给的扩展组件中有些在国内用不了，所以就想把这个问题给修复下，方便国内用户使用。</p><p>在修复这个问题之前，现熟悉下scratch，以及如何自定义扩展。</p><span id="more"></span><h2 id="scratch"><a href="#scratch" class="headerlink" title="scratch"></a>scratch</h2><p>scratch是MIT开源的少儿编程工具，提供可视化的，积木式编程，降低学习门槛，丰富创作形式。<br>我使用的是scratch3.0，它是由多个模块组成的，与本篇文章涉及比较紧密的是<code>scratch-gui</code>和<code>scratch-vm</code>，其中<code>scratch-gui</code>提供了可视化的操作界面，<code>scratch-vm</code>是提供了运行环境和扩展模块。</p><h2 id="自定义扩展插件"><a href="#自定义扩展插件" class="headerlink" title="自定义扩展插件"></a>自定义扩展插件</h2><h3 id="scratch-vm中的改动"><a href="#scratch-vm中的改动" class="headerlink" title="scratch-vm中的改动"></a>scratch-vm中的改动</h3><p>扩展插件的具体实现在<code>scratch-vm</code>模块中的<code>src/extensions</code>，当前目录中已有一些官方集成的插件，比如翻译、乐高互联相关的插件，每个扩展中都有个<code>index.js</code>文件，这个文件就是该扩展的主要实现入口。</p><p>自定义扩展中可以使用的积木块所在<code>getInfo()</code>方法中定义的，看下翻译扩展中<code>getInfo()</code>方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">getInfo () &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;translate&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: formatMessage(&#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="string">&#x27;translate.categoryName&#x27;</span>,</span><br><span class="line">            <span class="attr">default</span>: <span class="string">&#x27;Translate&#x27;</span>,</span><br><span class="line">            <span class="attr">description</span>: <span class="string">&#x27;Name of extension that adds translate blocks&#x27;</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="attr">blockIconURI</span>: blockIconURI,</span><br><span class="line">        <span class="attr">menuIconURI</span>: menuIconURI,</span><br><span class="line">        <span class="attr">blocks</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">opcode</span>: <span class="string">&#x27;getTranslate&#x27;</span>,</span><br><span class="line">                <span class="attr">text</span>: formatMessage(&#123;</span><br><span class="line">                    <span class="attr">id</span>: <span class="string">&#x27;translate.translateBlock&#x27;</span>,</span><br><span class="line">                    <span class="attr">default</span>: <span class="string">&#x27;translate [WORDS] to [LANGUAGE]&#x27;</span>,</span><br><span class="line">                    <span class="attr">description</span>: <span class="string">&#x27;translate some text to a different language&#x27;</span></span><br><span class="line">                &#125;),</span><br><span class="line">                <span class="attr">blockType</span>: BlockType.REPORTER,</span><br><span class="line">                <span class="attr">arguments</span>: &#123;</span><br><span class="line">                    <span class="attr">WORDS</span>: &#123;</span><br><span class="line">                        <span class="attr">type</span>: ArgumentType.STRING,</span><br><span class="line">                        <span class="attr">defaultValue</span>: formatMessage(&#123;</span><br><span class="line">                            <span class="attr">id</span>: <span class="string">&#x27;translate.defaultTextToTranslate&#x27;</span>,</span><br><span class="line">                            <span class="attr">default</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">                            <span class="attr">description</span>: <span class="string">&#x27;hello: the default text to translate&#x27;</span></span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">LANGUAGE</span>: &#123;</span><br><span class="line">                        <span class="attr">type</span>: ArgumentType.STRING,</span><br><span class="line">                        <span class="attr">menu</span>: <span class="string">&#x27;languages&#x27;</span>,</span><br><span class="line">                        <span class="attr">defaultValue</span>: <span class="built_in">this</span>._randomLanguageCode</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">opcode</span>: <span class="string">&#x27;getViewerLanguage&#x27;</span>,</span><br><span class="line">                <span class="attr">text</span>: formatMessage(&#123;</span><br><span class="line">                    <span class="attr">id</span>: <span class="string">&#x27;translate.viewerLanguage&#x27;</span>,</span><br><span class="line">                    <span class="attr">default</span>: <span class="string">&#x27;language&#x27;</span>,</span><br><span class="line">                    <span class="attr">description</span>: <span class="string">&#x27;the languge of the project viewer&#x27;</span></span><br><span class="line">                &#125;),</span><br><span class="line">                <span class="attr">blockType</span>: BlockType.REPORTER,</span><br><span class="line">                <span class="attr">arguments</span>: &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>blocks</code>对应的值就是积木块类型，<code>opcode</code>是具体某个积木块的实现内容，如果要修改积木块的功能就修改此方法就可以。</p><p>自定义扩展的功能在此实现之后，还需要在<code>src/extension-support/extension-manager.js</code>中注册，这样在编译的时候，将其自定义扩展进行编译，已注册的扩展如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> builtinExtensions = &#123;</span><br><span class="line">    <span class="comment">// This is an example that isn&#x27;t loaded with the other core blocks,</span></span><br><span class="line">    <span class="comment">// but serves as a reference for loading core blocks as extensions.</span></span><br><span class="line">    <span class="attr">coreExample</span>: <span class="function">() =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;../blocks/scratch3_core_example&#x27;</span>),</span><br><span class="line">    <span class="comment">// These are the non-core built-in extensions.</span></span><br><span class="line">    <span class="attr">pen</span>: <span class="function">() =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;../extensions/scratch3_pen&#x27;</span>),</span><br><span class="line">    <span class="attr">wedo2</span>: <span class="function">() =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;../extensions/scratch3_wedo2&#x27;</span>),</span><br><span class="line">    <span class="attr">music</span>: <span class="function">() =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;../extensions/scratch3_music&#x27;</span>),</span><br><span class="line">    <span class="attr">microbit</span>: <span class="function">() =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;../extensions/scratch3_microbit&#x27;</span>),</span><br><span class="line">    <span class="attr">text2speech</span>: <span class="function">() =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;../extensions/scratch3_text2speech&#x27;</span>),</span><br><span class="line">    <span class="attr">translate</span>: <span class="function">() =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;../extensions/scratch3_translate&#x27;</span>),</span><br><span class="line">    <span class="attr">videoSensing</span>: <span class="function">() =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;../extensions/scratch3_video_sensing&#x27;</span>),</span><br><span class="line">    <span class="attr">ev3</span>: <span class="function">() =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;../extensions/scratch3_ev3&#x27;</span>),</span><br><span class="line">    <span class="attr">makeymakey</span>: <span class="function">() =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;../extensions/scratch3_makeymakey&#x27;</span>),</span><br><span class="line">    <span class="attr">boost</span>: <span class="function">() =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;../extensions/scratch3_boost&#x27;</span>),</span><br><span class="line">    <span class="attr">gdxfor</span>: <span class="function">() =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;../extensions/scratch3_gdx_for&#x27;</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="scratch-gui中的改动"><a href="#scratch-gui中的改动" class="headerlink" title="scratch-gui中的改动"></a>scratch-gui中的改动</h3><p>scratch-vm修改结束之后，还需要在<code>scratch-gui</code>中导入该扩展的一些信息与入口，修改<code>/src/lib/libraries/extensions/index.jsx</code>文件，<br>首先导入自定义扩展显示图标，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> translateIconURL <span class="keyword">from</span> <span class="string">&#x27;./translate/translate.png&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> translateInsetIconURL <span class="keyword">from</span> <span class="string">&#x27;./translate/translate-small.png&#x27;</span>;</span><br></pre></td></tr></table></figure><p>其次在<code>export default </code>代码块中增加自定义扩展的一些描述信息，需要注意的是其中的<code>extensionId</code>的值需要与<code>scratch-vm</code>中<code>builtinExtensions</code>的值对应。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span>: (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">FormattedMessage</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">defaultMessage</span>=<span class="string">&quot;Translate&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">description</span>=<span class="string">&quot;Name for the Translate extension&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">id</span>=<span class="string">&quot;gui.extension.translate.name&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        /&gt;</span></span></span><br><span class="line">    ),</span><br><span class="line">    <span class="attr">extensionId</span>: <span class="string">&#x27;translate&#x27;</span>,</span><br><span class="line">    <span class="attr">collaborator</span>: <span class="string">&#x27;YuanbaLab&#x27;</span>,</span><br><span class="line">    <span class="attr">iconURL</span>: translateIconURL,</span><br><span class="line">    <span class="attr">insetIconURL</span>: translateInsetIconURL,</span><br><span class="line">    <span class="attr">description</span>: (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">FormattedMessage</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">defaultMessage</span>=<span class="string">&quot;Translate text into many languages.&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">description</span>=<span class="string">&quot;Description for the Translate extension&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">id</span>=<span class="string">&quot;gui.extension.translate.description&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        /&gt;</span></span></span><br><span class="line">    ),</span><br><span class="line">    <span class="attr">featured</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">internetConnectionRequired</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译调试"><a href="#编译调试" class="headerlink" title="编译调试"></a>编译调试</h3><p>编译调试需要具备node.js环境，安装<code>npm install -g webpack</code>和<code>npm install -g webpack-dev-server</code>。<br>进入<code>scratch-vm</code>项目目录中，执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm link</span><br><span class="line">npm run watch</span><br></pre></td></tr></table></figure><p>然后再开一个终端，进入<code>scratch-gui</code>目录中，执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm link scratch-vm </span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p>没有任何错误信息之后，就可以在<code>http://127.0.0.1:8601/</code>地址使用scratch3.0了。</p><h2 id="编译成桌面程序"><a href="#编译成桌面程序" class="headerlink" title="编译成桌面程序"></a>编译成桌面程序</h2><p>git clone <a href="mailto:&#103;&#x69;&#116;&#x40;&#103;&#105;&#x74;&#x68;&#117;&#98;&#46;&#99;&#111;&#x6d;">&#103;&#x69;&#116;&#x40;&#103;&#105;&#x74;&#x68;&#117;&#98;&#46;&#99;&#111;&#x6d;</a>:hunshenshi/scratch-desktop.git</p><p>cd scratch-gui<br>npm install<br>npm link</p><p>cd scratch-desktop<br>npm install<br>npm link scratch-gui<br>npm run dist</p><p>electron 报错<br>进入 electron目录，执行node install.js</p><p>Cannot find module ‘autoprefixer’”<br>npm install –save autoprefixer@^9.0.1</p><p>将 本地scratch-vm和scratch-gui cp到desktop中   or     npm link scratch-vm scratch-blocks<br>npm run clean &amp;&amp; npm run compile &amp;&amp; npm run doBuild – –mode=dev</p><p>npm run dist # 编译后的安装包Scratch Desktop-3.8.0.AppImage和scratch-desktop_3.8.0_amd64.snap保存在scratch-desktop/dist/文件夹中。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今日想搞一搞scratch，使用过程中发现官方给的扩展组件中有些在国内用不了，所以就想把这个问题给修复下，方便国内用户使用。&lt;/p&gt;
&lt;p&gt;在修复这个问题之前，现熟悉下scratch，以及如何自定义扩展。&lt;/p&gt;</summary>
    
    
    
    <category term="kidsCode" scheme="http://yuanba.tech/categories/kidsCode/"/>
    
    
    <category term="scratch" scheme="http://yuanba.tech/tags/scratch/"/>
    
    <category term="扩展" scheme="http://yuanba.tech/tags/%E6%89%A9%E5%B1%95/"/>
    
    <category term="kidsCode" scheme="http://yuanba.tech/tags/kidsCode/"/>
    
  </entry>
  
  <entry>
    <title>metabase导入IDE调试</title>
    <link href="http://yuanba.tech/metabase-import-ide.html"/>
    <id>http://yuanba.tech/metabase-import-ide.html</id>
    <published>2021-12-13T15:31:22.000Z</published>
    <updated>2021-12-13T15:51:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在调研BI报表相关的工具，最后决定深入调研下metabase，于是就有了这篇文章。</p><p>之所以选择metabase是因为一下几点：</p><ol><li>低门槛，对无sql基础的人员友好</li><li>分析功能较全，支持join</li><li>图表功能OK</li><li>部署方便<br>对于我来说，唯一不足的是它是由clojure开发的，二开成本有点高，这才是这篇文章的诞生的真正原因，因为导入IDE编译成功就用了好几天。        </li></ol><span id="more"></span><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>metabase前端依赖node，后端以来jdk和clojure。</p><blockquote><p>我是在mac环境下的，下面的命令都是基于mac的。</p></blockquote><p>1、安装node<br>之前在电脑上装过node，使用tar安装的，只是版本比较老，于是用tar包升级了node，版本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ cnpm -v</span><br><span class="line">cnpm@7.1.0 </span><br><span class="line">npm@6.14.15 </span><br><span class="line">node@16.13.0 </span><br><span class="line">npminstall@5.2.2 </span><br></pre></td></tr></table></figure><p>2、安装yarn<br>node安装好之后，再安装yarn，安装时要选择全局安装，使用命令<br><code>npm install --global yarn</code></p><p>3、安装jdk<br>jdk的安装只强调一点，<strong>一定要jdk11、jdk11、jdk11</strong></p><p>4、安装clojure<br>利用brew安装<br><code>brew install clojure/tools/clojure</code></p><blockquote><p>由于Clojure也依赖maven，默认的maven源在国内经常无法访问，所以需要替换maven源</p></blockquote><p>在Clojure的安装目录中找到<code>deps.edn</code>，修改内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:mvn/repos &#123;</span><br><span class="line">  &quot;central&quot; &#123;:url &quot;http://maven.aliyun.com/nexus/content/repositories/central/&quot;&#125; </span><br><span class="line">  &quot;clojars&quot; &#123;:url &quot;https://repo.clojars.org/&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在命令行输入<code>clj</code> 或者 <code>clojure</code>，即可进入交互界面。</p><p>5、IDE开发环境设置<br>我使用的是intellij idea，安装插件<code>cursive</code>即可，不过需要注意的是cursive与一些插件有冲突，而且对IDE的版本也有要求。(可以说是为了搞这套环境，我把我的老古董开发环境全都升级了一下。)</p><blockquote><p><code>cursive</code>插件与La Clojure、 clojure-kit、 Leiningen冲突，需要IDE为2018.x, 2019.x, 2020.1 and the 2020.2</p></blockquote><h2 id="本地编译"><a href="#本地编译" class="headerlink" title="本地编译"></a>本地编译</h2><p>1、准备源码<br>从github上clone最新的代码<code>git clone git@github.com:metabase/metabase.git</code><br>clone下来的代码默认上master分支，我切了下分支，切到了最新的release版本，<code>git checkout -b 1.41.2 v1.41.2</code></p><p>2、导入IDE<br>选择File -&gt; Open -&gt; 在metabase目录中选择<code>deps.edn</code> -&gt; Open an Project<br>剩下的就是自动加载依赖。</p><p>3、编译uberjar<br>在metabase_home目录下执行<code>clojure -X:deps prep</code><br>成功之后执行<code>cd modules/drivers &amp;&amp; clojure -X:deps prep</code></p><blockquote><p>以上两个命令执行一次就行</p></blockquote><p>再次到metabase_home目录下，执行<code>./bin/build</code>进行编译，在<code>target/uberjar</code>目录下会出现一个jar包，最后执行<code>java -jar metabase.jar</code>即可启动。</p><h2 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h2><p>在<code>deps.edn</code>中找到程序的入口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:run</span><br><span class="line">&#123;:main-opts [&quot;-m&quot; &quot;metabase.core&quot;]</span><br><span class="line"> :jvm-opts  [&quot;-Dmb.run.mode=dev&quot;</span><br><span class="line">             &quot;-Djava.awt.headless=true&quot;                   ; prevent Java icon from randomly popping up in macOS dock</span><br><span class="line">             &quot;-Dmb.jetty.port=3000&quot;]&#125;</span><br></pre></td></tr></table></figure><p><code>main-opts</code>就是程序的入口，是<code>metabase</code>包的<code>core</code>，相关代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;;; ------------------------------------------------ <span class="type">App</span> <span class="type">Entry</span> <span class="type">Point</span> -------------------------------------------------</span><br><span class="line"></span><br><span class="line">(defn -main</span><br><span class="line">  <span class="string">&quot;Launch Metabase in standalone mode.&quot;</span></span><br><span class="line">  [&amp; [cmd &amp; args]]</span><br><span class="line">  (maybe-enable-tracing)</span><br><span class="line">  (<span class="keyword">if</span> cmd</span><br><span class="line">    (run-cmd cmd args) ; run a command like `java -jar metabase.jar migrate release-locks` or `clojure -<span class="type">M</span>:run migrate release-locks`</span><br><span class="line">    (start-normally))) ; <span class="keyword">with</span> no command line args just start <span class="type">Metabase</span> normally</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这就可以跟读调试代码了。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>接触一个新事物，其过程没有一帆风顺的，这次也不例外，这里记录下遇到的问题及解决方案。<br>1、<strong>方向性错误</strong><br>在着手本地编译时做了些调研工作，网上也有些相关教程，不过这些导入IDE的教程都是基于<code>Leiningen</code>的，metabase之前是基于<code>Leiningen</code>，但是在前段时间从<code>Leiningen</code>切到了<code>tools.deps</code>，这就导致网上所有的教程都过时了。具体信息见<a href="https://github.com/metabase/metabase/wiki/Migrating-from-Leiningen-to-tools.deps">官方信息</a></p><p><code>Leiningen</code>和<code>tools.deps</code>的明显区别是代码中的<code>project.clj</code>文件变成了<code>deps.edn</code>文件(当初傻傻的以为<code>project.clj</code>中project只是个变量呢。。。)</p><p>后来意识到<code>project.clj</code>就是一个文件时，查看源码的提交记录发现了其从<code>Leiningen</code>切到了<code>tools.deps</code>，所以IDE的插件需要变为<code>cursive</code></p><p>2、使用Clojure时maven源报UnknownHostException<br>安装完Clojure之后，验证是否可用时，在终端输入<code>clj</code>，报<code>UnknownHostException: repo.maven.apache.org</code><br>第一感觉去修改本机的maven配置，修改之后依然报同样的错。<br>去Clojure的安装目录中关键字检索<code>repo.maven.apache.org</code>，发现在<code>deps.edn</code>中配置的，改成国内的源即可，具体修改方式见上面的安装步骤。</p><p>3、本地编译报<code>SSL_ERROR_SYSCALL in connection to github.com:443</code><br>是因为github通过http链接时需要安全认证，所以执行<code>git config --global http.sslVerify false</code>关闭，(有时间好用有时间不好用，多次几次，随缘吧)。</p><p>4、运行jar包报错，错误内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021-11-30 00:24:59,891 WARN servicelocator.DefaultPackageScanClassResolver :: Cannot search jar file &#x27;/Users/metabase/target/uberjar/metabase.jar&#x27; for classes due to an IOException: invalid code lengths set</span><br><span class="line">java.util.zip.ZipException: invalid code lengths set</span><br></pre></td></tr></table></figure><p>网上并没有什么解决方案，想到我的代码拉的是master分支，是不是代码的问题，于是切到了最新的release版本，打包之后依然报错。<br>下载了官方release版本的jar包，在本地正常运行，排除代码问题，那问题就出在编译环境上，此时想到<strong>文档上要求jdk版本为11</strong>，升级jdk为11之后，再次打包运行成功。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在调研BI报表相关的工具，最后决定深入调研下metabase，于是就有了这篇文章。&lt;/p&gt;
&lt;p&gt;之所以选择metabase是因为一下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;低门槛，对无sql基础的人员友好&lt;/li&gt;
&lt;li&gt;分析功能较全，支持join&lt;/li&gt;
&lt;li&gt;图表功能OK&lt;/li&gt;
&lt;li&gt;部署方便&lt;br&gt;对于我来说，唯一不足的是它是由clojure开发的，二开成本有点高，这才是这篇文章的诞生的真正原因，因为导入IDE编译成功就用了好几天。        &lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="BigData" scheme="http://yuanba.tech/categories/BigData/"/>
    
    
    <category term="BigData" scheme="http://yuanba.tech/tags/BigData/"/>
    
    <category term="metabase" scheme="http://yuanba.tech/tags/metabase/"/>
    
    <category term="BI" scheme="http://yuanba.tech/tags/BI/"/>
    
  </entry>
  
  <entry>
    <title>Flink Connector调研</title>
    <link href="http://yuanba.tech/flink-connector-example.html"/>
    <id>http://yuanba.tech/flink-connector-example.html</id>
    <published>2021-11-10T14:30:20.000Z</published>
    <updated>2021-11-10T14:51:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇<a href="https://bigdatadecode.top/Flink-standlone-Flinkx.html">Flink standlone模式下Flinkx测试</a>介绍了使用Flinkx同步mysql，但是Flinkx在同步binlog日志时，个人感觉有点不方便，所以就对比下Flink Connector。</p><span id="more"></span><h2 id="Flink-standlone部署"><a href="#Flink-standlone部署" class="headerlink" title="Flink standlone部署"></a>Flink standlone部署</h2><p>部署比较简单，具体可以参考这篇<a href="https://bigdatadecode.top/Flink-standlone-Flinkx.html">Flink standlone模式下Flinkx测试</a></p><h2 id="启动sql-client"><a href="#启动sql-client" class="headerlink" title="启动sql client"></a>启动sql client</h2><p>主要是为了测试下sql功能，所以我就简单采用了sql client模式。<br>在${Flink_HOME}目录执行<code>./bin/sql-client.sh embedded</code>启动sql client</p><h2 id="mysql开启binlog"><a href="#mysql开启binlog" class="headerlink" title="mysql开启binlog"></a>mysql开启binlog</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server_id=1  # 不同节点的server_id必须不同</span><br><span class="line">log_bin=/opt/data/mysql-data/mysql-bin  # binlog日志目录</span><br><span class="line">binlog_format=ROW   </span><br><span class="line">expire_logs_days=30</span><br></pre></td></tr></table></figure><p>重启mysql服务，执行<code>show variables like &#39;%bin%&#39;;</code>检查是否已经开启成功。</p><h2 id="Flink-sql实时同步mysql"><a href="#Flink-sql实时同步mysql" class="headerlink" title="Flink sql实时同步mysql"></a>Flink sql实时同步mysql</h2><p>创建source表，mysql数据源表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> source</span><br><span class="line">(</span><br><span class="line">    id          <span class="type">int</span>,</span><br><span class="line">    name        <span class="type">varchar</span>,</span><br><span class="line">    money       <span class="type">decimal</span>,</span><br><span class="line">    dateone     <span class="type">timestamp</span>,</span><br><span class="line">    age         <span class="type">bigint</span>,</span><br><span class="line">    datethree   <span class="type">timestamp</span>,</span><br><span class="line">    datesix     <span class="type">timestamp</span>,</span><br><span class="line">    phone       <span class="type">bigint</span>,</span><br><span class="line">    wechat      STRING,</span><br><span class="line">    income      <span class="type">decimal</span>,</span><br><span class="line">    birthday    <span class="type">timestamp</span>,</span><br><span class="line">    dtdate      <span class="type">date</span>,</span><br><span class="line">    dttime      <span class="type">time</span>,</span><br><span class="line">    today       <span class="type">date</span>,</span><br><span class="line">    timecurrent <span class="type">time</span>,</span><br><span class="line">    aboolean    <span class="type">boolean</span>,</span><br><span class="line">    adouble     <span class="keyword">double</span>,</span><br><span class="line">    afloat      <span class="type">float</span>,</span><br><span class="line">    achar       <span class="type">char</span>,</span><br><span class="line">    abinary     BYTES,</span><br><span class="line">    atinyint    tinyint</span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">      <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;mysql-cdc&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;hostname&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;192.168.2.1&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;port&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;3306&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;username&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;password&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;root@321&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;database-name&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;table-name&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;flink_type&#x27;</span></span><br><span class="line">      );</span><br></pre></td></tr></table></figure><p>创建sink表，这里为了顺便测试下connector连mysql，所以sink到mysql中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mysql_sink</span><br><span class="line">(</span><br><span class="line">    id          <span class="type">int</span>,</span><br><span class="line">    name        <span class="type">varchar</span>,</span><br><span class="line">    money       <span class="type">decimal</span>,</span><br><span class="line">    dateone     <span class="type">timestamp</span>,</span><br><span class="line">    age         <span class="type">bigint</span>,</span><br><span class="line">    datethree   <span class="type">timestamp</span>,</span><br><span class="line">    datesix     <span class="type">timestamp</span>,</span><br><span class="line">    phone       <span class="type">bigint</span>,</span><br><span class="line">    wechat      STRING,</span><br><span class="line">    income      <span class="type">decimal</span>,</span><br><span class="line">    birthday    <span class="type">timestamp</span>,</span><br><span class="line">    dtdate      <span class="type">date</span>,</span><br><span class="line">    dttime      <span class="type">time</span>,</span><br><span class="line">    today       <span class="type">date</span>,</span><br><span class="line">    timecurrent <span class="type">time</span>,</span><br><span class="line">    aboolean    <span class="type">boolean</span>,</span><br><span class="line">    adouble     <span class="keyword">double</span>,</span><br><span class="line">    afloat      <span class="type">float</span>,</span><br><span class="line">    achar       <span class="type">char</span>,</span><br><span class="line">    abinary     BYTES,</span><br><span class="line">    atinyint    tinyint,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id) <span class="keyword">NOT</span> ENFORCED <span class="comment">-- 增量时，必须指定主键</span></span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">      <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;jdbc&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;driver&#x27;</span><span class="operator">=</span><span class="string">&#x27;com.mysql.jdbc.Driver&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;url&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;jdbc:mysql://192.168.2.1:3306/test?useUnicode=true&amp;characterEncoding=utf8&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;table-name&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;flink_type_cp&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;username&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;password&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;root@321&#x27;</span></span><br><span class="line">      );</span><br></pre></td></tr></table></figure><p>通过sql insert到sink表中，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mysql_sink</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> source u;</span><br></pre></td></tr></table></figure><p>执行完这个语句之后，任务会提交到flink集群，在源表中修改表内容之后，会实时同步到目标表中。</p><p>具体使用方式请参考以下内容<br><a href="https://ververica.github.io/flink-cdc-connectors/master/content/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/mysql-postgres-tutorial-zh.html">Flink CDC</a><br><a href="https://ci.apache.org/projects/flink/flink-docs-master/zh/docs/connectors/table/jdbc/">Flink jdbc</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇&lt;a href=&quot;https://bigdatadecode.top/Flink-standlone-Flinkx.html&quot;&gt;Flink standlone模式下Flinkx测试&lt;/a&gt;介绍了使用Flinkx同步mysql，但是Flinkx在同步binlog日志时，个人感觉有点不方便，所以就对比下Flink Connector。&lt;/p&gt;</summary>
    
    
    
    <category term="Flink" scheme="http://yuanba.tech/categories/Flink/"/>
    
    
    <category term="BigData" scheme="http://yuanba.tech/tags/BigData/"/>
    
    <category term="Flink" scheme="http://yuanba.tech/tags/Flink/"/>
    
    <category term="Connector" scheme="http://yuanba.tech/tags/Connector/"/>
    
    <category term="CDC" scheme="http://yuanba.tech/tags/CDC/"/>
    
  </entry>
  
  <entry>
    <title>Flink standlone模式下Flinkx测试</title>
    <link href="http://yuanba.tech/Flink-standlone-Flinkx.html"/>
    <id>http://yuanba.tech/Flink-standlone-Flinkx.html</id>
    <published>2021-11-06T15:05:20.000Z</published>
    <updated>2021-11-06T15:55:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>FlinkX是一个基于Flink的批流统一的数据同步工具，既可以采集静态的数据，比如MySQL，HDFS等，也可以采集实时变化的数据，比如MySQL binlog，Kafka等。 同时，FlinkX也是支持原生FlinkSql所有语法和特性的计算框架，具体使用方式可以参考<a href="https://github.com/DTStack/flinkx">github上的项目介绍</a></p><p>本篇记录下在Flink standlone模式下使用Flinx同步mysql数据。</p><span id="more"></span><h2 id="Flink部署standlone模式"><a href="#Flink部署standlone模式" class="headerlink" title="Flink部署standlone模式"></a>Flink部署standlone模式</h2><p>下载flink-1.12.2版本（因为flinkx使用的是1.12版本），简单配置下即可。修改内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vim masters</span><br><span class="line">127.0.0.1</span><br><span class="line"></span><br><span class="line">vim workers</span><br><span class="line">127.0.0.1</span><br><span class="line"></span><br><span class="line">vim flink-conf.yaml</span><br><span class="line">jobmanager.rpc.address: 127.0.0.1</span><br><span class="line">jobmanager.rpc.port: 6124 # 6123端口可能会冲突，改成6124</span><br><span class="line">jobmanager.memory.process.size: 5120m</span><br><span class="line">taskmanager.memory.process.size: 10240m</span><br><span class="line">taskmanager.numberOfTaskSlots: 2  </span><br><span class="line">parallelism.default: 1 </span><br><span class="line"></span><br><span class="line">bin/jobmanager.sh start</span><br><span class="line">bin/taskmanager.sh start # 也可直接执行bin/start-cluster.sh</span><br></pre></td></tr></table></figure><p>Flink standlone模式部署是不是很简单，下面部署Flinkx</p><h2 id="编译Flinkx"><a href="#编译Flinkx" class="headerlink" title="编译Flinkx"></a>编译Flinkx</h2><p>从github上下载了最新release版本，发现目录结构和文档中的不一样，所以就下载了源码进行编译。</p><p>由于flinkx支持的connector较多，编译时间较长，而且有些jar包仓库中也没有，需要一些额外的操作，所以我注释了些connector，可以在<code>flinkx/flinkx-connectors/pom.xml</code>文件中注释。</p><p>编译命令为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -DskipTests </span><br></pre></td></tr></table></figure><p>编译之后的目录结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--   1 test test    11K 10 21 11:26 LICENSE</span><br><span class="line">-rw-r--r--   1 test test   7.1K 10 21 11:26 README.md</span><br><span class="line">-rw-r--r--   1 test test   9.1K 10 21 11:26 README_CH.md</span><br><span class="line">drwxr-xr-x   5 test test   160B 11  3 13:02 bin</span><br><span class="line">drwxr-xr-x   3 test test    96B 10 21 14:36 build</span><br><span class="line">drwxr-xr-x   4 test test   128B 10 21 11:26 ci</span><br><span class="line">drwxr-xr-x  17 test test   544B 10 21 11:26 docs</span><br><span class="line">drwxr-xr-x   7 test test   224B 11  3 09:41 flinkx-clients</span><br><span class="line">drwxr-xr-x  41 test test   1.3K 10 22 16:25 flinkx-connectors</span><br><span class="line">drwxr-xr-x   7 test test   224B 11  3 09:39 flinkx-core</span><br><span class="line">drwxr-xr-x   6 test test   192B 10 22 16:10 flinkx-dirtydata-collectors</span><br><span class="line">drwxr-xr-x   6 test test   192B 11  3 09:40 flinkx-dist                    ## 编译之后的目录</span><br><span class="line">drwxr-xr-x   6 test test   192B 11  3 09:41 flinkx-docker</span><br><span class="line">drwxr-xr-x   4 test test   128B 10 21 11:26 flinkx-examples</span><br><span class="line">drwxr-xr-x   4 test test   128B 10 22 16:10 flinkx-formats</span><br><span class="line">drwxr-xr-x   4 test test   128B 10 21 11:26 flinkx-local-test</span><br><span class="line">drwxr-xr-x   7 test test   224B 10 22 16:10 flinkx-metrics</span><br><span class="line">-rw-r--r--   1 test test   1.9K 10 22 16:10 flinkx-parent.iml</span><br><span class="line">drwxr-xr-x  12 test test   384B 10 21 11:26 jars</span><br><span class="line">drwxr-xr-x   3 test test    96B 10 22 16:31 lib</span><br><span class="line">-rw-r--r--   1 test test   627B 10 21 11:26 license.txt</span><br><span class="line">-rw-------   1 test test    98K 10 22 18:07 nohup.out</span><br><span class="line">-rw-r--r--   1 test test   6.7K 10 21 11:26 pom.xml</span><br></pre></td></tr></table></figure><h2 id="Flinkx-json模式批量同步mysql表"><a href="#Flinkx-json模式批量同步mysql表" class="headerlink" title="Flinkx json模式批量同步mysql表"></a>Flinkx json模式批量同步mysql表</h2><p>Flinkx同步mysql表有两种方式，一种是job，另一种是sql。job形式需要配置一个json文件，主要是需要同步的库表信息，内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;job&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;content&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;reader&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;mysqlreader&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;column&quot;</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;id&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;varchar&quot;</span></span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;varchar&quot;</span></span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;category&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;varchar&quot;</span></span><br><span class="line">              &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;root@321&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;connection&quot;</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;jdbcUrl&quot;</span>: [</span><br><span class="line">                  <span class="string">&quot;jdbc:mysql://192.168.0.1:3306/test?useSSL=false&quot;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">&quot;table&quot;</span>: [</span><br><span class="line">                  <span class="string">&quot;t&quot;</span></span><br><span class="line">                ]</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;writer&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;mysqlwriter&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;root@321&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;connection&quot;</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;jdbcUrl&quot;</span>: <span class="string">&quot;jdbc:mysql://192.168.0.1:3306/test1?useSSL=false&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;table&quot;</span>: [</span><br><span class="line">                  <span class="string">&quot;t_1&quot;</span></span><br><span class="line">                ]</span><br><span class="line">              &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;writeMode&quot;</span>: <span class="string">&quot;insert&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;column&quot;</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;id&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;varchar&quot;</span></span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;varchar&quot;</span></span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;category&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;varchar&quot;</span></span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;setting&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;speed&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;channel&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;bytes&quot;</span>: <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在Flinx的home目录中执行job启动命令，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/flinkx -mode standalone -jobType sync -job /$&#123;FLINKX_HOME&#125;/flinkx-examples/json/mysql/mysql_mysql_batch.json -flinkxDistDir flinkx-dist -flinkConfDir $FLINK_HOME/conf -confProp &quot;&#123;\&quot;flink.checkpoint.interval\&quot;:60000&#125;&quot;</span><br></pre></td></tr></table></figure><p>任务很顺利的执行结束，下面看使用sql如何同步mysql表。</p><h2 id="Flinkx-sql模式同步mysql表"><a href="#Flinkx-sql模式同步mysql表" class="headerlink" title="Flinkx sql模式同步mysql表"></a>Flinkx sql模式同步mysql表</h2><p>在<code>flinkx-examples</code>下面有很多例子，这里执行下sql实时增量同步mysql，sql为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> source</span><br><span class="line">(</span><br><span class="line">    id          <span class="type">int</span>,</span><br><span class="line">    name        <span class="type">varchar</span>,</span><br><span class="line">    money       <span class="type">decimal</span>,</span><br><span class="line">    dateone     <span class="type">timestamp</span>,</span><br><span class="line">    age         <span class="type">bigint</span>,</span><br><span class="line">    datethree   <span class="type">timestamp</span>,</span><br><span class="line">    datesix     <span class="type">timestamp</span>,</span><br><span class="line">    phone       <span class="type">bigint</span>,</span><br><span class="line">    wechat      STRING,</span><br><span class="line">    income      <span class="type">decimal</span>,</span><br><span class="line">    birthday    <span class="type">timestamp</span>,</span><br><span class="line">    dtdate      <span class="type">date</span>,</span><br><span class="line">    dttime      <span class="type">time</span>,</span><br><span class="line">    today       <span class="type">date</span>,</span><br><span class="line">    timecurrent <span class="type">time</span>,</span><br><span class="line">    aboolean    <span class="type">boolean</span>,</span><br><span class="line">    adouble     <span class="keyword">double</span>,</span><br><span class="line">    afloat      <span class="type">float</span>,</span><br><span class="line">    achar       <span class="type">char</span>,</span><br><span class="line">    abinary     BYTES,</span><br><span class="line">    atinyint    tinyint</span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">      <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;mysql-x&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;url&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;jdbc:mysql://192.168.0.1:3306/test&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;table-name&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;flink_type&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;username&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;password&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;Shujupingtai@321&#x27;</span></span><br><span class="line"></span><br><span class="line">      ,<span class="string">&#x27;scan.polling-interval&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;3000&#x27;</span> <span class="comment">--间隔轮训时间。非必填(不填为离线任务)，无默认</span></span><br><span class="line"></span><br><span class="line">      ,<span class="string">&#x27;scan.parallelism&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="comment">-- 并行度</span></span><br><span class="line">      ,<span class="string">&#x27;scan.fetch-size&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;2&#x27;</span> <span class="comment">-- 每次从数据库中fetch大小。默认：1024条</span></span><br><span class="line">      ,<span class="string">&#x27;scan.query-timeout&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;10&#x27;</span> <span class="comment">-- 数据库连接超时时间。默认：不超时</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">-- ,&#x27;scan.partition.column&#x27; = &#x27;id&#x27; -- 多并行度读取的切分字段，必须是表中字段。无默认</span></span><br><span class="line">      <span class="comment">-- ,&#x27;scan.partition.strategy&#x27; = &#x27;range&#x27; -- 数据分片策略。默认：range，如果并行度大于1，且是增量任务或者间隔轮询，则会使用mod分片</span></span><br><span class="line"></span><br><span class="line">      ,<span class="string">&#x27;scan.increment.column&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;id&#x27;</span> <span class="comment">-- 增量字段名称，必须是表中的字段。非必填，无默认</span></span><br><span class="line">      ,<span class="string">&#x27;scan.increment.column-type&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;int&#x27;</span>  <span class="comment">-- 增量字段类型。非必填，无默认</span></span><br><span class="line">      ,<span class="string">&#x27;scan.start-location&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;10&#x27;</span> <span class="comment">-- 增量字段开始位置,如果不指定则先同步所有，然后在增量。非必填，无默认。如果没配置scan.increment.column，则不生效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--       ,&#x27;scan.restore.columnname&#x27; = &#x27;id&#x27; -- 开启了cp，任务从sp/cp续跑字段名称。如果续跑，则会覆盖scan.start-location开始位置，从续跑点开始。非必填，无默认</span></span><br><span class="line"><span class="comment">--       ,&#x27;scan.restore.columntype&#x27; = &#x27;int&#x27; -- 开启了cp，任务从sp/cp续跑字段类型。非必填，无默认</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sink</span><br><span class="line">(</span><br><span class="line">    id          <span class="type">int</span>,</span><br><span class="line">    name        <span class="type">varchar</span>,</span><br><span class="line">    money       <span class="type">decimal</span>,</span><br><span class="line">    dateone     <span class="type">timestamp</span>,</span><br><span class="line">    age         <span class="type">bigint</span>,</span><br><span class="line">    datethree   <span class="type">timestamp</span>,</span><br><span class="line">    datesix     <span class="type">timestamp</span>,</span><br><span class="line">    phone       <span class="type">bigint</span>,</span><br><span class="line">    wechat      STRING,</span><br><span class="line">    income      <span class="type">decimal</span>,</span><br><span class="line">    birthday    <span class="type">timestamp</span>,</span><br><span class="line">    dtdate      <span class="type">date</span>,</span><br><span class="line">    dttime      <span class="type">time</span>,</span><br><span class="line">    today       <span class="type">date</span>,</span><br><span class="line">    timecurrent <span class="type">time</span>,</span><br><span class="line">    aboolean    <span class="type">boolean</span>,</span><br><span class="line">    adouble     <span class="keyword">double</span>,</span><br><span class="line">    afloat      <span class="type">float</span>,</span><br><span class="line">    achar       <span class="type">char</span>,</span><br><span class="line">    abinary     BYTES,</span><br><span class="line">    atinyint    tinyint</span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">      <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;stream-x&#x27;</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sink</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> source;</span><br></pre></td></tr></table></figure><p>在Flinx的home目录中执行sql执行命令，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/finkx -mode standalone -jobType sql -job /$&#123;FLINKX_HOME&#125;/flinkx-examples/sql/mysql/mysql_source_realtime.sql -flinkxDistDir flinkx-dist -flinkConfDir /Users/hunhun/dev/flink/conf -confProp &quot;&#123;\&quot;flink.checkpoint.interval\&quot;:60000&#125;&quot;</span><br></pre></td></tr></table></figure><p>提交之后，提示job失败，报错信息为找不到类，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassNotFoundException：com.dtstack.flinkx.metrics.prometheus.PrometheusReport</span><br></pre></td></tr></table></figure><p>将<code>flinkx-dist/metrics/prometheus</code>目录下的<code>flinkx-metrics-prometheus-master.jar</code>放到flink的lib目录下，重启flink集群，再次提交又提示<code>com.dtstack.flinkx.conf.MetricParam</code>类找不到，将<code>flinkx-core-master.jar</code>包放到flink的lib下，重启之后依然报找不到类，应该是类加载冲突了。</p><p>再看报错信息是将<code>metrics</code>上报到<code>prometheus</code>时，找不到相关的类，那禁止上报就可以了，而且我也没有配置相关的信息，难道是默认配置的？而且json模式下并没有触发这个错误。</p><p>于是对比下sql和json这两个任务的区别(<em>为什么对比呢？是因为我没有找到禁止metrics上报到prometheus的配置。。。</em>)，发现sql是增量拉取表，于是将sql中的增量拉取配置注释掉：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--       ,&#x27;scan.polling-interval&#x27; = &#x27;3000&#x27; --间隔轮训时间。非必填(不填为离线任务)，无默认</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--       ,&#x27;scan.increment.column&#x27; = &#x27;id&#x27; -- 增量字段名称，必须是表中的字段。非必填，无默认</span></span><br><span class="line"><span class="comment">--       ,&#x27;scan.increment.column-type&#x27; = &#x27;int&#x27;  -- 增量字段类型。非必填，无默认</span></span><br><span class="line"><span class="comment">--       ,&#x27;scan.start-location&#x27; = &#x27;10&#x27; -- 增量字段开始位置,如果不指定则先同步所有，然后在增量。非必填，无默认。如果没配置scan.increment.column，则不生效</span></span><br></pre></td></tr></table></figure><p>注释掉再次提交，任务运行成功了。</p><p>由此推断并不是sql默认会上报prometheus，而是增量拉取时触发了上报的逻辑，那接下来跟下代码，看下具体逻辑是什么，是否可以找到对应的配置项进行调整。</p><p>从错误日志中定位<code>BaseRichInputFormat</code>类的<code>175</code>行附近，看到当<code>useCustomReporter</code>为true时，会自定义metrics上报逻辑，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (useCustomReporter()) &#123;</span><br><span class="line">    customReporter =</span><br><span class="line">            DataSyncFactoryUtil.discoverMetric(</span><br><span class="line">                    config, getRuntimeContext(), makeTaskFailedWhenReportFailed());</span><br><span class="line">    customReporter.open();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在<code>BaseRichInputFormat</code>类中，<code>useCustomReporter</code>为false，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** BaseRichInputFormat.class */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">useCustomReporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在返回true，应该是在其子类中被重写了，定位<code>JdbcInputFormat</code>子类，发现<code>useCustomReporter</code>的值与<code>jdbcConf.isIncrement()</code>绑定在一起了，当job是增量任务时，则<code>useCustomReporter</code>为true，这也解释了为什么sql的增量任务报错，而批量任务不报错。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">useCustomReporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jdbcConf.isIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么有这个逻辑，不太好揣摩其用途，不过将其改成false，不会影响主流程，遂将其修改成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">useCustomReporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    return jdbcConf.isIncrement();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先别着急编译打包运行，还有一处需要修改，在<code>initMetric</code>方法中的<code>customReporter</code>处增加判断逻辑，当<code>customReporter</code>为<code>true</code>时，进行设置，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initMetric</span><span class="params">(InputSplit inputSplit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!jdbcConf.isIncrement()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加customReporter相关的判断，</span></span><br><span class="line">    <span class="keyword">if</span> (useCustomReporter()) &#123;</span><br><span class="line">        customReporter.registerMetric(startLocationAccumulator, Metrics.START_LOCATION);</span><br><span class="line">        customReporter.registerMetric(endLocationAccumulator, Metrics.END_LOCATION);</span><br><span class="line">    &#125;</span><br><span class="line">    getRuntimeContext().addAccumulator(start, startLocationAccumulator);</span><br><span class="line">    getRuntimeContext().addAccumulator(end, endLocationAccumulator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次可以打包，提交sql任务了。</p><h2 id="Flinkx-sql模式binlog同步mysql表"><a href="#Flinkx-sql模式binlog同步mysql表" class="headerlink" title="Flinkx sql模式binlog同步mysql表"></a>Flinkx sql模式binlog同步mysql表</h2><p>上面的sql增量同步mysql表，从任务配置上可以推断其增量同步的逻辑是周期性的执行sql，通过某个字段来判断哪些是增量数据，这种模式有个明显的缺点就是数据的更新不够实时。<br>我们可以通过订阅mysql的binlog方式(<strong>前提是mysql开启binlog配置</strong>)，实时同步表的变化。其任务配置如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> source</span><br><span class="line">(</span><br><span class="line">    id          <span class="type">int</span>,</span><br><span class="line">    name        <span class="type">varchar</span>,</span><br><span class="line">    money       <span class="type">decimal</span>,</span><br><span class="line">    dateone     <span class="type">timestamp</span>,</span><br><span class="line">    age         <span class="type">bigint</span>,</span><br><span class="line">    datethree   <span class="type">timestamp</span>,</span><br><span class="line">    datesix     <span class="type">timestamp</span>,</span><br><span class="line">    phone       <span class="type">bigint</span>,</span><br><span class="line">    wechat      STRING,</span><br><span class="line">    income      <span class="type">decimal</span>,</span><br><span class="line">    birthday    <span class="type">timestamp</span>,</span><br><span class="line">    dtdate      <span class="type">date</span>,</span><br><span class="line">    dttime      <span class="type">time</span>,</span><br><span class="line">    today       <span class="type">date</span>,</span><br><span class="line">    timecurrent <span class="type">time</span>,</span><br><span class="line">    aboolean    <span class="type">boolean</span>,</span><br><span class="line">    adouble     <span class="keyword">double</span>,</span><br><span class="line">    afloat      <span class="type">float</span>,</span><br><span class="line">    achar       <span class="type">char</span>,</span><br><span class="line">    abinary     BYTES,</span><br><span class="line">    atinyint    tinyint</span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">      <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;binlog-x&#x27;</span></span><br><span class="line">      ,<span class="string">&#x27;username&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span></span><br><span class="line">      ,<span class="string">&#x27;password&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span></span><br><span class="line">      ,<span class="string">&#x27;cat&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;insert,delete,update&#x27;</span></span><br><span class="line">      ,<span class="string">&#x27;url&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;jdbc:mysql://localhost:3306/tudou?useSSL=false&#x27;</span></span><br><span class="line">      ,<span class="string">&#x27;host&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;localhost&#x27;</span>  <span class="comment">--  canal 地址</span></span><br><span class="line">      ,<span class="string">&#x27;port&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;3306&#x27;</span></span><br><span class="line"><span class="comment">--   ,&#x27;journal-name&#x27; = &#x27;mysql-bin.000001&#x27;</span></span><br><span class="line">      ,<span class="string">&#x27;table&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;tudou.type&#x27;</span></span><br><span class="line">      ,<span class="string">&#x27;timestamp-format.standard&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;SQL&#x27;</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sink</span><br><span class="line">(</span><br><span class="line">    id          <span class="type">int</span>,</span><br><span class="line">    name        <span class="type">varchar</span>,</span><br><span class="line">    money       <span class="type">decimal</span>,</span><br><span class="line">    dateone     <span class="type">timestamp</span>,</span><br><span class="line">    age         <span class="type">bigint</span>,</span><br><span class="line">    datethree   <span class="type">timestamp</span>,</span><br><span class="line">    datesix     <span class="type">timestamp</span>,</span><br><span class="line">    phone       <span class="type">bigint</span>,</span><br><span class="line">    wechat      STRING,</span><br><span class="line">    income      <span class="type">decimal</span>,</span><br><span class="line">    birthday    <span class="type">timestamp</span>,</span><br><span class="line">    dtdate      <span class="type">date</span>,</span><br><span class="line">    dttime      <span class="type">time</span>,</span><br><span class="line">    today       <span class="type">date</span>,</span><br><span class="line">    timecurrent <span class="type">time</span>,</span><br><span class="line">    aboolean    <span class="type">boolean</span>,</span><br><span class="line">    adouble     <span class="keyword">double</span>,</span><br><span class="line">    afloat      <span class="type">float</span>,</span><br><span class="line">    achar       <span class="type">char</span>,</span><br><span class="line">    abinary     BYTES,</span><br><span class="line">    atinyint    tinyint</span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">      <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;print&#x27;</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sink</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> source u;</span><br></pre></td></tr></table></figure><p>flinkx的binlog同步需要结合canal，这种方式个人感觉不太方便，组件较多，而且扩展性也较差，没再进行尝试，而打算使用<code>Flink CDC</code>功能进行测试，随后会有一篇文章进行介绍。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>测试使用了flinkx的json模式和sql模式对mysql表进行批量和增量同步，flinkx还支持很多source，功能比较丰富，而且批量同步不管是json模式还是sql模式配置都比较方便而且也比较简单，但是如果想要通过binlog同步mysql的话，就比较麻烦了，需要配合canal，个人感觉不太方便。</p><p>如果对数据的实时性要求不高的话，flinkx可以开箱即用，还是不错的选择。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;FlinkX是一个基于Flink的批流统一的数据同步工具，既可以采集静态的数据，比如MySQL，HDFS等，也可以采集实时变化的数据，比如MySQL binlog，Kafka等。 同时，FlinkX也是支持原生FlinkSql所有语法和特性的计算框架，具体使用方式可以参考&lt;a href=&quot;https://github.com/DTStack/flinkx&quot;&gt;github上的项目介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本篇记录下在Flink standlone模式下使用Flinx同步mysql数据。&lt;/p&gt;</summary>
    
    
    
    <category term="Flink" scheme="http://yuanba.tech/categories/Flink/"/>
    
    
    <category term="BigData" scheme="http://yuanba.tech/tags/BigData/"/>
    
    <category term="Flink" scheme="http://yuanba.tech/tags/Flink/"/>
    
    <category term="Flinkx" scheme="http://yuanba.tech/tags/Flinkx/"/>
    
    <category term="Connector" scheme="http://yuanba.tech/tags/Connector/"/>
    
  </entry>
  
  <entry>
    <title>openGauss极简版安装使用</title>
    <link href="http://yuanba.tech/openGauss-deploy.html"/>
    <id>http://yuanba.tech/openGauss-deploy.html</id>
    <published>2021-05-13T14:35:20.000Z</published>
    <updated>2021-05-13T15:55:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>openGauss是GaussDB的开源版，从<a href="https://opengauss.org/zh/download.html">官网</a>下载即可。</p><p>这里只是为了测试一些基本功能，所以只下载了极简版。下面记录下安装步骤和遇到的问题。</p><span id="more"></span><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>GaussDB安装不能用root用户，先新建一个专用用户<code>gaussdb</code>，执行命令<code>groupadd gaussdb &amp;&amp; useradd -d /home/gaussdb -m gaussdb -g gaussdb</code><br>解压安装包，执行命令<code>tar -jxvf openGauss-2.0.0-CentOS-64bit.tar.bz2 -C gaussdb-2.0.0</code><br>然后进入<code>simpleInstall</code>目录，执行<code>sh install.sh -w xx</code>命令进行安装。</p><p>如果上述流程正常，则GaussDB安装初步完成。但是我没有这么顺利，遇到些问题。</p><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>执行<code>install.sh</code>命令时，报错<code>SEMMNI</code>参数设置不对，错误信息如下：<br><code>On systemwide basis, the maximum number of SEMMNI is not correct. the current SEMMNI value is: 128. Please check it.</code></p><blockquote><p>解决<br>SEMMNI是在<code>/proc/sys/kernel/sem</code>文件中配置的，修改下就好了，需要注意的是修改方式不能直接vim，需要用echo命令写入，否则会写入不成功。<br>执行命令<code>echo 250    32000    32    2048 &gt; /proc/sys/kernel/sem</code></p></blockquote><p>安装成功之后，需要先验证下能否正常使用，比较安装不报错和能正常使用是两回事。</p><p>执行<code>gsql -d postgres -p 5432</code>，其中端口<code>5432</code>是默认端口，具体端口信息可以在<code>$&#123;GAUSSDB_HOME&#125;/data/single_node/postgresql.conf</code>中查看。</p><p>又报错了。。</p><h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p>是openssl的问题，错误信息如下：<br><code>openssl: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory</code></p><blockquote><p>解决<br>执行<code>openssl version</code>查看当前openssl的版本，我的版本是1.0.2，需要先将openssl升级到1.1，如果还报上面的错，在执行如下命令：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/lib64/libssl.so.1.1 /usr/lib64/libssl.so.1.1</span><br><span class="line">ln -s /usr/local/lib64/libcrypto.so.1.1 /usr/lib64/libcrypto.so.1.1</span><br></pre></td></tr></table></figure><p>这个问题解决完就可以正常使用了，一些常用命令有<code>\c</code>切换数据库，<code>\l</code>查看数据库、<code>\dt</code>查看表、<code>\d tablename</code>查看表结构。</p><h2 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h2><p>管理员帐号无法进行远程连接，新建个用户用于测试远程连接功能，新建用户命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER test PASSWORD &#x27;Test@123&#x27;;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 school库赋权给<span class="built_in">test</span>用户</span></span><br><span class="line">GRANT ALL PRIVILEGES ON DATABASE school to test;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 更改<span class="built_in">test</span>角色</span></span><br><span class="line">ALTER ROLE test CREATEDB;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 赋予用户权限</span></span><br><span class="line">GRANT ALL PRIVILEGES To test;</span><br></pre></td></tr></table></figure><p>使用新建的用户连接测试，执行命令<code>gsql -h xx.xx.xx.xx -d school -U test -p 5432 -r</code><br>报错无法连接，报权限错误，执行命令<code>gs_guc set -N all -I all -h &quot;host all test 192.168.xx.xx/32 sha256&quot;</code>，悲催的是又报错了，错误信息如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">realpath(/home/gaussdb/gaussdb-2.0.0/bin/cluster_static_config) failed : 没有那个文件或目录!</span><br><span class="line">The gs_guc run with the following arguments: [gs_guc -N all -I all -h host all jack 192.168.xx.xx/32 sha256 set ].</span><br><span class="line">gs_guc: malloc 0</span><br></pre></td></tr></table></figure><p>之所以没有这个文件是因为极简版中很多命令都没有，比如<code>gs_om</code>。</p><p>极简版少很多命令文件怎么解决，我只能从新安装个企业版？好麻烦。突然想到在搜索<code>gs_guc</code>这个命令的时候，它修改的是<code>pg_hba.conf</code>这个配置文件，我是不是可以绕过<code>gs_guc</code>命令直接修改配置文件就可以解决，立马去实践。</p><p><code>pg_hba.conf</code>在<code>$&#123;GAUSSDB_HOME&#125;/data/single_node</code>中，通过vim修改，增加<code>host    all             all             192.168.xx.xx/32            sha256</code><br>修改完之后重启下服务就行，搞笑的事情发生了，重启服务需要用到<code>gs_om</code>命令，可是没有咋办。。。</p><p>极简版是通过执行<code>install.sh</code>命令进行安装启动的，那么这个里面应该有启动命令，果然发现了，极简版的启停命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gs_ctl start -D /home/gaussdb/gaussdb-2.0.0/data/single_node -Z single_node</span><br><span class="line">gs_ctl stop -D /home/gaussdb/gaussdb-2.0.0/data/single_node -Z single_node</span><br></pre></td></tr></table></figure><p>终于搞定了，可以远程连接了。</p><h2 id="JDBC连接测试"><a href="#JDBC连接测试" class="headerlink" title="JDBC连接测试"></a>JDBC连接测试</h2><p>代码用官方的就行，加个依赖包，官方也提供了。<br>关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建数据库连接</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">GetConnection</span><span class="params">(String username, String passwd)</span> </span>&#123;</span><br><span class="line">    String driver = <span class="string">&quot;org.postgresql.Driver&quot;</span>;</span><br><span class="line">    String sourceURL = <span class="string">&quot;jdbc:postgresql://192.168.xx.xx:5432/school?useUnicode=true&amp;characterEncoding=utf8&quot;</span>;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//加载数据库驱动。</span></span><br><span class="line">        Class.forName(driver).newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建数据库连接。</span></span><br><span class="line">        conn = DriverManager.getConnection(sourceURL, username, passwd);</span><br><span class="line">        System.out.println(<span class="string">&quot;Connection succeed!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> conn;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="幸运之想"><a href="#幸运之想" class="headerlink" title="幸运之想"></a>幸运之想</h2><p>整个安装测试过程比较坎坷但也很幸运，所遇的问题都能比较简单，比较容易搞定。</p><p>安装使用过程中遇到些问题，有的问题比较普遍可以通过搜索引擎解决，但是有些问题比较独特，无法通过搜索引擎解决，此时就需要我们有解决问题的能力，这个能力从何而来，我认为能力是从思路中而来，而思路又是从经验见识中而来。所以呢还是那句老话，遇到问题不要慌，要多想想，要记住一点，问题肯定是能解决的，只是有的问题解决完就没有了，而有的问题解决完一个又会出现N个。</p><p>也许现在说这些都是风凉话，但现在想想如果当时解决远程连接问题时，没有去多想下，可能就直接更换企业版，然后安装部署，遇到新的问题继续解决问题。<br>但是我很庆幸我没有立马去更换企业版，而是多想了一步，并靠着自己的经验把遇到的问题给解决了，节省了一些时间也增加了自己独立解决问题的信心。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;openGauss是GaussDB的开源版，从&lt;a href=&quot;https://opengauss.org/zh/download.html&quot;&gt;官网&lt;/a&gt;下载即可。&lt;/p&gt;
&lt;p&gt;这里只是为了测试一些基本功能，所以只下载了极简版。下面记录下安装步骤和遇到的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="BigData" scheme="http://yuanba.tech/categories/BigData/"/>
    
    
    <category term="BigData" scheme="http://yuanba.tech/tags/BigData/"/>
    
    <category term="GaussDB" scheme="http://yuanba.tech/tags/GaussDB/"/>
    
    <category term="deploy" scheme="http://yuanba.tech/tags/deploy/"/>
    
  </entry>
  
  <entry>
    <title>姗姗来迟的果实</title>
    <link href="http://yuanba.tech/my-book.html"/>
    <id>http://yuanba.tech/my-book.html</id>
    <published>2021-04-26T15:35:20.000Z</published>
    <updated>2021-04-26T15:55:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>2021年也接近一半了，过去的2020年对谁都是不平凡的一年，对我尤是。<br>2020年在各位编辑老师的帮助下，对书进行了微调，终于在2021年要跟读者见面了，虽然整个战线由于疫情原因被拉了很长，但现在心里依然很激动。</p><p>这是一本关于Hadoop 3的书，书的名字叫《Hadoop 3实战指南》</p><span id="more"></span><p>其实本书按原先的计划是打算在2020年跟大家见面的，当时国内并没有关于Hadoop 3的相关书籍，而当时正在搞一些Hadoop 3的事情，所以我就打算把自己对Hadoop 3的理解以及工作之后在从事Hadoop相关工作时积累的经验分享给大家，所以就有了这本书，由于本人能力有限，书中难免会有理解不到位的地方，请各位大佬帮忙指正。</p><p>本书长这个样子，预计5月份在各大电商开售。<br><img src="/blogimgs/my-book/book.png"></p><p>本书目录：<br>第1章 Hadoop<br>    1.1 简介<br>        1.1.1 Hadoop 1.0<br>        1.1.2 Hadoop 2.0<br>    1.2 Hadoop 3.0<br>    1.3 阅读 Hadoop 源码<br>        1.3.1 单元测试<br>        1.3.2 断点调试代码<br>    1.4 小结<br>第2章 HDFS<br>    2.1 HDFS 简介<br>    2.2 解析NameNode中的元数据及其内存结构<br>        2.2.1 解析NameNode中的元数据<br>        2.2.2 解析NameNode的内存结构<br>    2.3 解析NameNode的HA功能<br>        2.3.1 基于QJM的HA<br>        2.3.2 故障转移<br>        2.3.3 多NameNode模式<br>    2.4 HDFS 的 Federation<br>        2.4.1 基于 viewfs 的 Federation<br>        2.4.2 基于Router的Federation<br>    2.5 纠删码<br>        2.5.1 纠删码的原理<br>        2.5.2 HDFS EC<br>        2.5.3 HDFS EC 的实现<br>        2.5.4 对比HDFS EC策略与三副本策略<br>    2.6 下一代对象存储系统Ozone<br>        2.6.1 Ozone 初体验<br>        2.6.2 Ozone 架构<br>    2.7 小结<br>第3章 YARN<br>    3.1 YARN 简介<br>    3.2 解析ResourceManager的HA功能<br>        3.2.1 故障转移<br>        3.2.2 数据恢复<br>    3.3 YARN Federation<br>        3.3.1 架构<br>        3.3.2 Router<br>        3.3.3 State Store和Policy Store<br>        3.3.4 AMRMProxy<br>        3.3.5 跨子集群运行<br>    3.4 中央调度器<br>        3.4.1 Capacity 调度器<br>        3.4.2 Fair 调度器<br>        3.4.3 调度扩展<br>    3.5 分布式调度器<br>        3.5.1 分布式调度器的架构<br>        3.5.2 opportunistic container<br>    3.6 YARN Shared Cache<br>        3.6.1 资源本地化<br>        3.6.2 Shared Cache 的架构<br>        3.6.3 Shared Cache 实例<br>    3.7 小结<br>第4章 Application on YARN<br>    4.1 MapReduce 的简介<br>    4.2 MapReduce 的源码分析<br>        4.2.1 InputSplit<br>        4.2.2 环形缓冲区<br>        4.2.3 溢写和归并<br>        4.2.4 Shuffle<br>    4.3 MapReduce on YARN<br>        4.3.1 YARN 的事件机制和状态机机制<br>        4.3.2 MR ApplicationMaster<br>    4.4 Application on YARN<br>    4.5 小结<br>第5章 实战指南<br>    5.1 Hadoop 3.x 的部署<br>        5.1.1 Hadoop 3.x HA的部署<br>        5.1.2 Hadoop 3.x Federation 的部署<br>    5.2 Hadoop 升级<br>        5.2.1 Hadoop 2.0 升级为 Hadoop 3.0<br>        5.2.2 Hadoop 3.0 降级为 Hadoop 2.0<br>        5.2.3 升级/降级中遇到的问题<br>    5.3 二次开发<br>        5.3.1 与其他自研系统融合<br>        5.3.2 自身功能扩展之自动识别修复后的数据盘<br>        5.3.3 合并社区 Patch<br>        5.3.4 提交PullRequest<br>    5.4 周边系统平台<br>        5.4.1 任务调度平台<br>        5.4.2 监控平台<br>        5.4.3 集群诊断分析平台<br>    5.5 小结</p><p>希望大家多多支持，有什么问题可以随时找我沟通。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2021年也接近一半了，过去的2020年对谁都是不平凡的一年，对我尤是。&lt;br&gt;2020年在各位编辑老师的帮助下，对书进行了微调，终于在2021年要跟读者见面了，虽然整个战线由于疫情原因被拉了很长，但现在心里依然很激动。&lt;/p&gt;
&lt;p&gt;这是一本关于Hadoop 3的书，书的名字叫《Hadoop 3实战指南》&lt;/p&gt;</summary>
    
    
    
    <category term="Hadoop" scheme="http://yuanba.tech/categories/Hadoop/"/>
    
    
    <category term="Hadoop" scheme="http://yuanba.tech/tags/Hadoop/"/>
    
    <category term="BigData" scheme="http://yuanba.tech/tags/BigData/"/>
    
    <category term="YARN" scheme="http://yuanba.tech/tags/YARN/"/>
    
    <category term="HDFS" scheme="http://yuanba.tech/tags/HDFS/"/>
    
  </entry>
  
  <entry>
    <title>坑娃-防沉迷App</title>
    <link href="http://yuanba.tech/android-app-timeup.html"/>
    <id>http://yuanba.tech/android-app-timeup.html</id>
    <published>2021-02-11T02:31:19.000Z</published>
    <updated>2021-02-12T05:30:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>猿爸：屁孩，已经看了很长xx了，该让眼睛休息下了。<br>屁孩：不情不愿的关了，去玩别的。<br>很和谐是不是？当你不在家的时候，屁孩就没这么乖了，是不是，认同不？<br>这时就需要有一个强势的“人”来阻止他，这个可别奢望老人来阻止他，于是只能让“机器人”来搞了。</p><p>于是搞了个App，名字叫<strong>坑娃神器</strong>（不知道若干年后，屁孩看到这个文章心里是什么滋味。。。），功能比较简单，就是监控指定app的活动状态，如果连续运行一段时间，坑娃神器就会自动从后台切到前台进行倒计时，倒计时结束之后可以继续娱乐。</p><p>这个App目前只是处于原始社会版，希望有能力的猿爸们加入，我们一起将其完善，帮助下一代养成一个好的自律能力，此App已在github上开源，欢迎贡献，项目地址<a href="https://github.com/hunshenshi/timeup.git">https://github.com/hunshenshi/timeup.git</a></p><span id="more"></span><h2 id="调研–准备工作"><a href="#调研–准备工作" class="headerlink" title="调研–准备工作"></a>调研–准备工作</h2><p>找了下目前市面已有的工具和一些手机自带的健康使用的功能，不太满足我的需求，<br>1、大多数都是限制每天累计使用时长，而我希望每使用一段时间就休息一会，而不关注累计时长<br>2、由于市面上都是一些面向广大用户的产品，达到时长之后会有提示，而不会有更激烈的行为。而我的需求强硬，再强硬（反正用户只有家长的娃）</p><blockquote><p>我想要的功能也比较简单，就是当检测到前台视频类的软件连续运行一段时间之后，依然在运行，就将其切换到后台，并将倒计时页面切换至前台，等待倒计时结束。随后再次进行下一轮监控，不监控累计时长，只监控连续使用时长，并且强制切换App。</p></blockquote><p>没有现成的轮子那就自己造一个吧，梳理下会用到的技术点：<br>1、App保活，因为需要坑娃神器长期存活于后台进行监控<br>2、如何拿到正在运行的app<br>3、定时执行，需要坑娃神器定期检测前台运行的app是什么<br>4、后台唤醒，需要坑娃神器从后台唤醒到前台进行倒计时</p><p>看了些相关的文章，感觉功能大都可以实现，只是安卓的版本太多了，各种功能在各个版本中实现方式又不一样，在这特别同情搞安卓的朋友，真不容易呀。。。</p><h2 id="第一个Android-Application"><a href="#第一个Android-Application" class="headerlink" title="第一个Android Application"></a>第一个Android Application</h2><p>决定要搞了，那就先从Hello World开始吧，首先下载个Android Studio，然后根据向导创建一个android应用，这里语言我选的是java，一路下来就能运行一个demo app了。具体步骤如下：<br><img src="/blogimgs/android-monitor/app01.png" alt="新建project" title="新建project"><br>新建project之后，进入选择模版页面，这里我选的是basic，下面还有很多模版可以选<br><img src="/blogimgs/android-monitor/app02.png" alt="选择project" title="选择project"><br>选择下一步之后，填写project相关的信息，比如project名字，需要的语言和sdk<br><img src="/blogimgs/android-monitor/app03.png" alt="填写project信息" title="填写project信息"><br>点击Finish就结束了，等待IDE加载程序就行了。</p><p>这个过程可能会比较慢，主要是gradle-5.6.4-all.zip下载慢，你可以使用迅雷下载，然后放到指定的目录就OK了。</p><h2 id="App保活"><a href="#App保活" class="headerlink" title="App保活"></a>App保活</h2><p>App保活这个话题，不搜不知道，一搜是打开眼界呀，充分展现了群众的智慧呀。什么双Activity相互唤醒、播放无声音频各种奇淫巧技。<br>不过我这里就自己用，这么多的奇淫巧技我是用不上了（就算需要用上我也没有那么高深的功力），规规矩矩的申请权限吧。</p><p>常驻后台需要申请电池白名单权限，网上有很多代码示例，相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS);</span><br><span class="line">context.startActivity(intent);</span><br></pre></td></tr></table></figure><h2 id="获取正在运行的App"><a href="#获取正在运行的App" class="headerlink" title="获取正在运行的App"></a>获取正在运行的App</h2><p>如何通过代码拿到正在前台展示的app，也是困难重重，对于一无所知的我依然是先网上搜一堆demo，然后测试。<br>搜素的结果大体分为3种，主要分布在不同的sdk版本中，已经过时的有<code>getRunningTasks</code>和<code>getRunningAppProcesses</code>，在新版sdk中都普遍使用<code>UsageStatsManager</code>，使用<code>UsageStatsManager</code>时需要申请权限，而且通过它获取app的方法网上也有好几种，我对比了几种使用的是<code>queryUsageStats</code>方法，还可以使用<code>queryEvents</code>方法，不过我测试发现<code>queryEvents</code>状态变更没有<code>queryUsageStats</code>及时。（不要问我为什么测试了这么多方法。。）</p><p>整体思路是通过<code>queryUsageStats</code>查询一段时间内的App使用信息，然后对App的最后更新时间进行排序，时间最大的就是正在前台展示的App。代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取UsageStats集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;UsageStats&gt;  <span class="title">getUsageStatsList</span><span class="params">(Context context, <span class="keyword">long</span> startTime, <span class="keyword">long</span> endTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        UsageStatsManager manager = (UsageStatsManager) context.getApplicationContext().getSystemService(Context.USAGE_STATS_SERVICE);</span><br><span class="line">        List&lt;UsageStats&gt;  usageStatses = manager.queryUsageStats(UsageStatsManager.INTERVAL_BEST, startTime, endTime);</span><br><span class="line">        <span class="keyword">if</span> (usageStatses == <span class="keyword">null</span> || usageStatses.size() == <span class="number">0</span>) &#123;<span class="comment">// 没有权限，获取不到数据</span></span><br><span class="line">            Log.i(<span class="string">&quot;AppUtil getUsageStatsList &quot;</span>, <span class="string">&quot;no permission for UsageStatsManager&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> usageStatses;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对最后更新时间进行排序获取前台App</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> UsageStats <span class="title">getForegroundUsageStats</span><span class="params">(Context context, <span class="keyword">long</span> startTime, <span class="keyword">long</span> endTime)</span> </span>&#123;</span><br><span class="line">    UsageStats usageStatsResult = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        List&lt;UsageStats&gt; usageStatses = getUsageStatsList(context, startTime, endTime);</span><br><span class="line">        <span class="keyword">if</span> (usageStatses == <span class="keyword">null</span> || usageStatses.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (UsageStats usageStats : usageStatses) &#123;</span><br><span class="line">            <span class="comment">// 通过反射获取App的事件类型</span></span><br><span class="line">            <span class="keyword">int</span> lastEvent = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Field mLastEventField = UsageStats.class.getField(<span class="string">&quot;mLastEvent&quot;</span>);</span><br><span class="line">                mLastEventField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                lastEvent = mLastEventField.getInt(usageStats);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (usageStatsResult == <span class="keyword">null</span> || usageStatsResult.getLastTimeUsed() &lt; usageStats.getLastTimeUsed()) &#123;</span><br><span class="line">                usageStatsResult = usageStats;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> usageStatsResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定时周期执行任务"><a href="#定时周期执行任务" class="headerlink" title="定时周期执行任务"></a>定时周期执行任务</h2><p>由于这只是个坑娃的App，所以这里直接简单粗暴的使用定时任务来check前台App是否为所要监控的App，而没有使用各种Trigger。<br>Android中的定时任务主要是<code>Timer</code>和<code>AlarmManager</code>，推荐使用<code>AlarmManager</code>，而且不需要申请权限。</p><p><code>AlarmManager</code>结合<code>Service</code>使用，在高版本的sdk中，<code>AlarmManager</code>没有重复执行的功能，需要在<code>Service</code>再次调用<code>AlarmManager</code>从而起到重复执行任务的功能。而且在高版中为了节省电量也进行了很多优化，要想精准出发定时器需要使用<code>setExactAndAllowWhileIdle</code>方法，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);</span><br><span class="line"><span class="comment">// CheckService是定时器触发之后要具体执行的任务逻辑</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(context, CheckService.class);</span><br><span class="line">pendingIntent = PendingIntent.getService(context, <span class="number">0</span>, intent, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// AlarmManager.ELAPSED_REALTIME_WAKEUP是为了能主动唤醒CPU</span></span><br><span class="line">am.setExactAndAllowWhileIdle(AlarmManager.ELAPSED_REALTIME_WAKEUP,</span><br><span class="line">                    SystemClock.elapsedRealtime(), pendingIntent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在CheckService的onStartCommand方法中执行定时任务逻辑，并且执行完之后继续设置定时器，起到重复执行的效果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// check前台App是否为需要监控的App，如果是执行相应的操作</span></span><br><span class="line">        <span class="comment">// 再次调用定时器</span></span><br><span class="line">        am.setExactAndAllowWhileIdle(AlarmManager.ELAPSED_REALTIME_WAKEUP,</span><br><span class="line">                    SystemClock.elapsedRealtime() + TIME_INTERVAL, pendingIntent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意两次调用定时器的不同，在<code>CheckService</code>中调用时Trigger为<code>SystemClock.elapsedRealtime() + TIME_INTERVAL</code>，代表延后<code>TIME_INTERVAL</code>之后触发。</p><h2 id="后台唤醒"><a href="#后台唤醒" class="headerlink" title="后台唤醒"></a>后台唤醒</h2><p>后台唤醒是指正在后台运行的App由于某种原因被切换到前台。</p><p>如果是在低版本的sdk中可以使用<code>getRunningTasks</code>，拿到对应package的task信息，其中包括taskId，然后调用<code>moveTaskToFront</code>方法将其任务切换到前台，但是<code>getRunningTasks</code>已被标注为过时的，所以在上面获取前台App时也没用该方法。</p><p>这里使用了新建Activity的方法，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toRunningForeground</span><span class="params">(String packageNameTarget)</span> </span>&#123;</span><br><span class="line">    PackageManager packageManager = getPackageManager();</span><br><span class="line"></span><br><span class="line">    Intent intent = packageManager.getLaunchIntentForPackage(packageNameTarget);</span><br><span class="line">    intent.addCategory(Intent.CATEGORY_LAUNCHER);</span><br><span class="line">    intent.setFlags(Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED | Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**android.intent.action.MAIN：打开另一程序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    intent.setAction(<span class="string">&quot;android.intent.action.MAIN&quot;</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * FLAG_ACTIVITY_SINGLE_TOP:</span></span><br><span class="line"><span class="comment">     * 如果当前栈顶的activity就是要启动的activity,则不会再启动一个新的activity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);</span><br><span class="line">    activity.startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="踩坑实录"><a href="#踩坑实录" class="headerlink" title="踩坑实录"></a>踩坑实录</h2><p>主要功能开发完成，并在IDE中正常运行，下面就要实机测试了，前方冰冷的洪水迎面拍来！！！</p><p>将App安装到平板上之后，进行测试发现应该切换倒计时页面时并没有正常切换，于是下面就开始了取经之后：</p><ol><li>sdk版本不兼容<br>因为Android sdk各版本有可能不兼容，所以首先怀疑是不是sdk的问题，于是在IDE中设置了对应版本，发现确实没有生效，于是搜索对应sdk后台切换前台的相关问题，发现可能是权限问题，sdk 29之后限制了App的相应权限，需要申请浮窗权限，申请代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestOverlayPermission</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION);</span><br><span class="line">    context.startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>获取当前App<br>申请相应权限之后，在IDE中可以正常运行，再次部署到平板上进行测试，发现依然没有生效，继续排查。<br>在IDE中多次排查时偶然发现获取当前App时，有次拿到了<code>com.xx.android.launcher</code>，以为是获取前台App不准确原因造成的，于是就用了好多种方法进行测试，发现始终未生效。但是在真机测试的过程中，发现一个规律，<strong>只要插上usb，App就运行正常</strong>，在IDE中查看App在平板上的运行日志也正常，可是拔掉usb就不生效，也看不到当时的日志，于是就想打印些关键信息在平板上查看进行排查问题。</p></li><li><p>真机上查看运行日志<br>看一些日志教程好复杂，专门搞一下真的不值得呀，于是想到是不是可以把关系信息写到一个可读的文件里，于是将其写入，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">(Context context, String filename, String filecontent)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileOutputStream output = context.openFileOutput(filename, Context.MODE_APPEND);</span><br><span class="line">    output.write(filecontent.getBytes());</span><br><span class="line">    output.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用时只传入文件名就行，默认写到<code>/data/data/app/com.xx/files</code>目录下，去平板上找这个目录，却没有找到。。。不过连上usb可以在IDE的<code>Device File Explorer</code>中找到，于是再次的测试流程就是拔掉usb进行测试，然后连上usb进行文件查看运行信息。</p></li><li><p>怀疑AlarmManger在后台不生效<br>查看App写入文件的信息之后，发现定时器只是第一次启动了，随后的定时器并未触发。<br>在使用<code>AlarmManger</code>时也没有要求申请什么权限，搜索之后也没有找到任何线索，于是资源一些专业人士，朋友说可能是定时器触发间隔时间太短，系统给优化了，并附上了源码中的方法注释，可信度很高呀，我也很开心，要搞定了，可是修改安装之后依然是暴击呀。</p></li></ol><p>此时真的陷入了死胡同，没有任何线索，一连好几天没有任何进展，偶然在手机上查看应用权限的时候，想到是不是平板自动启停的原因，于是将App的自动管理切换为手动管理，再次进行测试，生效了。</p><p>太艰辛了，为了坑个娃太不容易了。。。</p><p>这个App目前只是处于原始社会版，希望有能力的猿爸们加入，我们一起将其完善，帮助下一代养成一个好的自律能力，此App已在github上开源，欢迎贡献，项目地址<a href="https://github.com/hunshenshi/timeup.git">https://github.com/hunshenshi/timeup.git</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>其实写这个App并不完全是为了完全阻止他玩平板，只是为了培养他解决问题，善于思考的能力，让他知道如何去达到自己的目的。因为这个App本身比较简单，可能只能阻止他几天，然后他会发现这个App的逻辑漏洞，然后我再想办法把这个漏洞堵上，继续等待他发现新的漏洞，希望在这个过程中能培养他的好奇欲。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;猿爸：屁孩，已经看了很长xx了，该让眼睛休息下了。&lt;br&gt;屁孩：不情不愿的关了，去玩别的。&lt;br&gt;很和谐是不是？当你不在家的时候，屁孩就没这么乖了，是不是，认同不？&lt;br&gt;这时就需要有一个强势的“人”来阻止他，这个可别奢望老人来阻止他，于是只能让“机器人”来搞了。&lt;/p&gt;
&lt;p&gt;于是搞了个App，名字叫&lt;strong&gt;坑娃神器&lt;/strong&gt;（不知道若干年后，屁孩看到这个文章心里是什么滋味。。。），功能比较简单，就是监控指定app的活动状态，如果连续运行一段时间，坑娃神器就会自动从后台切到前台进行倒计时，倒计时结束之后可以继续娱乐。&lt;/p&gt;
&lt;p&gt;这个App目前只是处于原始社会版，希望有能力的猿爸们加入，我们一起将其完善，帮助下一代养成一个好的自律能力，此App已在github上开源，欢迎贡献，项目地址&lt;a href=&quot;https://github.com/hunshenshi/timeup.git&quot;&gt;https://github.com/hunshenshi/timeup.git&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="tool" scheme="http://yuanba.tech/categories/tool/"/>
    
    
    <category term="android" scheme="http://yuanba.tech/tags/android/"/>
    
    <category term="app" scheme="http://yuanba.tech/tags/app/"/>
    
    <category term="防沉迷" scheme="http://yuanba.tech/tags/%E9%98%B2%E6%B2%89%E8%BF%B7/"/>
    
    <category term="生活" scheme="http://yuanba.tech/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch运维踩坑</title>
    <link href="http://yuanba.tech/elasticsearch-op.html"/>
    <id>http://yuanba.tech/elasticsearch-op.html</id>
    <published>2020-08-03T03:33:12.000Z</published>
    <updated>2020-08-03T03:33:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>接触ES也小半年了，ES虽然使用方便，运维简单但是集群规模和数据量大的话运维也很头疼，这里梳理下这半年的运维经验。</p><span id="more"></span><h2 id="磁盘坑"><a href="#磁盘坑" class="headerlink" title="磁盘坑"></a>磁盘坑</h2><p>集群随着使用，数据会积累越来越多，磁盘消耗也会越来越大，此时为了保护某个磁盘被写满，需要给磁盘设置阈值，配置项为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 磁盘使用超过此值，将不再接受shard的均衡，只接受主shard的写入</span></span><br><span class="line">cluster.routing.allocation.disk.watermark.low</span><br><span class="line"><span class="comment"># 磁盘使用超过此值，磁盘上的shard开始向其他磁盘迁移，释放磁盘空间</span></span><br><span class="line">cluster.routing.allocation.disk.watermark.high</span><br><span class="line"><span class="comment"># 磁盘使用超过此值，节点将不再提供服务</span></span><br><span class="line">cluster.routing.allocation.disk.watermark.flood_stage</span><br></pre></td></tr></table></figure><p>配置项值的默认形式是百分比，也可以是绝对值。<br>如果集群进行了扩容，各个机器的磁盘大小不一，此时依然使用百分比的话对磁盘大机器就会造成存储空间浪费，将百分比改为绝对值可以充分使用各个不同大小的磁盘。</p><h2 id="shard重新分配"><a href="#shard重新分配" class="headerlink" title="shard重新分配"></a>shard重新分配</h2><p>集群中某个DataNode实例挂掉或者集群中某个磁盘的使用率达到上线，就需要对shard进行重新分配，有几个配置项可以对其调整，加快分配的速度，配置项为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实例用来控制接收和分发shard的线程数</span></span><br><span class="line">cluster.routing.allocation.node_concurrent_recoveries</span><br><span class="line"><span class="comment"># 控制从本地恢复主分片的线程数</span></span><br><span class="line">cluster.routing.allocation.node_initial_primaries_recoveries</span><br></pre></td></tr></table></figure><p><code>node_concurrent_recoveries</code>不宜设置的太大，如果集群规模没有超过百台，设置为DataNode实例个数的一半即可。<br><code>node_initial_primaries_recoveries</code>此值可根据机器配置进行设置即可。</p><h2 id="重启坑"><a href="#重启坑" class="headerlink" title="重启坑"></a>重启坑</h2><p>当集群实例宕机出现雪崩无法恢复时，需要重启集群进行恢复。但是由于ES重启之后需要加载所有索引的shard之后集群才可正常使用，而ES会自动对索引shard根据现有的集群状态对shard进行重分配，这个分配过程是比较耗时而且针对<strong>集群重启</strong>的场景是没有意义的，因为集群只是重启，shard并没有丢失。<br>所以在集群重启之时可以将<code>cluster.routing.allocation.enable</code>设置为none，等所有的DataNode实例启动之后再将其设置为all。</p><h2 id="大查询"><a href="#大查询" class="headerlink" title="大查询"></a>大查询</h2><p>数据查询量大，会触发ES的内存保护机制进行熔断，可以增加单独的查询客户端，并增加客户端实例的内存。随后设置集群配置，配置项为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># </span></span><br><span class="line">indices.breaker.total.limit</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">indices.breaker.fielddata.limit</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">indices.breaker.request.limit</span><br></pre></td></tr></table></figure><h2 id="排查问题工具"><a href="#排查问题工具" class="headerlink" title="排查问题工具"></a>排查问题工具</h2><ul><li>集群状态发生变化<ul><li>使用命令<code>ip:9200/_cluster/health?pretty</code>查询集群状态，如果集群状态发生了变化，可以从中分析原因</li></ul></li><li>节点正常，但是集群状态不是green<ul><li>使用命令<code>ip:9200/_cat/indices?v</code>，此命令会返回所有索引的状态，找到非green的索引，然后具体分析。</li></ul></li><li>查询分片失败原因<ul><li>命令<code>ip:9200/_cluster/allocation/explain</code></li></ul></li><li>查询索引分片状态<ul><li>命令<code>ip:9200/_cat/shards/index_name?v</code></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;接触ES也小半年了，ES虽然使用方便，运维简单但是集群规模和数据量大的话运维也很头疼，这里梳理下这半年的运维经验。&lt;/p&gt;</summary>
    
    
    
    <category term="bigdata" scheme="http://yuanba.tech/categories/bigdata/"/>
    
    
    <category term="BigData" scheme="http://yuanba.tech/tags/BigData/"/>
    
    <category term="ElasticSearch" scheme="http://yuanba.tech/tags/ElasticSearch/"/>
    
    <category term="运维" scheme="http://yuanba.tech/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>golang指针*和取址&amp;傻傻分不清楚</title>
    <link href="http://yuanba.tech/golang-point-address.html"/>
    <id>http://yuanba.tech/golang-point-address.html</id>
    <published>2020-05-03T09:24:05.000Z</published>
    <updated>2020-05-03T15:33:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>golang中有指针的概念，有指针相对的就有取址，何时使用指针何时使用取址对于刚接触的同学总是有点傻傻分不清楚。<br>本篇主要介绍下指针和取址的概念和区别。</p><span id="more"></span><p>指针类似于变量和常量，在使用指针前你需要声明指针。指针声明格式如下：<code>var name *Type</code>。<br>指针是指向一个<strong>值的内存地址</strong>，也就是说指针变量存放的是某个值或者对象的<strong>内存地址</strong>，即指针变量占用字节的大小与所指向的值的大小无关。<em>当一个指针被定义后没有分配到任何变量时，它的默认值为nil。</em></p><p>指针变量存放的是一个值的内存地址，那如何获取一个变量的内存地址呢？那就需要使用取址符号<code>&amp;</code>。<br>将一个值的内存地址通过<code>&amp;</code>赋值给了指针，那又应该如何通过指针来读取对应的值？需要使用符号<code>*</code>，需要与指针声明时的<code>*</code>进行区别。</p><p>看个代码感受下吧，代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 声明一个指针</span></span><br><span class="line"><span class="keyword">var</span> addr *<span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> house = <span class="string">&quot;Malibu Point 10880, 90265&quot;</span></span><br><span class="line"><span class="comment">// 通过&amp;将一个变量的内存地址赋值给指针</span></span><br><span class="line">addr = &amp;house</span><br><span class="line"><span class="comment">// 通过*获取指针中存储的地址对应的值</span></span><br><span class="line">value := *addr</span><br><span class="line">fmt.Printf(<span class="string">&quot;addr type: %T\n&quot;</span>, addr)</span><br><span class="line"><span class="comment">// 输出指针存储的内存地址，也就是house的内存地址</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;address: %p\n&quot;</span>, addr)</span><br><span class="line"><span class="comment">// 输出addr自身的内存地址</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;address: %p\n&quot;</span>, &amp;addr)</span><br><span class="line">fmt.Printf(<span class="string">&quot;value type: %T\n&quot;</span>, value)</span><br><span class="line">fmt.Printf(<span class="string">&quot;value: %s\n&quot;</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// addr type: *string</span></span><br><span class="line"><span class="comment">// address: 0xc000010200</span></span><br><span class="line"><span class="comment">// address: 0xc00000e028</span></span><br><span class="line"><span class="comment">// value type: string</span></span><br><span class="line"><span class="comment">// value: Malibu Point 10880, 90265</span></span><br></pre></td></tr></table></figure><p>代码先通过指针声明方式声明了一个<code>addr</code>指针，又通过取址符号<code>&amp;</code>将house的地址赋值给<code>addr</code>，然后又通过<code>*</code>将指针<code>addr</code>存储内存地址对应的值赋值给普通变量<code>value</code>。由于指针<code>addr</code>变量存储的是变量<code>house</code>的内存地址，所以输出的<code>addr</code>的值为一个内存地址，而又因为指针<code>addr</code>本身也是一个变量，也需要一个内存块来存储自己，所以通过取址符号<code>&amp;</code>得到的地址是指针变量的内存地址。</p><p>初看上面的代码，对其中的<code>*</code>和<code>&amp;</code>是不是傻傻分不清楚。<code>&amp;</code>功能比较单一，就是取址，获取变量的内存地址。<code>*</code>有<em>两种含义</em>，第一种是在指针声明时跟在变量的后面，紧跟变量类型，代表该变量是一个指针变量，如果使用<code>%p</code>来输出的话，它将是一个16进制数，第二种是紧跟指针变量，出现在指针变量的前面，代表获取该指针存储内存地址的值，一般是一个和指针类型一致的变量或者常量。在上面的demo代码中都有体现。</p><blockquote><p>Tips<br>go中何时使用指针？</p></blockquote><ul><li>当结构体较大的时候使用指针会更高效，可以避免内存拷贝</li><li>如果要修改结构体内部的数据或状态必须使用指针</li><li>如果方法的receiver是map、slice 、channel等引用类型不要使用指针</li><li>如果该函数需要将传入变量的修改状态传递出去，可以使用指针</li></ul><!--切片slice、字典map、管道channel引用类型的特点是：变量存储的是一个地址，这个地址对应的空间里才是真正存储的值，内存通常在堆中分配golang中到底有没有引用类型按照Golang的说法,Golang中所有的类型都是属于值类型,但是有几个类型比较特殊,表现出引用类型的特征go life, golang[够浪]unsafe是什么引用类型 是什么， 值类型引用类型是什么？golang中是否有引用类型？Go语言中有4个类型比较特别，看起来像引用类型引用类型 与 引用语义引用：就是变量的一个别名。java 引用变量-->]]></content>
    
    
    <summary type="html">&lt;p&gt;golang中有指针的概念，有指针相对的就有取址，何时使用指针何时使用取址对于刚接触的同学总是有点傻傻分不清楚。&lt;br&gt;本篇主要介绍下指针和取址的概念和区别。&lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://yuanba.tech/categories/golang/"/>
    
    
    <category term="go" scheme="http://yuanba.tech/tags/go/"/>
    
    <category term="golang" scheme="http://yuanba.tech/tags/golang/"/>
    
    <category term="指针" scheme="http://yuanba.tech/tags/%E6%8C%87%E9%92%88/"/>
    
    <category term="取址" scheme="http://yuanba.tech/tags/%E5%8F%96%E5%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>golang随波逐流之cache2go知识点解读</title>
    <link href="http://yuanba.tech/golang-cache2go-sec.html"/>
    <id>http://yuanba.tech/golang-cache2go-sec.html</id>
    <published>2020-04-13T16:17:00.000Z</published>
    <updated>2020-05-03T09:22:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://bigdatadecode.top/golang-cache2go-src.html">上篇</a>介绍了cache2go的代码逻辑，梳理代码逻辑时也能从中了解golang的一些语法以及使用技巧，本篇集中将源码中涉及到的知识点梳理下。</p><span id="more"></span><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><blockquote><p>结构体</p></blockquote><p>在mycachedapp.go文件中，看到的第一行有效代码是<code>type myStruct struct</code>，感觉有点像C语言中的结构体。<br>这个语句块定义了一个结构体，结构体是golang中一个比较重要的知识点，功能类似于JAVA中的类。</p><p>使用<code>type xName struct&#123;&#125;</code>定义一个结构体，mycachedapp.go中结构体相关的代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">text     <span class="keyword">string</span></span><br><span class="line">moreData []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实力化myStruct的对象</span></span><br><span class="line">val := myStruct&#123;<span class="string">&quot;This is a test!&quot;</span>, []<span class="keyword">byte</span>&#123;&#125;&#125;</span><br></pre></td></tr></table></figure><!-- // 区别，val相当于一个指针，一个引用类型val := &myStruct{"This is a test!", []byte{}}--><p>上述代码声明了一个名字为<code>myStruct</code>的结构体，其成员变量为<code>string</code>类型的<code>text</code>和<code>byte</code>类型的数组<code>moreData</code>。<br>紧着这初始化了一个<code>myStruct</code>对象并在初始化时对成员变量赋值，默认是按照变成声明的顺序依次赋值，也可以显示的指定变量进行赋值，例如<code>val := myStruct&#123;text: &quot;This xx&quot;&#125;</code>，未赋值的为类型的默认值，有点类似python。</p><p>结构体除了可以定义自己的成员变量，也可以定义成员方法。成员发方法的定义与普通函数的定义类似，只是在关键字<code>func</code>和函数名之间增加了函数归属哪个结构体的信息，如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个结构体</span></span><br><span class="line"><span class="keyword">type</span> Rect <span class="keyword">struct</span> &#123; </span><br><span class="line">x, y <span class="keyword">float64</span></span><br><span class="line">width, height <span class="keyword">float64</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义该结构体的成员方法</span></span><br><span class="line"><span class="comment">// 在关键字func和方法名之间增加方法归属的结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rect)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float64</span></span> &#123; </span><br><span class="line"><span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是结构体虽然类似其他语言中的类，但是golang结构体中并没有构造函数的概念，<strong>对象的创建通常交由一个全局的创建函数来完成</strong>，以<code>NewXXX</code>来命名，表示”构造函数”，例如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRect</span><span class="params">(x, y, width, height <span class="keyword">float64</span>)</span> *<span class="title">Rect</span></span> &#123; </span><br><span class="line"><span class="keyword">return</span> &amp;Rect&#123;x, y, width, height&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过&quot;构造函数&quot;创建Rect</span></span><br><span class="line">rect := NewRect(<span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>, <span class="number">6.6</span>)</span><br></pre></td></tr></table></figure><p>新类型可以像结构体那样新建，也可以基于已有的类型进行创建一个新的类型，语法为<code>type NewType Type</code>，<code>cachetable.go</code>文件中的<code>CacheItemPairList</code>就是基于已有类型进行新建的，代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CacheItemPair <span class="keyword">struct</span> &#123;</span><br><span class="line">Key         <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">AccessCount <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CacheItemPairList []CacheItemPair</span><br></pre></td></tr></table></figure><p>与基于已有类型新建类型的写法类似的是<code>类型别名</code>，其语法为<code>type alias = Type</code>，注意这里是等号。而且新建类型时Type已经发生了变化，而别名的Type并没有发生变化。</p><blockquote><p>数组 VS 切片</p></blockquote><p>数组几乎是所有编程语言中常用的数据结构，想必大家对其也比较了解，可以通过索引快速访问其值。数组的声明方式为<code>var variable_name [SIZE] variable_type</code>，代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x [<span class="number">32</span>]<span class="keyword">byte</span> =</span><br><span class="line"><span class="keyword">var</span> y [<span class="number">1000</span>]*<span class="keyword">float64</span> </span><br><span class="line"><span class="keyword">var</span> z [<span class="number">3</span>][<span class="number">5</span>]<span class="keyword">int</span> </span><br><span class="line"><span class="keyword">var</span> w [<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>]<span class="keyword">float64</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span> = [<span class="number">10</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125; <span class="comment">// 长度为5，...代表自动计算长度</span></span><br></pre></td></tr></table></figure><p>数组在使用过程中有个诟病就是长度在初始化时需要指定，并且后续无法改变。为了解决此问题各种语言都增加其它数据结构，golang中增加的是切片(slice)。<br>切片有一个初始数据长度，使用<code>len</code>函数获取，还有一个预留空间长度，预留空间用光之后会自动扩容，使用<code>cap</code>函数获取预留空间长度。切片的创建有两种方式，一种是直接创建，另一种是根据数组创建。</p><ul><li>直接创建需要使用关键字<code>make</code>，代码为<code>var mySlice []int or mySlice1 := make([]int, 5)</code></li><li>根据数组创建的话需要先创建一个数据，然后将数组的值赋值给切片，代码为</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray [<span class="number">10</span>]<span class="keyword">int</span> = [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125; <span class="comment">// 基于数组创建一个数组切片</span></span><br><span class="line"><span class="keyword">var</span> mySlice []<span class="keyword">int</span> = myArray[:<span class="number">5</span>]</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">mySlice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; <span class="comment">// 注意这里中括号中没有长度，如果有长度就变成数组的创建了</span></span><br></pre></td></tr></table></figure><p>数组和切片还有一个区别就是<em>数组作为参数或者变量之间赋值时，是复制一份，相互之间不影响</em>，例如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="keyword">var</span> b = a</span><br><span class="line">b[<span class="number">1</span>]++</span><br><span class="line">fmt.Println(a, b) <span class="comment">// a和b之间不受影响，print [1 2 3] [1 3 3]</span></span><br></pre></td></tr></table></figure><p>但是<strong>切片却可以在参数传递中，将修改的结果作用在同一份数据上</strong>，例如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">slice1 := []<span class="keyword">int</span>&#123;<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>&#125;</span><br><span class="line">fmt.Println(slice1)</span><br><span class="line">modify(slice1)</span><br><span class="line">fmt.Println(slice1) <span class="comment">// 输出1,6,6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(slice1 []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">fmt.Println(slice1)</span><br><span class="line">slice1[<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片slice表现出来的现象有点像引用类型，但是<strong>要切记slice并不是引用类型，只是表现出来引用语义而已</strong>。在<strong>golang中其实只有值传递</strong>，slice表现出来的引用语义其实只是golang的一个语法糖，具体看下这个语法糖是怎么实现的。<br>slice的声明如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">array unsafe.Pointer</span><br><span class="line"><span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line"><span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>slice结构体有一个<code>unsafe.Poiniter</code>的指针，他指向一个数组，剩下两个属性一个代表数据的长度另一个代表容量。<br>当slice进行变量传递或者参数传递时，依然是将其值拷贝一份，此时<code>unsafe.Poiniter</code>类型的指针<code>array</code>将其存储的<strong>数组地址</strong>也拷贝了一份，所以对传递之后的变量进行修改会影响原始slice的结果。示意图如下：<br><img src="/blogimgs/golang-grammar/slice.png" alt="slice变量" title="slice变量"><br>其中<code>[]int</code>是一个数组，存放slice中的数据，<code>slice1</code>是slice的一个实例，<code>slice1</code>对<code>slice2</code>进行了赋值。赋值时进行了值传递，将<code>slice1</code>中的数据拷贝了一份给<code>slice2</code>，<code>slice1</code>中的<code>array</code>指针将其值也就是<code>[]int</code>的地址拷贝了一份给<code>slice2</code>中的<code>array</code>指针，这就类似指针的赋值，所以对<code>slice2</code>的修改可以影响到<code>slice1</code>。<br>如果不想拷贝一份则可以使用指针传递，直接传递slice的指针，代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">slice1 := []<span class="keyword">int</span>&#123;<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>&#125;</span><br><span class="line">fmt.Println(slice1)</span><br><span class="line">modify(&amp;slice1)</span><br><span class="line">fmt.Println(slice1) <span class="comment">// 输出1,6,6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(slice1 *[]<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">fmt.Println(*slice1)</span><br><span class="line">(*slice1)[<span class="number">0</span>] =<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后记住关键的一句话<strong>golang只有值传递</strong>。</p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><blockquote><p>Timer</p></blockquote><p>Timer是一个定时器，在cache2go中用来定时检查缓存中对象的过期时间。在golang中有两种定时器，分别为<code>Timer</code>和<code>Ticker</code>。<code>Timer</code>只触发一次，如果还需继续触发需要使用Reset进行重置，而<code>Ticker</code>是间隔特定时间触发。</p><p>Timer可以通过<code>NewTimer</code>创建或者使用<code>AfterFunc</code>创建。使用<code>NewTimer</code>创建时，当Timer到期时，会将当时的时间发送给channel。<br>Timer类型定义如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Timer <span class="keyword">struct</span> &#123;</span><br><span class="line">    C &lt;-<span class="keyword">chan</span> Time     <span class="comment">// The channel on which the time is delivered.</span></span><br><span class="line">    r runtimeTimer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的C就是上文中，说的会将当前时间发送的channel，<code>NewTimer</code>创建Timer的demo如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer := time.NewTimer(time.Second * <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>这种形式创建的Timer，使用时需要监听channel C中的信号，使用demo如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d := time.Duration(time.Second*<span class="number">2</span>)</span><br><span class="line">    t := time.NewTimer(d)</span><br><span class="line">    <span class="keyword">defer</span> t.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 等待channel C中的信号</span></span><br><span class="line">        &lt;- t.C</span><br><span class="line"></span><br><span class="line">        fmt.Println(<span class="string">&quot;do someting...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置定时器，因为Timer是一次触发</span></span><br><span class="line"><span class="comment">// Reset 会先调用 stopTimer 再调用 startTimer，类似于废弃之前的定时器，重新启动一个定时器</span></span><br><span class="line">t.Reset(time.Second*<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cache2go中并没有使用这种方式创建Timer，而是使用了<code>AfterFunc</code>，代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">table.cleanupTimer = time.AfterFunc(smallestDuration, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> table.expirationCheck()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>AfterFunc传入两个参数，第一个是时间参数，间隔多久触发，第二个是执行逻辑，使用一个函数作为参数。当Timer经过smallestDuration长时间之后，会执行协程<code>table.expirationCheck()</code>，这个也是一次触发，所以每次都需要通过<code>AfterFunc</code>再次创建一个Timer。</p><p>另一个定时器是Ticker，是周期性的触发，需要注意的是除非程序终止否则定时器会一直触发，停止时应该调用<code>Ticker.Stop</code>来释放相关资源。Ticker使用<code>NewTicker</code>创建，demo如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := time.NewTicker(<span class="number">2</span>*time.Second)</span><br><span class="line">    <span class="keyword">defer</span> t.Stop()</span><br><span class="line"></span><br><span class="line">    fmt.Println(time.Now())</span><br><span class="line">    time.Sleep(<span class="number">5</span>*time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">            fmt.Println(time.Now())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- 需要注意的是golang timer定时器是不能stop停止的，只能在逻辑上通过标示位来退出定时任务， 为什么？？？？ --><blockquote><p>go协程</p></blockquote><p>go关键字表示协程goroutine，是Go语言中的轻量级线程实现，由Go运行时(runtime)管理。</p><p>协程是对线程的一种补充，线程是由系统内核管理的，<strong>线程之间的切换会触发用户态到内核态的切换</strong>，此时需要保存一些上下文信息，比较消耗资源，而且线程太多也会达到线程上限的瓶颈。<br>而协程完全是由程序所控制(也就是在用户态执行，所以也叫<strong>用户态线程</strong>)，是在应用层模拟线程，因此避免了用户态和内核态的频繁切换。<br>程序最终是要由CPU及相关存储器进行执行，而协程在用户态执行，不由系统内核调度，那么他是如何调度到CPU的？在golang中，协程是基于线程的，并且实现了一个逻辑流调度(也就是协程调度器)，可以像调度线程那样在用户态也能根据代码的执行状态进行调度协程，<em>更充分的利用并发的优势，又避免反复系统调用，还有进程切换造成的开销</em>。</p><p>更通俗的说<em>协程是子函数的一个特例</em>，在线程中函数之间的调用只需要将各自的执行状态压入栈中即可，所以协程切换时也是压栈操作，比较轻量。</p><p>了解过协程之后，发现协程确实是个好东西，更好的是golang从编译器和语言基础库多个层面对协程做了实现，例如golang对各种io函数进行了封装，内部调用操作系统的异步io函数，根据这些函数返回的状态将现有的执行序列压栈，让线程去拉另一个协程执行，是目前各类有协程概念的语言中实现的最完整和成熟的，最重要的是使用起来很方便，只需在普通函数之前添加<code>go</code>关键字即可，使开发者更多的关注业务逻辑的实现，更少的在这些关键的基础构件上耗费太多精力。</p><p>cache2go中只有一处使用了协程，代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">expirationCheck</span><span class="params">()</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">table.cleanupTimer = time.AfterFunc(smallestDuration, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> table.expirationCheck()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>go</code>关键字加普通函数代表协程，不同于函数调用，不会等待调用函数结束，而是继续执行剩下的代码片段，被调用的函数会在适当的时间被调度。<em>需要注意的是，如果这个函数有返回值，那么这个 返回值会被丢弃。</em></p><!--协程就是在用户程序中实现了协作式任务调度(当任务得一个到了 CPU 时间，除非它自己放弃使用 CPU ，否则将完全霸占 CPU)并发 一个时间段内，多个任务交替执行并行 同一时刻，多个任务同时执行协程的优势：最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。协程也可以在多个线程之间切换，--><!--> 函数 func(key interface{}, args ...interface{})   可变参数长度函数变量>test golang字符串，byte数组 byte区别## 语法技巧匿名函数匿名属性函数参数res.Data().(*myStruct).text 这是什么用法，强制转换类型？ 接口类型强制转换声明多个变量可以缩写，用小括号括起来<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">cache = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*CacheTable)</span><br><span class="line">mutex sync.RWMutex</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>map 接口<br>t, ok := cache[table] 判断是否有值</p><p>RLock与Lock的区别<br>sync.WaitGroup<br>–&gt;</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://bigdatadecode.top/golang-cache2go-src.html&quot;&gt;上篇&lt;/a&gt;介绍了cache2go的代码逻辑，梳理代码逻辑时也能从中了解golang的一些语法以及使用技巧，本篇集中将源码中涉及到的知识点梳理下。&lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://yuanba.tech/categories/golang/"/>
    
    
    <category term="go" scheme="http://yuanba.tech/tags/go/"/>
    
    <category term="golang" scheme="http://yuanba.tech/tags/golang/"/>
    
    <category term="cache2go" scheme="http://yuanba.tech/tags/cache2go/"/>
    
    <category term="源码" scheme="http://yuanba.tech/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>golang随波逐流之cache2go源码解读</title>
    <link href="http://yuanba.tech/golang-cache2go-src.html"/>
    <id>http://yuanba.tech/golang-cache2go-src.html</id>
    <published>2020-03-30T15:17:05.000Z</published>
    <updated>2020-04-13T16:00:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>想学习golang了，工作中又接触不到，基础语法一看全明白，真到用的时候却是瞪眼瞎，怎么办？<br>可以找简单的开源项目，看下源码，看看这些语法的常用方式，并且也可以自己尝试着去自己实现下。<br><a href="https://github.com/muesli/cache2go">cache2go</a>就是一个比较简单的项目，也是初学者必撸的项目了吧。<br>本篇是我梳理cache2go的学习笔记。</p><span id="more"></span><h2 id="cache2go概览"><a href="#cache2go概览" class="headerlink" title="cache2go概览"></a>cache2go概览</h2><p>cache2go是用Go实现的并发安全的缓存库，主要功能有：</p><ul><li>并发安全</li><li>缓存命中次数</li><li>缓存过期</li></ul><p>项目目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">xx/cache2go</span><br><span class="line">├── LICENSE.txt</span><br><span class="line">├── README.md</span><br><span class="line">├── benchmark_test.go</span><br><span class="line">├── cache.go</span><br><span class="line">├── cache_test.go</span><br><span class="line">├── cacheitem.go</span><br><span class="line">├── cachetable.go</span><br><span class="line">├── errors.go</span><br><span class="line">└── examples</span><br><span class="line">    ├── callbacks</span><br><span class="line">    │   └── callbacks.go</span><br><span class="line">    ├── dataloader</span><br><span class="line">    │   └── dataloader.go</span><br><span class="line">    └── mycachedapp</span><br><span class="line">        └── mycachedapp.go</span><br></pre></td></tr></table></figure><p>是不是很简单，功能代码一共也就四个文件，其中一个还是个error文件，里面只定义了两个error类型，其核心文件也就三个。<br>核心代码虽然不多，但是仔细读这三个文件，还是可以从中学习很多golang语法和知识点的，比如lock、goroutine、匿名函数等等。</p><h2 id="强撸灰飞烟灭"><a href="#强撸灰飞烟灭" class="headerlink" title="强撸灰飞烟灭"></a>强撸灰飞烟灭</h2><p>对于一个程序员来说，阅读代码是一项必备的技能，因为在工作中肯定会遇到开发维护遗留项目的情况。<br>那么如何快速高效的阅读代码呢？俗话说强撸灰飞烟灭，所以肯定不能上来就一顿操作猛如虎。<br>针对不同开发人员开发的项目以及不同类型的项目需要有不同的方法，这里谈下我个人的几点看法：<br>1、公司内部项目可结合口头流传或者wiki以及项目本身的技术框架，从某个功能点进行切入<br>2、开源项目普遍有较为完善的文档和单元测试或者examples，可以从文档入手了解功能及使用方式，然后以单元测试或者examples作为代码的切入点。</p><p>cache2go是一个开源项目，里面有测试相关的代码，也有examples，所以先从examples代码入手。<br>examples中有三个文件，分别为mycachedapp.go、dataloader.go和callbacks.go，看名字应该先看mycachedapp.go这个文件，它应该是缓存的使用方式。</p><p>mycachedapp.go文件中介绍了cache的读写和删等常用操作，解析下关键代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实力化一个缓存cache，名字为myCahe</span></span><br><span class="line">cache := cache2go.Cache(<span class="string">&quot;myCache&quot;</span>)</span><br><span class="line"><span class="comment">// 向缓存中加入元素，kv格式，第二个参数时key的过期时间，0代表用不过期</span></span><br><span class="line">cache.Add(<span class="string">&quot;someKey&quot;</span>, <span class="number">5</span>*time.Second, &amp;val)</span><br><span class="line"><span class="comment">// 缓存中读取key对应的值</span></span><br><span class="line">res, err := cache.Value(<span class="string">&quot;someKey&quot;</span>)</span><br><span class="line"><span class="comment">// 设置删除某个key时的回调函数</span></span><br><span class="line">cache.SetAboutToDeleteItemCallback(<span class="function"><span class="keyword">func</span><span class="params">(e *cache2go.CacheItem)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Deleting:&quot;</span>, e.Key(), e.Data().(*myStruct).text, e.CreatedOn())</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 从缓存中删除某个key</span></span><br><span class="line">cache.Delete(<span class="string">&quot;someKey&quot;</span>)</span><br><span class="line"><span class="comment">// 清空缓存</span></span><br><span class="line">cache.Flush()</span><br></pre></td></tr></table></figure><p>通读mycachedapp.go之后，了解了cache的基本用法，下面我们更深一步，去探寻他具体是如何实现的。</p><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>mycachedapp.go中调用<code>cache2go.Cache()</code>初始化了一个缓存实例，接着跟进这个方法看下具体的细节。此方法位于<code>cache.go</code>文件中，代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">cache = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*CacheTable)</span><br><span class="line">mutex sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Cache</span><span class="params">(table <span class="keyword">string</span>)</span> *<span class="title">CacheTable</span></span> &#123;</span><br><span class="line"><span class="comment">// RLock读锁，读锁之间可以共享，Lock需要等待Rlock释放才能得到锁</span></span><br><span class="line">mutex.RLock()</span><br><span class="line"><span class="comment">// 从map cache中获取table对应的值</span></span><br><span class="line">t, ok := cache[table]</span><br><span class="line">mutex.RUnlock()</span><br><span class="line">    <span class="comment">// ok为true代表有值，false代表无值</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="comment">// 互斥锁</span></span><br><span class="line">mutex.Lock()</span><br><span class="line">t, ok = cache[table]</span><br><span class="line"><span class="comment">// Double check whether the table exists or not.</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="comment">// 创建一个CacheTable对象</span></span><br><span class="line">t = &amp;CacheTable&#123;</span><br><span class="line">name:  table,</span><br><span class="line">items: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*CacheItem),</span><br><span class="line">&#125;</span><br><span class="line">cache[table] = t</span><br><span class="line">&#125;</span><br><span class="line">mutex.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cache.go</code>代码比较简单，先声明了两个全局变量，接着就是<code>Cache()</code>方法。该方法也比较简单，根据传入的参数table从map类型的cache中取出对应的值，有值则直接返回，无值则创建一个<code>CacheTable</code>类型的对象。这里使用了<code>Double check</code>机制来保证线程安全。</p><h2 id="CacheTable"><a href="#CacheTable" class="headerlink" title="CacheTable"></a>CacheTable</h2><p>关键点就在于<code>CacheTable</code>，接下来看下<code>CacheTable</code>的具体实现。</p><p><code>CacheTable</code>位于<code>cachetable.go</code>文件中，是一个结构体，代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CacheTable <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 匿名属性</span></span><br><span class="line">sync.RWMutex</span><br><span class="line"></span><br><span class="line"><span class="comment">// The table&#x27;s name.</span></span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line"><span class="comment">// All cached items.</span></span><br><span class="line">items <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*CacheItem</span><br><span class="line"></span><br><span class="line"><span class="comment">// Timer responsible for triggering cleanup.</span></span><br><span class="line">cleanupTimer *time.Timer</span><br><span class="line"><span class="comment">// 当前计时器持续时间</span></span><br><span class="line"><span class="comment">// Current timer duration.</span></span><br><span class="line">cleanupInterval time.Duration</span><br><span class="line"></span><br><span class="line"><span class="comment">// The logger used for this table.</span></span><br><span class="line">logger *log.Logger</span><br><span class="line"></span><br><span class="line"><span class="comment">// Callback method triggered when trying to load a non-existing key.</span></span><br><span class="line">loadData <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, args ...<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">CacheItem</span></span></span><br><span class="line"><span class="comment">// Callback method triggered when adding a new item to the cache.</span></span><br><span class="line"><span class="comment">// 触发回调函数，回调函数可以不止一个</span></span><br><span class="line">addedItem []<span class="function"><span class="keyword">func</span><span class="params">(item *CacheItem)</span></span></span><br><span class="line"><span class="comment">// Callback method triggered before deleting an item from the cache.</span></span><br><span class="line">aboutToDeleteItem []<span class="function"><span class="keyword">func</span><span class="params">(item *CacheItem)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CacheTable</code>的成员变量重点介绍下<code>items</code>、<code>cleanupTimer</code>和一些用于回调函数的函数变量，其中<code>items</code>是一个map，以key/value的形式存储具体的缓存数据；<code>cleanupTimer</code>是一个定时器，用于检查缓存对象的过期时间；剩下的<code>loadData、addedItem和aboutToDeleteItem</code>用于某些操作的回调函数。</p><p>接下来看下mycachedapp.go文件中对缓存使用相关的方法，增加缓存的方法Add，读取缓存中数据的方法Value和删除缓存中数据的方法Delete，这几个方法的首字母都是大写，代表方法是public。</p><blockquote><p>Add</p></blockquote><p>先看下Add方法，代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key是缓存对象的key，data是缓存对象的值，lifeSpan是对象的过期时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">Add</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, lifeSpan time.Duration, data <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">CacheItem</span></span> &#123;</span><br><span class="line"><span class="comment">// golang中的“构造函数”</span></span><br><span class="line">item := NewCacheItem(key, lifeSpan, data)</span><br><span class="line"><span class="comment">// 将item加入CacheTable中，这里涉及到多线程，所以需要加锁</span></span><br><span class="line"><span class="comment">// 锁的释放在addInternal方法中，是对锁粒度进行的优化</span></span><br><span class="line">table.Lock()</span><br><span class="line">table.addInternal(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Add方法会根据传入的参数调用<code>NewCacheItem</code>方法构建一个CacheItem对象，由于golang中的结构体并没有构造函数的概念，对于需要构造函数的场景，一般都会使用<code>NewStructName()</code>的方式声明一个方法，作为结构体的构造函数使用。NewCacheItem位于cacheitem.go中，会在下一节介绍。</p><p>item创建成功之后，需要将其加入到map类型的items中，以便于后续数据的读取。由于此操作涉及到读写操作，在多线程下需要保证线程安全，所以在调用<code>addInternal</code>方法之前先获取锁，但是释放锁并没有在<code>addInternal</code>方法执行结束再释放，而是在<code>addInternal</code>代码中对相应资源读写结束之后释放，这样做减少了持有锁的时间，提高了并行度。<code>addInternal</code>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">addInternal</span><span class="params">(item *CacheItem)</span></span> &#123;</span><br><span class="line"><span class="comment">// Careful: do not run this method unless the table-mutex is locked!</span></span><br><span class="line"><span class="comment">// It will unlock it for the caller before running the callbacks and checks</span></span><br><span class="line">table.log(<span class="string">&quot;Adding item with key&quot;</span>, item.key, <span class="string">&quot;and lifespan of&quot;</span>, item.lifeSpan, <span class="string">&quot;to table&quot;</span>, table.name)</span><br><span class="line"><span class="comment">// 将数据加入缓存中</span></span><br><span class="line">table.items[item.key] = item</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将值进行提前缓存，及时释放锁</span></span><br><span class="line">expDur := table.cleanupInterval</span><br><span class="line"><span class="comment">// 得到Add的回调函数列表</span></span><br><span class="line">addedItem := table.addedItem</span><br><span class="line"><span class="comment">// 未持有锁，而直接进行释放时，会报异常</span></span><br><span class="line">table.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trigger callback after adding an item to cache.</span></span><br><span class="line"><span class="keyword">if</span> addedItem != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, callback := <span class="keyword">range</span> addedItem &#123;</span><br><span class="line">callback(item)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we haven&#x27;t set up any expiration check timer or found a more imminent item.</span></span><br><span class="line"><span class="comment">// 如果item的过期时间小于下次检查的时间间隔，则触发过期检查，重置过期时间间隔</span></span><br><span class="line"><span class="keyword">if</span> item.lifeSpan &gt; <span class="number">0</span> &amp;&amp; (expDur == <span class="number">0</span> || item.lifeSpan &lt; expDur) &#123;</span><br><span class="line">table.expirationCheck()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addInternal</code>方法才会真正的将数据添加到缓存中，并且调用相应的回调函数，并且这里还会触发过期检查。<br>数据的过期检查使用了<code>Timer</code>的定时功能，但是细心的童鞋会发现<code>CacheTable</code>在创建的时候并没有给<code>Timer</code>进行赋值，<code>Timer</code>是通过第一个加入到缓存中的数据激活的。<br>这样好处是缓存初始化之后，在添加数据之前不用让<code>Timer</code>去定期执行一些无意义的操作，而且在每加入一个数据就触发过期检查更能更及时的调整进行过期检查的时间点，<strong>因为缓存中数据的过期时间不定，无法设置一个合理的定期时间去周期性的执行，而且遍历一遍所有数据找出最先过期的数据，将其剩余时间作为下次检查的时间间隔</strong>。<br><code>expirationCheck</code>方法代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">expirationCheck</span><span class="params">()</span></span> &#123;</span><br><span class="line">table.Lock()</span><br><span class="line"><span class="comment">// Timer定时功能的一种用法，结合下面对cleanupTimer的赋值方式即可理解</span></span><br><span class="line"><span class="keyword">if</span> table.cleanupTimer != <span class="literal">nil</span> &#123;</span><br><span class="line">table.cleanupTimer.Stop()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> table.cleanupInterval &gt; <span class="number">0</span> &#123;</span><br><span class="line">table.log(<span class="string">&quot;Expiration check triggered after&quot;</span>, table.cleanupInterval, <span class="string">&quot;for table&quot;</span>, table.name)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// cleanupInterval 为0时，代表没有定时去执行过期检查任务</span></span><br><span class="line">table.log(<span class="string">&quot;Expiration check installed for table&quot;</span>, table.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// To be more accurate with timers, we would need to update &#x27;now&#x27; on every</span></span><br><span class="line"><span class="comment">// loop iteration. Not sure it&#x27;s really efficient though.</span></span><br><span class="line">now := time.Now()</span><br><span class="line">smallestDuration := <span class="number">0</span> * time.Second</span><br><span class="line"><span class="comment">// 遍历缓存中的数据，找出最先过期的时间差</span></span><br><span class="line"><span class="keyword">for</span> key, item := <span class="keyword">range</span> table.items &#123;</span><br><span class="line"><span class="comment">// Cache values so we don&#x27;t keep blocking the mutex.</span></span><br><span class="line">item.RLock()</span><br><span class="line">lifeSpan := item.lifeSpan</span><br><span class="line">accessedOn := item.accessedOn</span><br><span class="line">item.RUnlock()</span><br><span class="line"><span class="comment">// lifeSpan为0，代表用不过期</span></span><br><span class="line"><span class="keyword">if</span> lifeSpan == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> now.Sub(accessedOn) &gt;= lifeSpan &#123;</span><br><span class="line"><span class="comment">// 过期的则删掉</span></span><br><span class="line">table.deleteInternal(key)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Find the item chronologically closest to its end-of-lifespan.</span></span><br><span class="line"><span class="comment">// 这个分支中 lifeSpan-now.Sub(accessedOn) 一定大于 0，如果小于0的话，会被if拦截</span></span><br><span class="line"><span class="keyword">if</span> smallestDuration == <span class="number">0</span> || lifeSpan-now.Sub(accessedOn) &lt; smallestDuration &#123;</span><br><span class="line">smallestDuration = lifeSpan - now.Sub(accessedOn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup the interval for the next cleanup run.</span></span><br><span class="line">table.cleanupInterval = smallestDuration</span><br><span class="line"><span class="comment">// smallestDuration &lt;= 0时，不再执行定时检查任务</span></span><br><span class="line"><span class="comment">// smallestDuration 只能等于或者大于0</span></span><br><span class="line"><span class="keyword">if</span> smallestDuration &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// smallestDuration大于0，则设置定时执行任务</span></span><br><span class="line">table.cleanupTimer = time.AfterFunc(smallestDuration, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 协程</span></span><br><span class="line"><span class="keyword">go</span> table.expirationCheck()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">table.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Add相关的代码就介绍到这里，下面看下Value</p><blockquote><p>Value</p></blockquote><p>Value方法代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*CacheItem, error)</span></span> &#123;</span><br><span class="line">table.RLock()</span><br><span class="line">r, ok := table.items[key]</span><br><span class="line"><span class="comment">// 缓存中没有命中时到回调函数</span></span><br><span class="line">loadData := table.loadData</span><br><span class="line">table.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="comment">// 缓存中有数据，调用CacheItem的KeepAlive更新访问时间和访问次数</span></span><br><span class="line">r.KeepAlive()</span><br><span class="line"><span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数不为null时，执行具体的回调函数，</span></span><br><span class="line"><span class="comment">// args参数是传递给回调函数的</span></span><br><span class="line"><span class="keyword">if</span> loadData != <span class="literal">nil</span> &#123;</span><br><span class="line">item := loadData(key, args...)</span><br><span class="line"><span class="keyword">if</span> item != <span class="literal">nil</span> &#123;</span><br><span class="line">table.Add(key, item.lifeSpan, item.data)</span><br><span class="line"><span class="keyword">return</span> item, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义错误类型</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrKeyNotFoundOrLoadable</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义错误类型</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrKeyNotFound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在mycachedapp.go中调用的Value方法是<code>cache.Value(&quot;someKey&quot;)</code>，而这里的Value函数却是传入两个参数，这里的第二个参数是可变长度的参数，长度可以为0，所以可以传如一个参数。</p><blockquote><p>Delete</p></blockquote><p>Delete方法代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*CacheItem, error)</span></span> &#123;</span><br><span class="line">table.Lock()</span><br><span class="line"><span class="comment">// 在方法执行完之后，执行Unlock</span></span><br><span class="line"><span class="keyword">defer</span> table.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> table.deleteInternal(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">deleteInternal</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*CacheItem, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// golang从map中取值避免null值的语法</span></span><br><span class="line">r, ok := table.items[key]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrKeyNotFound</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cache value so we don&#x27;t keep blocking the mutex.</span></span><br><span class="line"><span class="comment">// 删除数据时的回调函数</span></span><br><span class="line">aboutToDeleteItem := table.aboutToDeleteItem</span><br><span class="line">table.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trigger callbacks before deleting an item from cache.</span></span><br><span class="line"><span class="keyword">if</span> aboutToDeleteItem != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, callback := <span class="keyword">range</span> aboutToDeleteItem &#123;</span><br><span class="line">callback(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r.RLock()</span><br><span class="line"><span class="comment">// 这里的defer是在函数的最后执行RUnlock吧</span></span><br><span class="line"><span class="keyword">defer</span> r.RUnlock()</span><br><span class="line"><span class="comment">// 为什么两个回调函数</span></span><br><span class="line"><span class="keyword">if</span> r.aboutToExpire != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, callback := <span class="keyword">range</span> r.aboutToExpire &#123;</span><br><span class="line">callback(key)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">table.Lock()</span><br><span class="line">table.log(<span class="string">&quot;Deleting item with key&quot;</span>, key, <span class="string">&quot;created on&quot;</span>, r.createdOn, <span class="string">&quot;and hit&quot;</span>, r.accessCount, <span class="string">&quot;times from table&quot;</span>, table.name)</span><br><span class="line"><span class="comment">// map的系统函数进行数据删除</span></span><br><span class="line"><span class="built_in">delete</span>(table.items, key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Delete方法于Add类似，都是在其内部调用了另一个内部函数，具体的逻辑在其内部函数中，这里是<code>deleteInternal</code>方法。代码和语法都比较简单，就不过多展开了。<br>接下来看下如何清空缓存，方法是<code>Flush</code>。</p><blockquote><p>Flush</p></blockquote><p>Flush方法的代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">Flush</span><span class="params">()</span></span> &#123;</span><br><span class="line">table.Lock()</span><br><span class="line"><span class="keyword">defer</span> table.Unlock()</span><br><span class="line"></span><br><span class="line">table.log(<span class="string">&quot;Flushing table&quot;</span>, table.name)</span><br><span class="line"><span class="comment">// 直接将一个新的map赋值给items，老map等着自动回收</span></span><br><span class="line">table.items = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*CacheItem)</span><br><span class="line">table.cleanupInterval = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> table.cleanupTimer != <span class="literal">nil</span> &#123;</span><br><span class="line">table.cleanupTimer.Stop()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>介绍到这里，<code>cachetable.go</code>中的代码就几乎撸完了，不过还有个功能需要提下，就是统计缓存中访问次数最多的数据，方法名为<code>MostAccessed</code>，代码也比较简单，重点介绍下这个排序功能。<br>排序是先将缓存中的数据放入切片中，然后调用<code>sort.Sort</code>对切片进行排序，调用<code>sort.Sort</code>时，需要传入的集合是可比类型的，而且还可以重写比较器，类似java中的使用方式。<br>代码中先声明了一个<code>CacheItemPair</code>结构体，用来作为比较对象，只存储Key和访问次数关键信息，减少内存消耗，其次声明一个切片类型的<code>CacheItemPairList</code>，并实现了可比的相关函数，代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CacheItemPair <span class="keyword">struct</span> &#123;</span><br><span class="line">Key         <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">AccessCount <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CacheItemPairList []CacheItemPair</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p CacheItemPairList)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p CacheItemPairList)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p CacheItemPairList)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> p[i].AccessCount &gt; p[j].AccessCount &#125;</span><br></pre></td></tr></table></figure><p>至此，<code>cachetable.go</code>的相关代码就算介绍完了，剩下的就是些回调函数的设置以及一些常规用法，比较简单。<br>了解了<code>cachetable.go</code>相关代码之后，缓存的内存结构其实也就清楚了，也就对整个缓存的架构有了初步的了解，就感觉其实很简单，其内存结构图如下：<br><img src="/blogimgs/cache2go-src/cache2go.png" alt="cache2go内存结构" title="cache2go内存结构"></p><h2 id="CacheItem"><a href="#CacheItem" class="headerlink" title="CacheItem"></a>CacheItem</h2><p>CacheTable了解之后，再来看下CacheItem，在读CacheTable相关代码的时候其实已经涉及到一些CacheItem相关的代码，从中可以看出CacheItem代码并不复杂，比较简单易懂。</p><p>CacheItem相关的属性如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CacheItem <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 匿名变量</span></span><br><span class="line">sync.RWMutex</span><br><span class="line"></span><br><span class="line"><span class="comment">// The item&#x27;s key.</span></span><br><span class="line">key <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="comment">// The item&#x27;s data.</span></span><br><span class="line">data <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="comment">// How long will the item live in the cache when not being accessed/kept alive.</span></span><br><span class="line">lifeSpan time.Duration</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creation timestamp.</span></span><br><span class="line">createdOn time.Time</span><br><span class="line"><span class="comment">// Last access timestamp.</span></span><br><span class="line">accessedOn time.Time</span><br><span class="line"><span class="comment">// How often the item was accessed.</span></span><br><span class="line">accessCount <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Callback method triggered right before removing the item from the cache</span></span><br><span class="line">aboutToExpire []<span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在golang中，针对结构体并没有对行的<strong>构造函数</strong>，但是对于习惯使用构造函数的人来说该怎么办呢？于是有了一种约定俗成的语法，那就是将函数命名为<code>NewXXX</code>形式，以此表示该结构体的构造函数，cacheitem.go中就用到了这种命名方式，代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCacheItem</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, lifeSpan time.Duration, data <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">CacheItem</span></span> &#123;</span><br><span class="line">t := time.Now()</span><br><span class="line"><span class="keyword">return</span> &amp;CacheItem&#123;</span><br><span class="line">key:           key,</span><br><span class="line">lifeSpan:      lifeSpan,</span><br><span class="line">createdOn:     t,</span><br><span class="line">accessedOn:    t,</span><br><span class="line">accessCount:   <span class="number">0</span>,</span><br><span class="line">aboutToExpire: <span class="literal">nil</span>,</span><br><span class="line">data:          data,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码看到这里应该对cache2go整个源码都已了解了，而且对golang也有了进一步的理解吧，只是其中还有很多语法以及用法不太熟悉，随后多看多写就OK了，下一篇我会根据这个项目中涉及到的知识点进行梳理扩展。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;想学习golang了，工作中又接触不到，基础语法一看全明白，真到用的时候却是瞪眼瞎，怎么办？&lt;br&gt;可以找简单的开源项目，看下源码，看看这些语法的常用方式，并且也可以自己尝试着去自己实现下。&lt;br&gt;&lt;a href=&quot;https://github.com/muesli/cache2go&quot;&gt;cache2go&lt;/a&gt;就是一个比较简单的项目，也是初学者必撸的项目了吧。&lt;br&gt;本篇是我梳理cache2go的学习笔记。&lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://yuanba.tech/categories/golang/"/>
    
    
    <category term="go" scheme="http://yuanba.tech/tags/go/"/>
    
    <category term="golang" scheme="http://yuanba.tech/tags/golang/"/>
    
    <category term="cache2go" scheme="http://yuanba.tech/tags/cache2go/"/>
    
    <category term="源码" scheme="http://yuanba.tech/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Flink window解密</title>
    <link href="http://yuanba.tech/Flink-Window-Decode.html"/>
    <id>http://yuanba.tech/Flink-Window-Decode.html</id>
    <published>2019-12-05T13:52:53.000Z</published>
    <updated>2019-12-10T15:52:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>近几年流处理简直火的一塌糊涂，Flink也在阿里的推广下逐渐成为业界主流，正在逐步取代Storm和Spark Streaming。<br>Flink天生就是为了处理流，而且相对于其他流处理框架集成了很多实用功能，比如状态管理；Flink还丰富了window的功能，使window也成为了Flink的一个特色。<br>本篇主要对window从多种角度进行解密，主要包括：</p><ul><li>何为window</li><li>如何使用</li><li>如何实现</li><li>各组件原理</li></ul><blockquote><p>在解密window之前，简单介绍下何为流处理？</p></blockquote><span id="more"></span><p>流是指一种源源不断的形态，流处理是一种被设计来处理无界数据集的数据处理系统引擎，无界的数据集是指没有边界，数量上是无穷的一类数据集。<br>Flink将流处理总结为四个单词： what where when how</p><ul><li><p>what – What results are calculated(计算的结果是什么)</p></li><li><p>where – Where in event time are results calculated(在事件时间中的哪个位置计算结果)</p></li><li><p>when – When in processing time are results materialized(在处理时间中的哪个时刻触发计算结果)</p></li><li><p>how – How do refinements of results relate(如何修正结果)</p></li></ul><!-- 为什么Flink天生就是用来处理流的？？？？ window不也相当于一个微批吗？ --><blockquote><p>既然流处理有这么多的问题需要解决，那么为什么还要进行流计算？</p></blockquote><ol><li>在商业竞争中极度渴望更快的数据，而转换成流计算则是一个好的方法来降低延迟。</li><li>海量的、无穷数据集在现在的商业环境里变的越来越常见，而用专门设计来处理这样数据的系统来应对这些数据则更为容易。</li><li>在数据到达时就对他们进行处理能够更加平均地把负载进行均衡，取得更好的一致性和更可预测的计算资源消耗。</li></ol><!--流数据，when where what how 特点 无界    计算的结果是什么（What results are calculated）？ 通过transformations操作 transformations是以一个或多个stream作为输入的某种operation  数据集之间的转换    在事件时间中的哪个位置计算结果（Where in event time are results calculated）？ 使用窗口（windowing）的概念    在处理时间中的哪个时刻触发计算结果（When in processing time are results materialized）？ 使用triggers + watermarks进行触发计算    如何修正结果（How do refinements of results relate）？通过accumulation的类型修正结果数据--><h2 id="何为window"><a href="#何为window" class="headerlink" title="何为window"></a>何为window</h2><p>window回答了where这个问题，因为在流处理应用中，数据是连续不断的，我们不可能等到所有数据都到了才开始处理，况且我们也无法判断所有的数据何时能完整到来。而且在实际的环境中也需要做一些聚合计算，例如计算过去5分钟某个页面的UV，这就必须定义一个窗口，用来收集并计算这5分钟内的数据。所以window很好的回答了where这个问题，他决定了数据在哪里被计算。</p><p>window是无限流上一种核心机制，其按照时间边界对数据源进行切分，切分方式分为固定窗口、滑动窗口和会话窗口三种，同时，在可以在窗口内进行聚合，从而把源源不断产生的数据根据不同的条件划分成一段一段有边界的数据区间，使用户能够利用窗口功能实现很多复杂的统计分析需求。具体实现时，窗口又可以是严格按照时间来驱动，例如TimeWindow；也可以由数据驱动，例如CountWindow。切分方式如图<br><img src="/blogimgs/flink-window/windowing-chop.jpg" alt="window切分方式" title="window切分方式"></p><blockquote><p>固定窗口(Fixed windows)</p></blockquote><p>固定窗口按照固定的长度进行分片，这个固定的长度可以时间维度也可以是数据维度。如上图中红色的划分方式，这个固定的长度可以是每1分钟也可以是每100个元素。<br>固定窗口典型地会对所有的数据集进行等份划分，也叫对齐窗口。在某些情形下，可能会希望对不同的数据子集应用不同的相位偏移，从而能让分片的完整度更加的平均。这时就不再是对齐窗口，而是非对齐窗口。</p><blockquote><p>滑动窗口(Sliding windows)</p></blockquote><p>滑动窗口是固定窗口的一个更一般化的形式，滑动窗口一般会定义两个属性，即窗口大小（时间长短）和滑动时间。<strong>如果滑动时间比窗口要小，则窗口会重叠；如果相等，这就是固定窗口；如果滑动时间比窗口大，就产生了一种特殊的数据采样，也就是按时间只看数据集里的一部分子集的数据。</strong>类似于固定窗口，滑动窗口一般也是对齐的。出于性能考虑也会在某些情况下是非对齐的。需要注意的是，上图中蓝色部分为了能表明滑动的性质而没有把每个窗口对应到所有的键。实际情况里是都要对应到的。</p><blockquote><p>会话窗口(Sessions)</p></blockquote><p>会话是指在不活跃时间段之间的一连串事件，这个不活跃时间一般是设定的比超时的时间要长，会话窗口是一种动态窗口。<strong>会话单元一般用来做用户行为分析</strong>，即观察在一个会话单元里用户的一系列事件。会话单元的长度一般都没法提前确定，完全取决于实际数据的情况。会话单元也是非对齐窗口的一个经典案例，因为实际情况下，不同子集数据的会话单元长度几乎不可能一致地对齐。</p><p>一般而言，window是在无限的流上定义了一个有限的元素集合。这个集合可以是基于时间的，元素个数的，时间和个数结合的，会话间隙的，或者是自定义的。Flink提供了简洁的算子来满足常用的窗口操作，同时提供了通用的窗口机制来允许用户自己定义窗口分配逻辑。下面看下Flink内置的窗口。</p><h2 id="Flink提供的内置窗口使用及其实现"><a href="#Flink提供的内置窗口使用及其实现" class="headerlink" title="Flink提供的内置窗口使用及其实现"></a>Flink提供的内置窗口使用及其实现</h2><p>Flink将窗口的切分规则分为3种，3种切分规则Flink都有对应内置窗口实现，内置窗口包括滚动时间窗口、滑动时间窗口、滚动计数窗口、滑动计数窗口和会话窗口。这里为了方便将内置窗口分为3类进行介绍，依次为计数窗口countWindow、时间窗口timeWindow和会话窗口sessionWindow。</p><ul><li>计数窗口<br>计数窗口是根据元素个数对数据流进行分组的，分为滚动计数窗口和滑动计数窗口。使用计数窗口时先将DataStream转换为KeyedStream，然后通过调用countWindow函数进行使用。</li></ul><p>例如需要统计每100个订单中的总数，则使用滚动计数窗口，每100个元素滚动一次，代码实现为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream of (userId, buyCnts)</span></span><br><span class="line"><span class="keyword">val</span> buyCnts: <span class="type">DataStream</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> tumblingCnts: <span class="type">DataStream</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = buyCnts</span><br><span class="line">  .keyBy(<span class="number">0</span>)</span><br><span class="line">  <span class="comment">// 滚动计数窗口，每100个元素滚动一次</span></span><br><span class="line">  .countWindow(<span class="number">100</span>)</span><br><span class="line">  .sum(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>与滚动计数窗口相对的是滑动计数窗口，如果要计算每10个元素计算一次最近100个元素的总和，使用滑动窗口，窗口大小为100，每10个元素滑动一次，代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> slidingCnts: <span class="type">DataStream</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = vehicleCnts</span><br><span class="line">  .keyBy(<span class="number">0</span>)</span><br><span class="line">  <span class="comment">// 滑动计数窗口，窗口大小为100，每10个滑动一次</span></span><br><span class="line">  .countWindow(<span class="number">100</span>, <span class="number">10</span>)</span><br><span class="line">  .sum(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>使用方式很简单，这里看下countWindow的具体是如何实现的，两个countWindow函数代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动计数窗口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowedStream&lt;T, KEY, GlobalWindow&gt; <span class="title">countWindow</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> window(GlobalWindows.create()).trigger(PurgingTrigger.of(CountTrigger.of(size)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滑动计数窗口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowedStream&lt;T, KEY, GlobalWindow&gt; <span class="title">countWindow</span><span class="params">(<span class="keyword">long</span> size, <span class="keyword">long</span> slide)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> window(GlobalWindows.create())</span><br><span class="line">            .evictor(CountEvictor.of(size))</span><br><span class="line">            .trigger(CountTrigger.of(slide));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由countWindow的实现可以看出window丰富的功能是由一些关键组件组合实现的，这些组件包括evictor和trigger。两者使用的窗口分配器都是<code>GlobalWindows</code>，两者的区别是trigger，因为GlobalWindows的默认trigger是<code>NeverTrigger</code>，意思是不触发窗口计算。滚动窗口的trigger是将<code>CountTrigger</code>封装成<code>PurgingTrigger</code>，根据窗口分配的元素个数进行触发计算，并且在计算之后清除窗口中的数据，从而达到滚动窗口的效果。滑动窗口的trigger只是一个单纯的<code>CountTrigger</code>，根据滑动元素的个数进行计算，由于countWindow使用的是GlobalWindows，只有一共全局窗口，trigger触发计算时又只是单纯的计算结果，并未像滚动窗口那样清除数据，所以滑动窗口中的数据会越来越多，不仅性能上会受影响，而且数据也可能会被重复计算，这里增加了evictor对数据进行过滤。</p><!-- 计数窗口无论是滚动还是滑动窗口，都只有一个窗口，是一个全局窗口，不像时间窗口那样，一个元素可以归属多个窗口 --><ul><li>时间窗口<br>时间窗口是根据时间对数据流进行分组对，也分为滚动时间窗口和滑动时间窗口。时间窗口按照时间划分，这个时间在Flink中有三种概念，分别是event time(事件时间：事件发生时的时间)，ingestion time(摄取时间：事件进入流处理系统的时间)，processing time(处理时间：消息被计算处理的时间)。<strong>注：Flink 中窗口机制和时间类型是完全解耦的，也就是说当需要改变时间类型时不需要更改窗口逻辑相关的代码。</strong></li></ul><p>例如我们需要统计每一分钟中用户购买的商品的总数，需要将用户的行为事件按每一分钟进行切分汇总，这种切分被称为滚动时间窗口，代码如下:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream of (userId, buyCnt)</span></span><br><span class="line"><span class="keyword">val</span> buyCnts: <span class="type">DataStream</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = ...</span><br><span class="line"><span class="comment">// 将DataStream转换为KeyedStream，然后再使用窗口函数</span></span><br><span class="line"><span class="keyword">val</span> tumblingCnts: <span class="type">DataStream</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = buyCnts</span><br><span class="line">  .keyBy(<span class="number">0</span>) </span><br><span class="line">  <span class="comment">// 窗口长度为1分钟的滚动时间窗口</span></span><br><span class="line">  .timeWindow(<span class="type">Time</span>.minutes(<span class="number">1</span>))</span><br><span class="line">  .sum(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>窗口计算时，可以选择窗口切分时使用的时间方式，默认使用的是processtime，使用<code>env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)</code>对时间方式进行更改。</p><p>时间窗口的另一种方式是滑动时间窗口，主要用于平滑地进行窗口聚合计算。如果，需要每分钟统计下最近5分钟用户购买的商品总数，就可以使用滑动时间窗口进行计算，代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> slidingCnts: <span class="type">DataStream</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = buyCnts</span><br><span class="line">  .keyBy(<span class="number">0</span>) </span><br><span class="line">  <span class="comment">// 窗口长度为5分钟，每1分钟滑动一次</span></span><br><span class="line">  .timeWindow(<span class="type">Time</span>.minutes(<span class="number">5</span>), <span class="type">Time</span>.minutes(<span class="number">1</span>))</span><br><span class="line">  .sum(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>时间窗口使用时依然很简单方便，将DataStream流转换为KeyedStream流，调用<code>timeWindow</code>进行使用，传入一个参数代表滚动时间窗口，传入两个参数时代表滑动时间窗口，其中第一个参数代表窗口的长度，第二个参数代表滑动的长度。其具体的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动时间窗口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowedStream&lt;T, KEY, TimeWindow&gt; <span class="title">timeWindow</span><span class="params">(Time size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (environment.getStreamTimeCharacteristic() == TimeCharacteristic.ProcessingTime) &#123;</span><br><span class="line">        <span class="keyword">return</span> window(TumblingProcessingTimeWindows.of(size));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> window(TumblingEventTimeWindows.of(size));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滑动时间窗口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowedStream&lt;T, KEY, TimeWindow&gt; <span class="title">timeWindow</span><span class="params">(Time size, Time slide)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (environment.getStreamTimeCharacteristic() == TimeCharacteristic.ProcessingTime) &#123;</span><br><span class="line">        <span class="keyword">return</span> window(SlidingProcessingTimeWindows.of(size, slide));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> window(SlidingEventTimeWindows.of(size, slide));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>时间窗口的实现比计数窗口较复杂，每种窗口类型根据不同的时间设置都有专门的实现，滚动窗口的实现是<code>TumblingProcessingTimeWindows</code>和<code>TumblingEventTimeWindows</code>，而滑动窗口的实现是<code>SlidingProcessingTimeWindows</code>和<code>SlidingEventTimeWindows</code>。<code>TumblingProcessingTimeWindows</code>和<code>TumblingEventTimeWindows</code>的实现逻辑一样，都是根据元素的时间指定一个时间窗口<code>TimeWindow</code>，每个元素只能属于一个窗口，不同点只是触发计算的trigger，根据设置的时间策略指定相应的trigger，其中<code>TumblingProcessingTimeWindows</code>的trigger是<code>ProcessingTimeTrigger</code>，<code>TumblingEventTimeWindows</code>的trigger是<code>EventTimeTrigger</code>。<code>SlidingProcessingTimeWindows</code>和<code>SlidingEventTimeWindows</code>划分窗口的逻辑跟<code>TumblingProcessingTimeWindows</code>和<code>TumblingEventTimeWindows</code>一样，只是滑动窗口中一个元素可以归属多个窗口，所以返回的是一个窗口集合，至于触发器trigger和滚动窗口中的一样。</p><ul><li>会话窗口<br>此处的会话类似浏览页面时所指的会话，会话窗口并没有固定时间长度，而是根据事件之间的时间间隔来决定的，如果两个事件之间的时间间隔超过阈值，则被划分到不同的窗口中。例如，需要计算每个用户在活跃期间总共购买的商品数量，由于每个用户的活跃时长不固定，不能统一设置窗口时长，所以此时应该使用会话窗口，代码如下：</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream of (userId, buyCnts)</span></span><br><span class="line"><span class="keyword">val</span> buyCnts: <span class="type">DataStream</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sessionCnts: <span class="type">DataStream</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = vehicleCnts</span><br><span class="line">  .keyBy(<span class="number">0</span>)</span><br><span class="line">  <span class="comment">// 事件之间超过30秒则划分新窗口</span></span><br><span class="line">  .window(<span class="type">ProcessingTimeSessionWindows</span>.withGap(<span class="type">Time</span>.seconds(<span class="number">30</span>)))</span><br><span class="line">  .sum(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>使用会话窗口调用<code>KeydeStream.window</code>方法，同样此方法也在<code>countWindow</code>和<code>timeWindow</code>中被调用，并没有为会话窗口封装单独的函数，使用时传入对应时间的会话窗口分配器即可。</p><!--滚动窗口其实是滑动窗口的一种特殊情况--><!--全天UV日增UV过滤每5分钟未下单的订单    滚动窗口--><h2 id="窗口进阶"><a href="#窗口进阶" class="headerlink" title="窗口进阶"></a>窗口进阶</h2><p>内置窗口使用比较简单，<code>WindowedStream</code>也提供了一些简单的计算函数，但是如果自定义一些计算逻辑时就用到了窗口函数。<br>窗口函数分为ReduceFunction、AggregateFunction、FoldFunction和ProcessWindowFunction。前两个是增量聚合函数，性能比较高效；ProcessWindowFunction中会包含一个迭代器，这个迭代器中记录了窗口中的所有元素，除此之外还包含一些窗口的元信息。接下来看下每个窗口函数具体怎么用。</p><ul><li>ReduceFunction<br>将输入的两个元素进行计算，得到一个相同类型的元素做为输出。此函数是增量的对窗口中的元素进行计算，类似于MR中Reduce。具体使用代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(&lt;window assigner&gt;)</span><br><span class="line">    .reduce(<span class="keyword">new</span> ReduceFunction&lt;Tuple2&lt;String, Long&gt;&gt; &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Long&gt; <span class="title">reduce</span><span class="params">(Tuple2&lt;String, Long&gt; v1, Tuple2&lt;String, Long&gt; v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(v1.f0, v1.f1 + v2.f1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><ul><li>AggregateFunction<br>AggregateFunction也是一个增量聚合窗口函数，比ReduceFunction更加通用，包含三个参数，第一个是窗口流中输入的元素，第二个是累加器，第三个元素是计算之后的输出，累加器和输出结果的类型都可以自定义。使用样例如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AverageAggregate</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">AggregateFunction</span>&lt;<span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Long</span>&gt;, <span class="title">Tuple2</span>&lt;<span class="title">Long</span>, <span class="title">Long</span>&gt;, <span class="title">Double</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title">createAccumulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(<span class="number">0L</span>, <span class="number">0L</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title">add</span><span class="params">(Tuple2&lt;String, Long&gt; value, Tuple2&lt;Long, Long&gt; accumulator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(accumulator.f0 + value.f1, accumulator.f1 + <span class="number">1L</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Double <span class="title">getResult</span><span class="params">(Tuple2&lt;Long, Long&gt; accumulator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">double</span>) accumulator.f0) / accumulator.f1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title">merge</span><span class="params">(Tuple2&lt;Long, Long&gt; a, Tuple2&lt;Long, Long&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(a.f0 + b.f0, a.f1 + b.f1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(&lt;window assigner&gt;)</span><br><span class="line">    .aggregate(<span class="keyword">new</span> AverageAggregate());</span><br></pre></td></tr></table></figure><ul><li>FoldFunction<br>窗口中的元素与累加器进行计算，此时累加器有初始值，并且输出的结果类型和累加器相同。此窗口函数不能用在合并窗口中，比如会话窗口。使用样例代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(&lt;window assigner&gt;)</span><br><span class="line">    .fold(<span class="string">&quot;&quot;</span>, <span class="keyword">new</span> FoldFunction&lt;Tuple2&lt;String, Long&gt;, String&gt;&gt; &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">fold</span><span class="params">(String acc, Tuple2&lt;String, Long&gt; value)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> acc + value.f1;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><ul><li>ProcessWindowFunction<br>ProcessWindowFunction最灵活，包含的信息也较多，可以对整个窗口中的元素进行迭代计算，还可以访问窗口的一些元信息。但是单纯使用ProcessWindowFunction时，由于要缓存窗口中的所有元素，所以会消耗一些资源。使用样例代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">  .keyBy(t -&gt; t.f0)</span><br><span class="line">  .timeWindow(Time.minutes(<span class="number">5</span>))</span><br><span class="line">  .process(<span class="keyword">new</span> MyProcessWindowFunction());</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProcessWindowFunction</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Long</span>&gt;, <span class="title">String</span>, <span class="title">String</span>, <span class="title">TimeWindow</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String key, Context context, Iterable&lt;Tuple2&lt;String, Long&gt;&gt; input, Collector&lt;String&gt; out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Tuple2&lt;String, Long&gt; in: input) &#123;</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">    out.collect(<span class="string">&quot;Window: &quot;</span> + context.window() + <span class="string">&quot;count: &quot;</span> + count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProcessWindowFunction中记录的窗口信息在抽象类Context中，ProcessWindowFunction抽象类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">IN</span>, <span class="title">OUT</span>, <span class="title">KEY</span>, <span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window</span>&gt; <span class="keyword">implements</span> <span class="title">Function</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            KEY key,</span></span></span><br><span class="line"><span class="params"><span class="function">            Context context,</span></span></span><br><span class="line"><span class="params"><span class="function">            Iterable&lt;IN&gt; elements,</span></span></span><br><span class="line"><span class="params"><span class="function">            Collector&lt;OUT&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The context holding window metadata.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * Returns the window that is being evaluated.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> W <span class="title">window</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/** Returns the current processing time. */</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">currentProcessingTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/** Returns the current event-time watermark. */</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">currentWatermark</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * State accessor for per-key and per-window state.</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt;If you use per-window state you have to ensure that you clean it up</span></span><br><span class="line"><span class="comment">            * by implementing &#123;<span class="doctag">@link</span> ProcessWindowFunction#clear(Context)&#125;.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> KeyedStateStore <span class="title">windowState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * State accessor for per-key global state.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> KeyedStateStore <span class="title">globalState</span><span class="params">()</span></span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然ProcessWindowFunction比较耗资源，但是在有些场景下他可以和之前介绍的增量聚合窗口函数一起使用，这样不仅可以将元素进行增量聚合减少资源消耗，也可以访问ProcessWindowFunction中记录的窗口元信息。下面的例子是ReduceFunction和ProcessWindowFunction结合使用的，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;SensorReading&gt; input = ...;</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">  .keyBy(&lt;key selector&gt;)</span><br><span class="line">  .timeWindow(&lt;duration&gt;)</span><br><span class="line">  .reduce(<span class="keyword">new</span> MyReduceFunction(), <span class="keyword">new</span> MyProcessWindowFunction());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function definitions</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReduceFunction</span> <span class="keyword">implements</span> <span class="title">ReduceFunction</span>&lt;<span class="title">SensorReading</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SensorReading <span class="title">reduce</span><span class="params">(SensorReading r1, SensorReading r2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> r1.value() &gt; r2.value() ? r2 : r1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProcessWindowFunction</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">SensorReading</span>, <span class="title">Tuple2</span>&lt;<span class="title">Long</span>, <span class="title">SensorReading</span>&gt;, <span class="title">String</span>, <span class="title">TimeWindow</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String key,</span></span></span><br><span class="line"><span class="params"><span class="function">                    Context context,</span></span></span><br><span class="line"><span class="params"><span class="function">                    Iterable&lt;SensorReading&gt; minReadings,</span></span></span><br><span class="line"><span class="params"><span class="function">                    Collector&lt;Tuple2&lt;Long, SensorReading&gt;&gt; out)</span> </span>&#123;</span><br><span class="line">      SensorReading min = minReadings.iterator().next();</span><br><span class="line">      out.collect(<span class="keyword">new</span> Tuple2&lt;Long, SensorReading&gt;(context.window().getStart(), min));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="窗口底层实现"><a href="#窗口底层实现" class="headerlink" title="窗口底层实现"></a>窗口底层实现</h2><p>窗口的实现包含三个组件，分别是窗口分配器(WindowAssigner)、触发器(Trigger)和驱逐器(Evictor)。其中窗口分配器决定元素该分发到哪个窗口；触发器决定窗口中的元素何时计算或者清除该窗口中的元素，每个窗口都有自己的trigger；驱逐器类似过滤器，根据一定规则将窗口中部分数据清除掉。将这三个组件的不同实现组合在一起，就能实现各种窗口计算。</p><ul><li>窗口分配器(WindowAssigner)</li></ul><blockquote><p>先看下核心函数<br>assignWindows: 将对应的元素分配到指定的窗口中<br>getDefaultTrigger: 获取该窗口分配器默认指定的Trigger<br>isEventTime: 是否基于event time对元素进行分配</p></blockquote><p>countWindow中用的是GlobalWindow，所以该分配器只是返回当前窗口即可。<br>重点看下timeWindow的assignWindows方法，这里只关注下<code>SlidingEventTimeWindows</code>的<code>assignWindows</code>，因为滚动窗口的分配逻辑和滑动窗口类似。<code>SlidingEventTimeWindows.assignWindows</code>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;TimeWindow&gt; <span class="title">assignWindows</span><span class="params">(Object element, <span class="keyword">long</span> timestamp, WindowAssignerContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timestamp &gt; Long.MIN_VALUE) &#123;</span><br><span class="line">        <span class="comment">// 计算窗口可以有多少个滑动窗口</span></span><br><span class="line">        List&lt;TimeWindow&gt; windows = <span class="keyword">new</span> ArrayList&lt;&gt;((<span class="keyword">int</span>) (size / slide));</span><br><span class="line">        <span class="comment">// 当前元素时间所在的最近窗口的起始位置</span></span><br><span class="line">        <span class="keyword">long</span> lastStart = TimeWindow.getWindowStartWithOffset(timestamp, offset, slide);</span><br><span class="line">        <span class="comment">// 生成该元素的窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> start = lastStart;</span><br><span class="line">            start &gt; timestamp - size;</span><br><span class="line">            start -= slide) &#123;</span><br><span class="line">            <span class="comment">// 窗口的区间是前闭后开</span></span><br><span class="line">            windows.add(<span class="keyword">new</span> TimeWindow(start, start + size));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> windows;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Record has Long.MIN_VALUE timestamp (= no timestamp marker). &quot;</span> +</span><br><span class="line">                <span class="string">&quot;Is the time characteristic set to &#x27;ProcessingTime&#x27;, or did you forget to call &quot;</span> +</span><br><span class="line">                <span class="string">&quot;&#x27;DataStream.assignTimestampsAndWatermarks(...)&#x27;?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码逻辑在<code>TimeWindow.getWindowStartWithOffset</code>中，代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Method to get the window start for a timestamp.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timestamp epoch millisecond to get the window start.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset The offset which window start would be shifted by.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> windowSize The size of the generated windows.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> window start</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 滑动窗口和滚动窗口都是调用这个函数获取窗口的起始位置</span></span><br><span class="line"><span class="comment"> * 滑动窗口传入的windowSize是滑动的大小，对于滑动窗口按照slide滑动，其实可以理解成长度为slide的滚动窗口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getWindowStartWithOffset</span><span class="params">(<span class="keyword">long</span> timestamp, <span class="keyword">long</span> offset, <span class="keyword">long</span> windowSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// offset 可以理解成最开始到那个窗口的起始位置</span></span><br><span class="line">    <span class="comment">// timestamp - offset 为 到最开始那个窗口的距离</span></span><br><span class="line">    <span class="comment">// (timestamp - offset + windowSize) % windowSize 离最近窗口的距离，相当于timestamp - offset - windowSize - windowSize ...</span></span><br><span class="line">    <span class="comment">// timestamp - (timestamp - offset + windowSize) % windowSize 则为最近窗口的起始位置</span></span><br><span class="line">    <span class="keyword">return</span> timestamp - (timestamp - offset + windowSize) % windowSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>触发器(Trigger)</li></ul><blockquote><p>先看下核心函数<br>onElement: 处理每个添加到窗口中的元素<br>onEventTime: TriggerContext中注册的event-time timer被触发时调用<br>onProcessingTime: TriggerContext中注册的processing-time timer被触发时调用<br>onMerge: window被merge时触发</p></blockquote><p>在WindowAssigner中，会调用getDefaultTrigger得到该窗口的默认触发器。这里看下<code>SlidingEventTimeWindows</code>的默认trigger–<code>EventTimeTrigger</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TriggerResult <span class="title">onElement</span><span class="params">(Object element, <span class="keyword">long</span> timestamp, TimeWindow window, TriggerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// element 所在的 window，maxTimestamp为end-1</span></span><br><span class="line">    <span class="comment">// wartermark是定期生成的，maxTimestamp正常应该是大于wartermark的</span></span><br><span class="line">    <span class="comment">// window的maxTimestamp是不变的，wartermark是周期性变化的</span></span><br><span class="line">    <span class="comment">// 则onElement一般不会触发FIRE</span></span><br><span class="line">    <span class="comment">// 迟到时会触发</span></span><br><span class="line">    <span class="comment">// 假如一直没有迟到的数据到达是不是就不会在这里触发，</span></span><br><span class="line">    <span class="comment">// 假如迟到的数据到达了，但是该窗口已经由Time触发了FIRE怎么办？？</span></span><br><span class="line">    <span class="comment">// 迟到和乱序的理解：迟到会再次触发window计算，乱序是window等待一段时间进行计算，只计算一次。</span></span><br><span class="line">    <span class="comment">// 迟到会触发多次，只要在规定的最大迟到时间内都会触发计算</span></span><br><span class="line">    <span class="keyword">if</span> (window.maxTimestamp() &lt;= ctx.getCurrentWatermark()) &#123;</span><br><span class="line">        <span class="comment">// if the watermark is already past the window fire immediately</span></span><br><span class="line">        <span class="keyword">return</span> TriggerResult.FIRE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.registerEventTimeTimer(window.maxTimestamp());</span><br><span class="line">        <span class="keyword">return</span> TriggerResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一秒中的第一条数据触发窗口计算，那这之后的数据怎么计算？</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TriggerResult <span class="title">onEventTime</span><span class="params">(<span class="keyword">long</span> time, TimeWindow window, TriggerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> time == window.maxTimestamp() ?</span><br><span class="line">        TriggerResult.FIRE :</span><br><span class="line">        TriggerResult.CONTINUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!--ContinuousEventTimeTrigger：指定的 interval 以及 event window 的边界小于当前 watermark 时触发 onEventTime 计算ContinuousProessingTimeTrigger：指定的 interval 触发 onProcessingTime 计算CountTrigger: 指定的 maxCount 触发，出发后 maxCount 清零重新累加DeltaTrigger: 提供 delta 函数和历史 datapoint 存储，每个元素消费时触发 delta 函数计算EventTimeTrigger：event window 的边界小于当前 watermark 时触发 onEventTime 计算  是小于还是大于？？？ProessingTimeTrigger：event window 的边界小于当前 watermark 时触发 onProcessingTime 计算--><ul><li>驱逐器(Evictor)</li></ul><blockquote><p>先看下核心函数<br>evictBefore: 在触发窗口函数计算之前对窗口中的元素进行过滤<br>evictAfter: 在触发窗口函数计算之后对窗口中的元素进行过滤<br>evict: 过滤窗口中元素的具体实现，在evictBefore或者evictAfter内调用</p></blockquote><p>完整的窗口计算流程，经历了 Window Assigner -&gt; Trigger -&gt; Evictor -&gt; Evaluation Function 的过程，最终获得结果。</p><!--何为window，window类型，如何使用以及自定义 window function实例用起来很爽，但是window是怎么实现的呢？如何实现，借助trigger ev watermarktrigger计时器的作用？在哪用？ 如何触发？ 是定时器还是watermark    trigger会生成窗口，trigger计时器到之后进行窗口function计算触发器（Trigger）提供了一种灵活的机制来决定窗口的计算结果在什么时候对外输出。理论上来说，只有两种类型的触发器，大部分的应用都是选择其一或组合使用：Repeated update triggers：重复更新窗口的计算结果，更新可以是由新消息到达时触发，也可以是每个一段时间（如1分钟）进行触发Completeness triggers：在窗口结束时进行触发，这是更符合直觉的使用方法，也和批处理模式的计算结果相吻合。但是需要一种机制来衡量一个窗口的所有消息都已经被正确地处理了。ev 利用状态进行过滤watermark   Watermark 是用来追踪业务事件的概念，可以理解成 EventTime 世界中的时钟，用来指示当前处理到什么时刻的数据了    水印是针对事件时间的概念，提供了一种事件时间相对于处理时间是乱序的系统中合理推测无界数据集里数据完整性的工具    何为watermark    有何作用    如何生成   自动生成 setAutoWatermarkInterval    watermark与trigger如何相互作用    一个窗口可以有多个watermark，多个watermark如何触发窗口的，当前watermark触发上一个窗口的计算？？？    当前系统的 watermark 为时间 T，那么系统认为所有事件时间小于 T 的消息都已经到达，即系统任务它不会再接收到事件时间小于 T 的消息了多流乱序    watermark 大的数据会缓存吗？https://www.jianshu.com/p/b9b23a7cb880https://www.jianshu.com/p/c8c789ff5570window 都提供了window operator    在windowedStream中的windowFunction指定windowOperator综合early fire、late fire、水印时间与窗口结束时间，综合判断是否触发窗口当未来某个watermark的时间戳大于该trigger的注册时间时，就会触发trigger，执行该trigger所在的window operator的window process进行计算。WindowOperator 定义了window assigner, trigger, windowProcessFunction 的执行顺序如何，它们之间的执行逻辑等trigger过期还是窗口过期 watermark过期Timer怎么触发？apply：自定义window functionprocessElement处理数据流程：a、 获取当前record具有的事件时间，如果是Processing Time模式，从时间服务Service里面获取时间即可b、使用上一步获取的时间，接着调用windowFunction.assignWindow生成窗口，其内部实际上是调用各类型的WindowAssigner生成窗口，windowFunction有三大类，分别是Paned（滑动）、Merge（会话）、General（前两种以外的），WindowAssigner类型大致有5类，分别是Tumbling（翻转）、Sliding（滑动）、Session（会话）、CountTumbling 、CountSlide这几类,根据输入的一条数据和时间，可以生成1到多个窗口c、接下来是遍历涉及的窗口进行聚合，包括从windowState获取聚合前值、使用句柄进行聚合、更新状态至windowState，将当前转态d、上一步聚合完成后，就可以遍历窗口，使用TriggerContext（其实就是不同类型窗口Trigger触发器的代理），综合early fire、late fire、水印时间与窗口结束时间，综合判断是否触发窗口写出e、如果TriggerContext判断出触发条件为true，则调用emitWindowResult写出，其内部有retract判断，更新当前state及previous state，写出数据等操作f、如果TriggerContext判断出触发条件为false，则触发需要注册cleanupTimer,到达指定时间后，触发onEventTime或onProcessingTimeg、onEventTime或onProcessingTime功能十分类似，首先会触发emitWindowResult提交结果，另外会判断窗口结束时间+Lateness和当前时间是否相等，相等则表示可以清除窗口数据、当前state及previous state、窗口对应trigger。元素在streaming dataflow引擎中流动到WindowOperator时，会被分为两拨，分别是普通事件和水印。WatermarkAssignerOperator.advanceWatermark -> OperatorChain.emitWatermark -> operator.processWatermark-->]]></content>
    
    
    <summary type="html">&lt;p&gt;近几年流处理简直火的一塌糊涂，Flink也在阿里的推广下逐渐成为业界主流，正在逐步取代Storm和Spark Streaming。&lt;br&gt;Flink天生就是为了处理流，而且相对于其他流处理框架集成了很多实用功能，比如状态管理；Flink还丰富了window的功能，使window也成为了Flink的一个特色。&lt;br&gt;本篇主要对window从多种角度进行解密，主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;何为window&lt;/li&gt;
&lt;li&gt;如何使用&lt;/li&gt;
&lt;li&gt;如何实现&lt;/li&gt;
&lt;li&gt;各组件原理&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在解密window之前，简单介绍下何为流处理？&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Flink" scheme="http://yuanba.tech/categories/Flink/"/>
    
    
    <category term="BigData" scheme="http://yuanba.tech/tags/BigData/"/>
    
    <category term="Flink" scheme="http://yuanba.tech/tags/Flink/"/>
    
    <category term="window" scheme="http://yuanba.tech/tags/window/"/>
    
  </entry>
  
  <entry>
    <title>golang新手入门</title>
    <link href="http://yuanba.tech/golang-newbie.html"/>
    <id>http://yuanba.tech/golang-newbie.html</id>
    <published>2019-11-02T03:33:12.000Z</published>
    <updated>2019-11-02T03:33:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go开发环境配置"><a href="#Go开发环境配置" class="headerlink" title="Go开发环境配置"></a>Go开发环境配置</h2><p>​    选择操作系统对应的版本，可以直接下载安装包进行一键安装，也可以下载tar/zip包进行自定义安装。自定义安装时需要在环境变量中指定<code>GOROOT</code>和<code>GOPATH</code>，<code>GOROOT</code>是tar包的解压目录，<code>GOPATH</code>是Go工程项目目录，这里不仅存储这自己开发的项目也存放着项目所依赖包的源码及二进制文件。</p><span id="more"></span><h2 id="Go项目目录"><a href="#Go项目目录" class="headerlink" title="Go项目目录"></a>Go项目目录</h2><p>​    使用某种编程语言或者某个编程框架开发的项目都有自己特有的目录结构，所以学习一门新语言或者编程框架时要先熟悉其项目的工程目录结构。Go的工程目录是一个层级目录，第一层有两个目录<code>bin</code>和<code>src</code>两个目录，<code>bin</code>文件中存放的是Go编译之后的可执行文件，<code>src</code>文件夹中存放的都是项目源文件，项目的目录结构可根据代码功能进行划分。Go工程项目结构样例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bin/</span><br><span class="line">    hello                          <span class="comment"># command executable</span></span><br><span class="line">    outyet                         <span class="comment"># command executable</span></span><br><span class="line">src/</span><br><span class="line">    github.com/golang/example/</span><br><span class="line">        .git/                      <span class="comment"># Git repository metadata</span></span><br><span class="line">        hello/</span><br><span class="line">            hello.go               <span class="comment"># command source</span></span><br><span class="line">        outyet/</span><br><span class="line">            main.go                <span class="comment"># command source</span></span><br><span class="line">            main_test.go           <span class="comment"># test source</span></span><br><span class="line">        stringutil/</span><br><span class="line">            reverse.go             <span class="comment"># package source</span></span><br><span class="line">            reverse_test.go        <span class="comment"># test source</span></span><br><span class="line">    golang.org/x/image/</span><br><span class="line">        .git/                      <span class="comment"># Git repository metadata</span></span><br><span class="line">        bmp/</span><br><span class="line">            reader.go              <span class="comment"># package source</span></span><br><span class="line">            writer.go              <span class="comment"># package source</span></span><br><span class="line">    ... (many more repositories and packages omitted) ...</span><br></pre></td></tr></table></figure><p>上面的<code>src</code>目录有两个Go项目，分别是<code>example</code>和<code>image</code>。<code>example</code>中有三个文件夹，其中<code>hello</code>和<code>outyet</code>分别包含可执行命令的文件，<code>stringutil</code>是一个工具包。<code>image</code>中没有包含可执行命令的文件，只有一个bmp的工具包和其它工具包。通过<code>go install</code>命令编译<code>example</code>项目会<code>bin</code>目录中增加两个可执行文件<code>hello</code>和<code>outyet</code></p><p>​    Go的工程目录其实就是在上一节中设置的<code>GOPATH</code>，默认目录名是<code>go</code>，会当前用户home目录下创建此文件夹，例如Linux为<code>$HOME/go</code>，win为<code>C:\Users\YourName\go</code>。可以通过<code>export GOPATH=xx</code>设置任意目录，不过不能是Go的安装目录，也就是<code>GOROOT</code>。</p><p>​    Go提供了<code>env</code>命令，它可以输出环境变量的值，例如执行命令<code>go env GOPATH</code>，如果为了执行Go编译的可执行文件方便，可将<code>GOPATH</code>目录添加到PATH环境变量里，增加<code>export PATH=$PATH:$(go env GOPATH)/bin</code></p><h2 id="Go-Go-Go"><a href="#Go-Go-Go" class="headerlink" title="Go Go Go!"></a>Go Go Go!</h2><p>​    环境部署好，也熟悉了Go项目的目录结构，下面来个<code>Go Go Go!</code>找下Hello World的感觉。在<code>$GOPATH/src</code>目录下创建项目文件夹go-test，然后在此目录新建一个<code>hello.go</code>的文件，内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello, Go Go Go!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是在IDE中可以直接点击右键执行，也可以在命令行执行<code>go run hello.go </code>执行。Go可以生成可执行文件执行运行，执行命令<code>go install go-test</code>，其中go-test是项目相对于GOPATH的相对路径，也可以直接在go-test目录下执行<code>go install</code>，此命令成功之后会在<code>$GOPATH/bin</code>目录下增加一个<code>go-test</code>的可执行文件（如果是win，则是<code>go-test.exe</code>）。<code>go install</code>没有任何输出代表执行成功，执行异常时会有错误输出，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  go-test go install</span><br><span class="line"><span class="comment"># go-test</span></span><br><span class="line">./t.go:3:6: main redeclared <span class="keyword">in</span> this block</span><br><span class="line">        previous declaration at ./hello.go:8:6</span><br></pre></td></tr></table></figure><p>执行成功可以直接执行<code>$GOPATH/bin/go-test</code>。</p><p>​    Go和其它语言类似，也需要在文件开头引入一些包，使用命令<code>import</code>，例如<code>hello.go</code>中的<code>import &quot;fmt&quot;</code>，<code>fmt</code>是Go自带的标准依赖包，如果要引用其它依赖包则需要依赖包在<code>$GOPATH</code>中的相对路径，这个相对路径是每个依赖包的唯一标识。</p><p>​    由于Go语言天生的开源特性，很多依赖包的开源作者都习惯使用GitHub来管理自己的代码，在import时写<code>github.com/user/pro</code>即可，而且还可以选择不同的版本，方便的很。所以我们也可以在<code>$GOPATH</code>中创建自己的GitHub目录（即使你没有GitHub账号，但为了方便你某一天想把自己的代码开源出去让更多的人使用），假如Github账号是go-test，创建目录<code>mkdir -p $GOPATH/src/github.com/go-test</code>，然后将上面的<code>hello.go</code>代码移到该目录中。</p><p>​    如果在代码中引入了Github上的第三方依赖包，使用<code>go get github.com/user/pro</code>下载依赖到本地$GOPATH中，如何引入自己开发的第三方依赖包呢或者如何开发一个依赖包。</p><p>​    开发一个依赖包首先想一个包名，这个包名在自己开发的项目中不能重复，因为Go导入第三方依赖时是导入包路径。这里给<code>hello.go</code>增加一个<code>stringutil</code>的依赖，创建目录<code>mkdir $GOPATH/src/github.com/go-test/stringutil</code>，在此目录中新建一个 <code>reverse.go</code>的文件，复制如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package stringutil contains utility functions for working with strings.</span></span><br><span class="line"><span class="keyword">package</span> stringutil</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reverse returns its argument string reversed rune-wise left to right.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">r := []<span class="keyword">rune</span>(s)</span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(r)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(r)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">r[i], r[j] = r[j], r[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依赖包使用 <code>go build</code>进行编译，命令执行之后与<code>go install</code>一样不会打印任何信息，不同的是<code>go install</code>会在<code>$GOPATH/bin</code>中输出一个二进制文件，而 <code>go build</code>没有任何输出，只是将编译的结果放入本地build cache中。</p><p>​    依赖包编译成功之后就可以引用了，在上述的<code>hello.go</code>中添加依赖，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/go-test/stringutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello, Go Go Go!&quot;</span>)</span><br><span class="line">fmt.Println(stringutil.Reverse(<span class="string">&quot;!oG ,olleH&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>go install</code>，随后就可以执行<code>go-test</code>。</p><p>​    写完上面的代码，此时可能有些疑问为什么<code>hello.go</code>的package是<code>main</code>，而 <code>reverse.go</code>的package是<code>stringutil</code>。Go代码的第一行必须是<code>package name</code>，这个name一般为当前文件所在的目录名，例如<code>reverse.go</code>在<code>stringutil</code>目录中，则第一行为<code>package stringutil</code>，这个name也是依赖此包时导入路径的最后一个目录，如<code>hello.go</code>中要依赖的源码是 <code>reverse.go</code>，而它在<code>stringutil</code>目录中，所以添加<code>import &quot;github.com/go-test/stringutil&quot;</code>。需要注意的是某个package中的所有文件必须有一样的name，而且如果包含可执行命令，name必须为<code>main</code>，也就是像<code>hello.go</code>那样，而且还得包含<code>func main()</code>。</p><!-- 可执行文件的名字是怎么来的？？？？ 目录名 --><h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><p>​    了解上述内容其实就可以去玩Go了，但是在玩的过程中可能会遇到给文件起名字时以 <code>_test.go</code>的问题，在其它语言中对文件名字的内容并没有限制，但在Go中有限制，如果以 <code>_test.go</code>结尾则代表这是一个测试类。</p><p>​    Go有一个轻量的测试框架，使用时导入 <code>testing</code>包，执行<code>go test</code> 。使用测试框架时，创建一个以<code>_test.go</code>结尾文件，测试某个func的方法名为<code>func TestXXX(t *testing.T)</code>，如果这个测试方法调用了 <code>t.Error</code> 或者 <code>t.Fail</code>则认为测试失败。给上述 <code>reverse.go</code>添加一个测试类，在stringutil文件中创建<code>reverse_test.go</code>，复制如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stringutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReverse</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">cases := []<span class="keyword">struct</span> &#123;</span><br><span class="line">in, want <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;<span class="string">&quot;Hello, world&quot;</span>, <span class="string">&quot;dlrow ,olleH&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Hello, 世界&quot;</span>, <span class="string">&quot;界世 ,olleH&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> cases &#123;</span><br><span class="line">got := Reverse(c.in)</span><br><span class="line"><span class="keyword">if</span> got != c.want &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Reverse(%q) == %q, want %q&quot;</span>, c.in, got, c.want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行<code>go test github.com/go-test/stringutil</code>或者直接在stringutil目录中执行<code>go test</code>，执行成功输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> github.com/go-test/stringutil</span><br><span class="line">ok  github.com/user/stringutil 0.165s</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Go开发环境配置&quot;&gt;&lt;a href=&quot;#Go开发环境配置&quot; class=&quot;headerlink&quot; title=&quot;Go开发环境配置&quot;&gt;&lt;/a&gt;Go开发环境配置&lt;/h2&gt;&lt;p&gt;​    选择操作系统对应的版本，可以直接下载安装包进行一键安装，也可以下载tar/zip包进行自定义安装。自定义安装时需要在环境变量中指定&lt;code&gt;GOROOT&lt;/code&gt;和&lt;code&gt;GOPATH&lt;/code&gt;，&lt;code&gt;GOROOT&lt;/code&gt;是tar包的解压目录，&lt;code&gt;GOPATH&lt;/code&gt;是Go工程项目目录，这里不仅存储这自己开发的项目也存放着项目所依赖包的源码及二进制文件。&lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://yuanba.tech/categories/golang/"/>
    
    
    <category term="go" scheme="http://yuanba.tech/tags/go/"/>
    
    <category term="golang" scheme="http://yuanba.tech/tags/golang/"/>
    
    <category term="菜鸟" scheme="http://yuanba.tech/tags/%E8%8F%9C%E9%B8%9F/"/>
    
    <category term="环境" scheme="http://yuanba.tech/tags/%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>YARN Capacity Scheduler</title>
    <link href="http://yuanba.tech/[%E8%AF%91]Yarn-capacity.html"/>
    <id>http://yuanba.tech/[%E8%AF%91]Yarn-capacity.html</id>
    <published>2019-07-28T15:35:23.000Z</published>
    <updated>2019-08-12T15:45:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇译文，<a href="https://hortonworks.com/blog/yarn-capacity-scheduler/">原文地址</a></p><p>主要介绍了Capacity Scheduler相关的内容。</p><p>Capacity Scheduler在资源分配时主要考虑两个主要属性：<em>用户名和应用程序ID</em>。在指定最小用户百分比和用户限制因素的队列中，用户之间共享资源时，关注的是用户名本身。在队列中，应用程序获取资源分配由叶子队列排序策略驱动：FIFO或FAIR，它只关心应用程序而不关心哪个用户正在运行它。在FIFO中，资源首先被分配给队列中最先提交的应用程序，并且只有当它不再需要任何请求时，下一个应用程序才会获得分配。对于使用最少资源的FAIR应用程序，首先询问是否存在待处理的分配，如果存在则分配，则如果不存在，则检查具有最少资源的下一个应用程序；这有助于与通常使用它们的应用程序平均共享队列。</p><span id="more"></span><h2 id="容量和分层设计"><a href="#容量和分层设计" class="headerlink" title="容量和分层设计"></a>容量和分层设计</h2><p>​YARN对其可分配的资源定义了最小分配量和最大分配量，目前这些资源包括内存和内核。可调度资源是由NodeManage提供的，来自所有节点的资源聚合为可被Capacity调度的总资源，总资源组成root队列。</p><p>​Capacity调度的基础设置是如何布置队列以及为它们分配资源。队列以分层设计布局，最顶层的父节点是集群队列的“根”，可以从根分配子队列，或者可以在自己队列的基础上再次分配子队列。资源被分配给这些队列，作为层次结构中父级资源的最小和最大百分比。 最小容量是如果群集上的所有队列都已运行，并且集群总资源已用完，此时各队列应该可以使用的资源量。 最大容量是类似弹性的容量，允许队列利用不用于填充其他队列中的最小容量需求的资源。<br><img src="/blogimgs/capacity/queue.png" alt="队列设计" title="队列设计"></p><h2 id="最低用户百分比和用户限制因素"><a href="#最低用户百分比和用户限制因素" class="headerlink" title="最低用户百分比和用户限制因素"></a>最低用户百分比和用户限制因素</h2><p>​最小用户百分比和用户限制因子是控制如何将正在使用的队列中的资源分配给他们的方法。 最小用户百分比是单个用户在请求时应访问的最小资源量百分比，是一个软限制。 例如，10％的最小用户百分比意味着10个用户将获得10％; 这个值不是硬性规定的，因为如果其中一个用户要求更少，我们可能会将更多用户放入队列。</p><p>​用户限制因子是一种控制单个用户可以使用的最大资源量的方法。 用户限制因子设置为队列最小容量的倍数。如果用户限制因子为1表示用户可以使用队列的整个最小容量， 如果用户限制因子大于1，则用户可能会增长到最大容量，如果该值设置为小于1，例如0.5，则用户只能获得队列最小容量的一半。 如果您希望用户能够增长到队列设置的最大容量，则大于1的值将允许用户多次超过最小容量。<br><img src="/blogimgs/capacity/user.png" alt="限制因子" title="限制因子"></p><p>​最初可能不直观的常见设计点是按工作负载而不是应用程序创建队列，然后使用用户限制因子来防止单个用户<strong>通过使用小于1.0的值单独接管队列</strong>。 此模型支持更简单的操作，不允许通过为每个LoB创建一个队列来创建队列，而是通过按工作负载创建队列来创建可预测的队列行为。 一旦群集完全使用并且应用程序排队等待运行时，较低的用户限制因素将是控制租户之间资源共享的关键。</p><p>​最初，由于使用较小的用户限制来限制用户资源，这可能无法在其Hadoop平台旅程开始时提供群集利用率，有许多方法，但需要考虑的是，最初允许单个租户接管一个小集群（比如10个节点），这可能是合理的，但是当扩展平台占用空间时，降低用户限制因子，以便每个租户保留与添加新节点之前相同数量的可分配资源。 这可以让用户保持最初的体验，但是无法接管整个集群，因为随着整个群集的增长，新用户可以轻松获得分配的容量，同时不会降低原始用户的体验。</p><h2 id="队列设计"><a href="#队列设计" class="headerlink" title="队列设计"></a>队列设计</h2><p>​队列设计时需要考虑如下相关场景：</p><ul><li><strong>即时查询</strong><br>主要是些临时统计需求，任务的出现没有规律，主要集中在工作时间，由用户主动触发</li><li><strong>紧急需求</strong><br>主要用于处理一些紧急需求，比如紧急补数</li><li><strong>机器学习</strong><br>这部分需求是需要大量的资源并且可能会长时间占用资源，但是紧急度和运行时长要求不是很高</li><li><strong>实时计算</strong><br>这部分需求是长时间运行并且没有明确的结束标识，对实时要求较高，不能容忍延迟，需要严格保证资源不被其它需求抢占</li><li><strong>批处理</strong><br>是指一些常规数据ETL，主要关注任务的吞吐量而不是当个任务是否延迟</li></ul><p>​队列中资源使用模型可以认为是一些containers像常量那样一直存在和新启动的。 这种使用模型对于具有良好行为的集群非常重要，因为队列可以快速重新平衡到其最小容量，并公平地平衡其用户之间的队列容量。 不好的使用模式是长期存在的容器，资源一直在被自己使用并且永远不会释放，这样它可以阻止资源的适当重新平衡，在某些情况下它可以完全阻止其他应用程序启动或其他队列恢复其最小容量。 当不使用抢占时，如果队列扩容弹性空间但从不释放其容器，则弹性空间永远不会被返回给其他队列来保证他们的最小容量。 如果在队列中运行的应用程序具有长期存在容器，请特别注意并考虑使用诸如用户限制因子，抢占或甚至没有弹性容量的专用队列等功能来减轻其对其他用户的影响的方法。</p><h2 id="CAPACITY调度特性"><a href="#CAPACITY调度特性" class="headerlink" title="CAPACITY调度特性"></a>CAPACITY调度特性</h2><h3 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h3><p>​默认情况下Capacity调度不支持CPU调度。如果开启CPU调度的话，可能会降低批处理任务的吞吐量。支持CPU调度的算法是Dominant Resource Fairness (DRF)。</p><p>​CPU调度主要包含两部分：</p><ol><li>分配和放置</li><li>强制限制</li></ol><p>​只要开启CPU调度即可解决分配和放置问题，调度器会使用DRF算法和VCores Node Manager的汇报结果。 这解决了一些新问题，例如用户使用1个或2个executors来调度他的Spark应用程序，但是每个executor分配8个core，然后由于可用内存过多而继续向这个节点分配任务，由于core的限制影响这些任务的运行。 通过启用简单的CPU调度，如果正在使用所有core，则不再将其他任务分配到该节点上，并找到群集中其它节点来放置任务。</p><p>​至于强制限制可以通过Cgroup来解决。Cgroup可以让YARN确保分配给某个container的vcore个数不会超过请求的数量。可以启用未使用时共享vcores，也可以仅严格执行已安排的内容。 节点管理器还可以配置为服务器上允许所有任务总和的最大CPU使用量，这样可以保证操作系统的功能正常使用core。</p><h3 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h3><p>​当应用程序在队列A中使用了弹性容量，此时另一个队列B提交了一个应用程序，队列B的资源被队列A的任务抢先使用中，此时正常情况下队列B中的应用程序必须等待队列A中的任务释放自由之后才能运行。如果开启抢占功能，就可以立马回收其他队列中的资源，以便满足队列的最小容量需求。抢占功能并不会彻底杀死一个应用程序，优先抢占map任务的资源，最后才是reduce的资源，因为被kill掉的任务必须重新运行，reduce比map要重复更多的工作。 从排序的角度来看，抢占时优先考虑最新的应用程序和大多数超额订阅的应用程序。</p><p>​抢占有些功能并不能像用户预期的那样发挥作用。<strong>最常见的行为是认为队列可以在其自身内部抢占以平衡所有用户的资源。 这种假设是错误的，因为抢占只能在队列之间</strong>，在队列中用户之间的资源平衡需要查看其他控制方式，例如用户限制因子和队列FIFO / FAIR策略。</p><!--另一个行为是，如果资源不能提供足够的资源来满足另一个资源分配请求，则Preemption不会抢占资源。 虽然对于具有较大最大容器大小的小型集群而言，大型集群通常不会出现问题但是Preemption未配置为回收最大可能容量的容器，因此根本不会执行任何操作。 用于控制此行为的主要属性是每轮总抢占率和自然终止因子。 每轮总抢占率是群集中可以立即被抢占的资源的百分比，自然终止因子是所请求的总群集（100％）中资源的百分比将被抢占到每轮总抢占数。--><h3 id="队列的排序策略"><a href="#队列的排序策略" class="headerlink" title="队列的排序策略"></a>队列的排序策略</h3><p>​Capacity调度目前支持两种排序策略：FIFO和FAIR。队列默认使用的是FIFO，但是这不是用户所希望的排序策略。在叶子队列中配置FIFO或者FAIR，可以在应用程序的吞吐量和共享公平之间合理选择。关于排序策略的一个重要事情是，排序是针对队列中的应用程序级别，而不关心哪个用户拥有应用程序。</p><p>​FIFO策略是按照应用程序提交的顺序来排序的。如果应用程序有未完成的资源请求，则会根据先到先得的原则分配。 这样做的结果是，如果应用程序有足够的未完成请求，它们将在完成之前多次请求，可能会使用整个队列，它们将阻止其他应用程序启动。 用户甚至可以使用自己的应用程序占满整个集群资源而阻止其它应用程序提交，正是这种行为对用户来说是最不可接受的。</p><p>​使用FAIR策略能很容易的解决上面的问题。在子队列上使用FAIR策略时，应首先对应用程序已占用的资源量进行评估，资源使用最少的应用程序会优先分配请求。 这样，进入队列的没有进行资源分配的新应用程序将首先进行资源分配。 一旦队列中的所有应用程序都得到资源，这样就在用户之间得到平衡。</p><p>​最重要的是，只有在队列中有良好的资源交互时才会出现此行为。由于队列内部不存在抢占资源，因此无法在队列中强制重新分配资源，而且FAIR排序策略仅涉及新资源分配而非当前已使用资源的再分配；这是什么意思？ 如果队列中资源被当前任务使用且任务永远不会完成或长时间运行而不允许在队列中发生容器结束，那么将保留资源并仍然阻止应用程序执行。</p><h3 id="默认队列映射"><a href="#默认队列映射" class="headerlink" title="默认队列映射"></a>默认队列映射</h3><p>​通常是在配置文件中指定用户提交的队列，Capacity调度可以使用<strong>默认队列映射</strong>通过用户名或者用户组将用户路由到指定的队列。但是需要注意的是默认队列的路由规则是哪个规则先满足就使用那个规则进行路由。也就是说如果组用户映射规则在用户映射规则前面，则先使用组用户映射规则对用户进行路由。</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>​当资源在队列之间分配时，<strong>具有最低相对容量的队列首先获得资源</strong>。如果你想让某个队列总是比其它队列优先获得资源，那么最简单的方法就是提高这个队列的优先级。</p><p>​在这两个队列之上提供了如何使用未经队列优先级修改的相对容量的示例。在这种情况下，即使队列A小于队列B并且队列B使用更多绝对资源，也会选择继续接收它们，因为它的相对容量低于队列A的相对容量。如果所需行为需要队列A始终接收资源分配首先，队列优先级应该增加到高于队列B的优先级。当分配优先级时，更高的值表示更高的优先级。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一篇译文，&lt;a href=&quot;https://hortonworks.com/blog/yarn-capacity-scheduler/&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主要介绍了Capacity Scheduler相关的内容。&lt;/p&gt;
&lt;p&gt;Capacity Scheduler在资源分配时主要考虑两个主要属性：&lt;em&gt;用户名和应用程序ID&lt;/em&gt;。在指定最小用户百分比和用户限制因素的队列中，用户之间共享资源时，关注的是用户名本身。在队列中，应用程序获取资源分配由叶子队列排序策略驱动：FIFO或FAIR，它只关心应用程序而不关心哪个用户正在运行它。在FIFO中，资源首先被分配给队列中最先提交的应用程序，并且只有当它不再需要任何请求时，下一个应用程序才会获得分配。对于使用最少资源的FAIR应用程序，首先询问是否存在待处理的分配，如果存在则分配，则如果不存在，则检查具有最少资源的下一个应用程序；这有助于与通常使用它们的应用程序平均共享队列。&lt;/p&gt;</summary>
    
    
    
    <category term="Hadoop" scheme="http://yuanba.tech/categories/Hadoop/"/>
    
    
    <category term="Hadoop" scheme="http://yuanba.tech/tags/Hadoop/"/>
    
    <category term="BigData" scheme="http://yuanba.tech/tags/BigData/"/>
    
    <category term="YARN" scheme="http://yuanba.tech/tags/YARN/"/>
    
    <category term="Capacity" scheme="http://yuanba.tech/tags/Capacity/"/>
    
  </entry>
  
  <entry>
    <title>Resource Localization in YARN</title>
    <link href="http://yuanba.tech/YARN-Resource-Localization.html"/>
    <id>http://yuanba.tech/YARN-Resource-Localization.html</id>
    <published>2019-05-20T14:10:01.000Z</published>
    <updated>2019-05-20T17:10:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个Applciation运行在YARN上的流程为，从YARN Client向ResourceManager提交任务，将Applciation所需资源提交到HDFS中，然后ResourceManager启动APPMaster，APPMaster通知各个NodeManager启动container执行具体到计算任务。在启动container之前需要从HDFS上下载该container执行所依赖的资源，这些资源包括jar、依赖的jar或者其它文件，这个过程就称为<strong>资源本地化</strong>(Resource Localization)。</p><p>本篇主要介绍下资源本地化相关的内容。</p><span id="more"></span><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><strong>本地化(Localization)</strong><br>本地化是指将HDFS上的资源下载到本地的<strong>过程</strong>。将资源本地化，使container不用总是访问HDFS上的数据，而是直接访问本地数据，提高效率。</p><p><strong>本地资源(LocalResource)</strong><br>本地资源是指container运行时所需要的资源，可以是某个文件或者依赖的library，这些资源存在HDFS中。NodeManager在container启动之前负责将这些资源进行本地化。对于Application来说，本地资源指：</p><ul><li>URL: 需要从HDFS上下载的本地资源地址</li><li>Size: 本地资源的大小</li><li>timestamp: 本地资源在HDFS上创建时的时间戳</li><li>LocalResourceType: NodeManager本地化资源时指定的资源类型，有FILE、ARCHIVE和PATTERN</li><li>Pattern: 从archive中解压具体内容时使用的规则匹配方式(只有LocalResourceType是PATTERN时才生效)。</li><li>LocalResourceVisibility: NodeManager将资源本地化之后针对该Nodemanager上其它用户和Application的可见性。可见范围为PUBLIC、PRIVATE和APPLICATION。</li></ul><blockquote><p>NOTE: 本地资源并不是指在本地磁盘的资源，而是需要从HDFS下载到本地的资源。</p></blockquote><p>那么container会请求什么样的资源进行本地化呢？可以是任意的文件，但是这些文件对contianer必须是只读的。<br>下面举几个比较适合做本地资源的典型例子：</p><ol><li>container启动的时候需要的代码库，如jar文件</li><li>container启动时所需要的configure文件</li><li>静态的文件目录</li></ol><p>一些动态资源不适合作为本地资源，例如：container需要的资源有可能被其它组件进行更新，application自己会直接更新的文件或者application想跟其它服务共享文件的变化情况的。</p><p><strong>ResourceLocalizationService</strong><br>ResourceLocalizationService是NodeManager内部的一个服务，主要负责下载和管理container所需的各种资源。下载时会对所有可用的磁盘进行负载均衡，对下载的资源会严格控制他们的访问权限。</p><p><strong>DeletionService</strong><br>DeletionService也是NodeManager内部的一个服务，主要负责在收到指令之后删除本地目录</p><p><strong>Localizer</strong><br>Localizer实际上是一个线程，用于资源本地化。Localizer有两种类型，一种是指用与下载PUBLIC访问类型资源的<em>PublicLocalizer</em>，另一种是下载PRIVATE和APPLICATION访问类型的<em>ContainerLocalizers</em>。</p><p><strong>LocalCache</strong><br>LocalCache是NodeManager维护所有下载到本地的文件的local-cache。这些资源通过下载时指定的HDFS地址来唯一标识。</p><h2 id="概念补充"><a href="#概念补充" class="headerlink" title="概念补充"></a>概念补充</h2><h3 id="LOCALRESOURCE-TIMESTAMPS"><a href="#LOCALRESOURCE-TIMESTAMPS" class="headerlink" title="LOCALRESOURCE TIMESTAMPS"></a>LOCALRESOURCE TIMESTAMPS</h3><p>timestamp反应了本地资源的一个版本，NodeManager在下载本地资源时会检查timestamp，这样Application在运行时看到的文件内容都一样。<br>利用timestamp，YARN能发现资源是否发生过变化，如果发生变化将使container失败避免不一致发生。因为在HDFS上的资源一旦被NodeManager本地化到本地磁盘，这个文件就不再与源文件有任何联系，只会记录下原来的URL用来在本地进行唯一标识。此时即使源文件发生变化，NodeManager也不会跟踪此变化再次下载文件。</p><blockquote><p>这里需要注意的是<em>当container启动时，ApplicationMaster会向运行container的NodeManager指定资源的timestamp，同样当运行ApplicationMaster的container启动时，也需要资源的timestamp，此时这个timestamp就需要由client指定</em>。以MapReduce on YARN为例，MapReduce的JobClient决定ApplicationMaster需要的资源的timestamp，然后由ApplicationMaster自己决定map和reduce所需资源的timestamp。</p></blockquote><h3 id="LOCALRESOURCE-TYPES"><a href="#LOCALRESOURCE-TYPES" class="headerlink" title="LOCALRESOURCE TYPES"></a>LOCALRESOURCE TYPES</h3><p>上一节中提到LocalResourceType为FILE、ARCHIVE和PATTERN，下面介绍下三种type的具体含义。<br>FILE类型是指普通的文件，文本类型或者二进制文件<br>ARCHIVE类型是指一些可以被NodeManager自动识别解压的归档文件，比如jars、tars、tar.gz和zip<br>PATTERN是ARCHIVE和FILE的一种混合体。这种类型下载到本地的源文件会保留，并且在本地化时只有解压的文件会留存在本地文件系统中。源文件和解压的文件在同一个目录中。哪些文件需要从ARCHIVE中抽取出来，哪些不需要这些都是由pattern决定的。目前只有jar支持PATTERN，其它都被认为正常的ARCHIVE。</p><h3 id="LOCALRESOURCE-VISIBILITES"><a href="#LOCALRESOURCE-VISIBILITES" class="headerlink" title="LOCALRESOURCE VISIBILITES"></a>LOCALRESOURCE VISIBILITES</h3><p>上一节LocalResourceVisibility中提到本地资源有三种可见性，分别为PUBLIC、PRIVATE和APPLICATION。其中</p><p>PUBLIC的访问权限是指<strong>任何用户的任意Application的container都可以访问</strong>。典型的PUBLIC资源是那些在HDFS上可以被任何人访问的文件，当这些资源被本地化之后会保留相同的访问权限。<em>如果一个资源是PUBLIC，当有container(container可以是当前Attempt，也可以是其它用户的任意Application中的container)请求相同的本地资源时，只要此资源没有被LocalCache删除，都可以直接从LocalCache里直接使用，而不需要再次下载</em>。</p><p>PUBLIC资源存储在NodeManager本地磁盘的<code>&lt;local-dir&gt;/filecache</code>目录下，此目录中的所有文件的owner是NodeManager进程启动时的用户，并且所有用户都有读权限，因此这些资源可以在此NodeManager上运行的所有用户的container共享。</p><p>PRIVATE权限本地资源只能在<strong>当前节点上相同用户的application之间共享</strong>，这些资源存储在NodeManager本地磁盘的<code>&lt;local-dir&gt;/usercache/$username/filecache</code>目录下，这些文件的owner是启动Application的user，并且其它用户没有访问权限。类似PUBLIC，一旦资源本地化，所有的用户都没有写权限，即使是提交任务的user。这样是为了避免恶意的container去修改文件。</p><p>APPLICATION只在<strong>当前节点上同一个application的container之间共享</strong>。这些资源存储在NodeManager本地磁盘的<code>&lt;local-dir&gt;/usercache/$username/appcache/&lt;app-id&gt;/</code>目录下，文件的owner是Application的提交者，并且只有读权限。</p><blockquote><p>这里需要注意的是LOCALRESOURCE VISIBILITIES与LOCALRESOURCE TIMESTAMPS类似，都是由ApplicationMaster指定本地资源的可见性，NodeManager并不会对资源的可见性做任何决定。同样当运行ApplicationMaster的container启动时，也需要资源的可见性，此时这个可见性就需要由client指定。以MapReduce on YARN为例，MapReduce的JobClient决定ApplicationMaster需要的资源的可见性，然后由ApplicationMaster自己决定map和reduce所需资源的可见性。</p></blockquote><h4 id="本地化流程"><a href="#本地化流程" class="headerlink" title="本地化流程"></a>本地化流程</h4><p>PUBLIC资源本地化是由<code>PublicLocalizer</code>实现的，在NodeManager进程中会有一个线程池PublicLocalizers，其个数是由<code>yarn.nodemanager.localizer.fetch.thread-count</code>决定，线程池的大小决定并行下载PUBLIC资源的线程最大个数。当PublicLocalizer本地化PUBLIC资源时，会通过检查这些资源在HDFS上的权限来确定所申请的资源确实为PUBLIC。只要有资源不符合就拒绝本地化。PublicLocalizer能安全的从HDFS上下载资源是向ContainerLaunchContext传递了证书。 </p><p>PRIVATE/APPLICATON资源的本地化是由<code>ContainerLocalizer</code>实现的，不同与PUBLIC的<code>PublicLocalizer</code>实现。<em>PublicLocalizer是直接在NodeManager中启动一个线程池进行本地化，而ContainerLocalizer出于安全问题，并没有在NodeManager进程中直接实现，而是在continer中实现的</em>。</p><p>PRIVATE/APPLICATON资源的本地化是由<code>ContainerLocalizer</code>实现，这是一个单独的进程，这个进程由<code>LocalizerRunner</code>线程管理，<em>LocalizerRunner是NodeManager中的一个线程</em>，只要某个container有资源还没有下载，<em>那么此container就会触发一个LocalizerRunner</em>。下面看下具体的细节：</p><!--LocalResourcesTracker is a per-user or per-application object that tracks all the LocalResources for a given user or an application.--><p>当某个container第一次请求PRIVATE/APPLICATION类型的本地资源时，如果没有在LocalResourcesTracker中找到，则加入pending-resources列表。随后是否需要创建LocalizerRunner线程取决于是否有必要下载资源，如果需要就将本地资源加入<strong>LocalizerRunner</strong>维护的pending-resources列表。</p><p>NodeManager在安全模式时，本地资源本地化时需要所用的user是application的提交用户而不是NodeManager的启动用户。因此<strong>LocalizerRunner会以application提交者的身份启动LinuxContainerExecutor(LCE)进程，然后LCE会执行ContainerLocalizer下载资源</strong>。<em>ContainerLocalizer启动之后会与NodeManager维持一个心跳</em>，通过心跳，LocalizerRunner给ContainerLocalizer分配需要下载的资源或者停止ContainerLocalizer进程，而ContainerLocalizer会通知LocalizerRunner自己的下载进度。如果资源下载失败，这个资源将会从LocalResourcesTracker中移除，并且container最终也会失败。如果下载成功，LocalizerRunner会通过心跳给ContainerLocalizer另一个资源进行下载，直到所有的资源都下载完。</p><!--At present, each ContainerLocalizer doesn’t support parallel download of mutliple PRIVATE/APPLICATION resources which we are trying to fix via YARN-574.Note that because of the above, the maximum parallelism that we can get at present is the number of containers requested for same user on same node manager at THAT point of time. This in the worst case is one when an ApplicationMaster itself is starting. So if AM needs any resources to be localized then today they will be downloaded serially before its container starts.--><h4 id="本地资源的生命周期"><a href="#本地资源的生命周期" class="headerlink" title="本地资源的生命周期"></a>本地资源的生命周期</h4><p>由于本地资源的访问权限不一样，则不同的LocalResourceType在本地保留的时间也会不一样。</p><ul><li>PUBLIC由于是在任何用户的任意Application之间共享，所以并不会在某个container或者application结束之后被删除，只有在本地目录<local-dir>达到存储阈值时才会被删除，这个阈值由<code>yarn.nodemanager.localizer.cache.target-size-mb</code>控制。</li><li>PRIVATE和PUBLIC的生命周期一样。</li><li>APPLICATION会在application结束之后立即删除。</li></ul><!--One thing of note is that for any given application, we may have multiple ApplicationAttempts and each attempt may start zero or more containers on a given node manager. When the first container belonging to an ApplicationAttempt starts, ResourceLocalizationService localizes files for that application as requested in the container’s launch context. If future containers request more such resources then they all will be localized. If one ApplicationAttempt finishes/fails and another is started, ResourceLocalizationService doesn’t do anything w.r.t the previously localized resources. However when eventually the application finishes, ResourceManager communicates that information to NodeManagers which in turn clear the application LocalCache. In summary, APPLICATION LocalResources are truly application scoped and not ApplicationAttempt scoped.--><h4 id="本地化相关的配置"><a href="#本地化相关的配置" class="headerlink" title="本地化相关的配置"></a>本地化相关的配置</h4><p>在<code>yarn-site.xml</code>中有一些资源本地化相关的配置。</p><ul><li><code>yarn.nodemanager.local-dirs</code>: 资源本地化时所在的本地目录，可以是以逗号分隔的多个磁盘目录。</li><li><code>yarn.nodemanager.local-cache.max-files-per-directory</code>: 每个目录中最多本地化文件的个数，PUBLIC / PRIVATE / APPLICATION分别统计。</li><li><code>yarn.nodemanager.localizer.address</code>: ResourceLocalizationService服务监听的RPC地址，用来接收不同localizers</li><li><code>yarn.nodemanager.localizer.client.thread-count</code>: ResourceLocalizationService中用来处理来自localizers请求的线程数。默认是5</li><li><code>yarn.nodemanager.localizer.fetch.thread-count</code>: 本地化PUBLIC资源时PublicLocalizer的线程数。默认是4</li><li><code>yarn.nodemanager.delete.thread-count</code>: DeletionService中删除文件的线程数，默认是4。</li><li><code>yarn.nodemanager.localizer.cache.target-size-mb</code>: 本地化资源所占的最大磁盘空间，单位是MB，比包括APPLICATION资源。</li><li><code>yarn.nodemanager.localizer.cache.cleanup.interval-ms</code>: 每隔固定时间，去检查下磁盘的使用量。在此间隔之后，如果存储的磁盘空间超过了配置的阈值，会删除未用的资源。</li></ul><blockquote><p>未使用的资源是指没有被正在运行的container引用的资源。每次container请求资源时，container会被加入到一个资源引用列表中，直到container结束之后才会被移除。所以当引用数为0时，可以被删除。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.hortonworks.com/blog/management-of-application-dependencies-in-yarn/">Management of Application Dependencies in YARN</a><br><a href="https://zh.hortonworks.com/blog/resource-localization-in-yarn-deep-dive/">Resource Localization in YARN: Deep Dive</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个Applciation运行在YARN上的流程为，从YARN Client向ResourceManager提交任务，将Applciation所需资源提交到HDFS中，然后ResourceManager启动APPMaster，APPMaster通知各个NodeManager启动container执行具体到计算任务。在启动container之前需要从HDFS上下载该container执行所依赖的资源，这些资源包括jar、依赖的jar或者其它文件，这个过程就称为&lt;strong&gt;资源本地化&lt;/strong&gt;(Resource Localization)。&lt;/p&gt;
&lt;p&gt;本篇主要介绍下资源本地化相关的内容。&lt;/p&gt;</summary>
    
    
    
    <category term="Hadoop" scheme="http://yuanba.tech/categories/Hadoop/"/>
    
    
    <category term="Hadoop" scheme="http://yuanba.tech/tags/Hadoop/"/>
    
    <category term="BigData" scheme="http://yuanba.tech/tags/BigData/"/>
    
    <category term="YARN" scheme="http://yuanba.tech/tags/YARN/"/>
    
    <category term="Localization" scheme="http://yuanba.tech/tags/Localization/"/>
    
  </entry>
  
</feed>
