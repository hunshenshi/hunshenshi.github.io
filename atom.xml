<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>big data decode club</title>
  
  <subtitle>hunhun -- Any answers you can find in source code.</subtitle>
  <link href="http://yuanba.tech/atom.xml" rel="self"/>
  
  <link href="http://yuanba.tech/"/>
  <updated>2022-11-25T15:12:10.000Z</updated>
  <id>http://yuanba.tech/</id>
  
  <author>
    <name>混绅士</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Golang开发wasm程序</title>
    <link href="http://yuanba.tech/golang-wasm.html"/>
    <id>http://yuanba.tech/golang-wasm.html</id>
    <published>2022-11-25T13:32:12.000Z</published>
    <updated>2022-11-25T15:12:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>wasm以小巧安全的特性受到广泛的关注，但是他也有很多的局限性。<br>这些局限性可以通过<code>Host Function</code>进行扩展，使得<em>wasm</em>与<em>host</em>能够进行交互，完成更多的功能。</p><p><code>Host Function</code>需要<code>import</code>到wasm中，同样wasm中的function需要<code>export</code>到host中才能调用。</p><p>本篇主要记录下在Golang下，<code>wasm function</code>如何与<code>host function</code>进行交互。</p><span id="more"></span><h2 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h2><ol><li>使用wazero或者wasmtime-go作为wasm的runtime</li><li>Tinygo编译Golang为wasm文件</li></ol><h2 id="为什么需要Host-Function"><a href="#为什么需要Host-Function" class="headerlink" title="为什么需要Host Function"></a>为什么需要<code>Host Function</code></h2><p><code>Host Function</code>指在<code>Host</code>程序里定义的方法。某些方面wasm还不太完善，比如默认情况下不能在终端上打印信息，比如<code>fmt.Println(&quot;Hello&quot;)</code>，此时就可以在<code>host</code>程序中创建一个<code>Print(string)</code>方法，让wasm调用这个<code>Print(string)</code>方法。</p><p>在Golang中需要wasm runtime将<code>Host Function</code>(比如<code>Print(string)</code>)加载到wasm中即可运行，这个操作从wasm角度看，为<code>import</code>。</p><p><img src="/blogimgs/golang-wasm/print-import.png"></p><h2 id="show-me-code"><a href="#show-me-code" class="headerlink" title="show me code"></a>show me code</h2><p><em>wasm</em>与<em>host</em>进行交互涉及到<code>import</code>和<code>export</code>操作，通过代码具体展示何时使用<code>import</code>和<code>export</code>，以及在tinygo中又该如何使用。</p><h3 id="1-Golang创建wasm模块"><a href="#1-Golang创建wasm模块" class="headerlink" title="1. Golang创建wasm模块"></a>1. Golang创建wasm模块</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export add </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="keyword">uint32</span>, y <span class="keyword">uint32</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1标记的空<code>main</code>函数是tinygo编译wasm时需要的</li><li>2标记的是将<code>add</code>方法导出到<code>host</code>，这样就可以在host程序中调用wasm模块</li></ul><p>使用tinygo将golang编译为wasm模块<br><code>tinygo build -o hello.wasm -scheduler=none --no-debug -target wasi ./hello.go</code></p><h3 id="2-编写host程序调用wasm模块"><a href="#2-编写host程序调用wasm模块" class="headerlink" title="2. 编写host程序调用wasm模块"></a>2. 编写<code>host</code>程序调用wasm模块</h3><p><code>host</code>模块是用<code>Wazero</code>runtime编写，首先创建一个WebAssembly Runtime，然后实例化一个WebAssembly module，这样<code>host</code>程序就能调用<code>wasm function</code>了。代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;context&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/tetratelabs/wazero&quot;</span></span><br><span class="line">  <span class="string">&quot;github.com/tetratelabs/wazero/wasi_snapshot_preview1&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ctx := context.Background()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">  r := wazero.NewRuntimeWithConfig(</span><br><span class="line">    ctx, wazero.NewRuntimeConfig().</span><br><span class="line">    WithWasmCore2())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">defer</span> r.Close(ctx) </span><br><span class="line"></span><br><span class="line">  _, err := wasi_snapshot_preview1.Instantiate(ctx, r)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Panicln(err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">  helloWasm, err := os.ReadFile(<span class="string">&quot;./hello.wasm&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Panicln(err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">  mod, err := r.InstantiateModuleFromBinary(ctx, helloWasm)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Panicln(err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">  addWasmModuleFunction := mod.ExportedFunction(<span class="string">&quot;add&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line">  result, err := addWasmModuleFunction.Call(ctx, <span class="number">20</span>, <span class="number">22</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Panicln(err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;result:&quot;</span>, result[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1标记的是创建一个WebAssembly Runtime</li><li>2标记的是加载一个wasm模块</li><li>3标记的是实例化一个WebAssembly module</li><li>4标记的是获取一个<code>wasm function</code> <strong>add</strong>的引用</li><li>5标记的是在host程序中调用wasm</li></ul><p>然后可以像运行正常Go程序那样执行<code>go run main.go</code>，输出是<code>result: 42</code></p><p>这个基础例子展示了wasm模块的常规用法，主要展示了host程序如何调用wasm模块。</p><ol><li>但是wasm模块如何调用<code>host function</code>呢？</li><li>在Go编写的wasm模块中，使用<code>export</code>关键字标记host程序可调用的<code>wasm function</code>，那<code>host function</code>又是如何标记被wasm模块调用的呢？</li></ol><p>带着这两个疑问看下面这一节内容。</p><h2 id="export-import-傻傻分不清楚"><a href="#export-import-傻傻分不清楚" class="headerlink" title="export import 傻傻分不清楚"></a>export import 傻傻分不清楚</h2><p>上面说wasm局限性时提到无法在终端打印信息，需要在<code>host function</code>中定义一个<code>Print(string)</code>方法，然后在wasm模块中调用，现在就在<code>host</code>程序中定义一个在终端打印数字的方法<code>hostLogUint32</code>。</p><blockquote><p>hostLogUint32</p></blockquote><p>wasm模块调用<code>host function</code>需要在host程序中和wasm中都进行改动</p><ul><li>host程序中的改动</li></ul><ol><li>定义一个<code>logUint32</code>方法</li><li>export <code>logUint32</code>方法到Wasm runtime种，为了方便标记<code>logUint32</code> export的名字为<code>hostLogUint32</code></li></ol><ul><li>wasm程序中的改动</li></ul><ol><li>import <code>hostLogUint32</code>方法</li><li>在wasm模块中调用<code>hostLogUint32</code>方法在终端打印一个数字</li></ol><p><img src="/blogimgs/golang-wasm/hostLogUint32.png"></p><p>看下具体的代码改动，在<code>main.go</code>中添加<code>logUint32</code>方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logUint32</span><span class="params">(value <span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;🤖:&quot;</span>, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在runtime中export <code>logUint32</code>方法为<code>hostLogUint32</code>，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_, errEnv := wasmRuntime.NewModuleBuilder(<span class="string">&quot;env&quot;</span>).</span><br><span class="line">  ExportFunction(<span class="string">&quot;hostLogUint32&quot;</span>, logUint32).</span><br><span class="line">  Instantiate(ctx, wasmRuntime)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> errEnv != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Panicln(<span class="string">&quot;env/host function(s) error:&quot;</span>, errEnv)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在wasm模块中import <code>hostLogUint32</code>，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//export hostLogUint32</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hostLogUint32</span><span class="params">(value <span class="keyword">uint32</span>)</span></span></span><br></pre></td></tr></table></figure><p><strong>这里是不是有人开始疑惑了，不是说好import嘛，怎么还是export呀？？？我当时可是困扰了好久好久。。。</strong><br><strong>这里<code>//export hostLogUint32</code>其实是wasm模块import <code>host function</code>，可以注意到这里的<code>hostLogUint32</code>并没有方法体，这个可以用来区分是export还是import</strong></p><p>最后就是在wasm模块中调用<code>host function</code>了，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export hostLogUint32</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hostLogUint32</span><span class="params">(value <span class="keyword">uint32</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export add</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="keyword">uint32</span>, y <span class="keyword">uint32</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">  res := x + y</span><br><span class="line">  hostLogUint32(res)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序准备好之后就可以运行，由于wasm模块也发生了变化，所以需要重新编译wasm文件，执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tinygo build -o hello.wasm -scheduler=none --no-debug -target wasi ./hello.go</span><br><span class="line"></span><br><span class="line">go run main.go</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出如下</span></span><br><span class="line">🤖: 42         # from the Wasm module</span><br><span class="line">result: 42     # from the host program</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>写这篇文章的主要目的其实想理解tinygo中export的用法，因为在参考wasm相关教程中<code>host function</code>需要import到wasm中才能使用，但是tinygo中并没有提供<code>import</code>关键字，这使我一度怀疑代码有问题，为了消除疑虑所以才查找了很多资料。</p><p>我的理解是tinygo中的<code>export</code>关键字有时间充当将wasm模块中的方法export到host的功能，有时也充当将<code>host function</code>中的方法import到wasm模块的功能，那这两种场景如何区分呢？是看带有<code>export</code>关键字的方法是否有<code>方法体</code>，如何有就是<code>export</code>，没有则是<code>import</code>。这个结果从<code>hostLogUint32</code>的解析图中可以猜想到，我们还可以将编译之后的wasm文件进行反编译进行验证。</p><p>wasm文件反编译使用的是<code>wasm-decompile</code>命令，具体命令为<code>wasm-decompile log.wasm -o log.dcmp</code>，查看<code>log.dcmp</code>文件可看到import和export标注的方法。</p><p><a href="https://www.wasm.builders/k33g_org/extend-wasm-with-host-functions-thanks-to-wazero-3n0n">参考</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;wasm以小巧安全的特性受到广泛的关注，但是他也有很多的局限性。&lt;br&gt;这些局限性可以通过&lt;code&gt;Host Function&lt;/code&gt;进行扩展，使得&lt;em&gt;wasm&lt;/em&gt;与&lt;em&gt;host&lt;/em&gt;能够进行交互，完成更多的功能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Host Function&lt;/code&gt;需要&lt;code&gt;import&lt;/code&gt;到wasm中，同样wasm中的function需要&lt;code&gt;export&lt;/code&gt;到host中才能调用。&lt;/p&gt;
&lt;p&gt;本篇主要记录下在Golang下，&lt;code&gt;wasm function&lt;/code&gt;如何与&lt;code&gt;host function&lt;/code&gt;进行交互。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="http://yuanba.tech/categories/Golang/"/>
    
    
    <category term="Wasm" scheme="http://yuanba.tech/tags/Wasm/"/>
    
    <category term="Golang" scheme="http://yuanba.tech/tags/Golang/"/>
    
    <category term="Tinygo" scheme="http://yuanba.tech/tags/Tinygo/"/>
    
  </entry>
  
  <entry>
    <title>基于Wasm的轻量实时计算</title>
    <link href="http://yuanba.tech/wasm-realtime.html"/>
    <id>http://yuanba.tech/wasm-realtime.html</id>
    <published>2022-11-05T05:35:12.000Z</published>
    <updated>2022-11-05T05:35:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着各行各业对实时计算的需求越来越强烈，实时计算领域的竞争也越来越激烈，呈现百花齐放的状态。</p><p>虽说Flink在实时计算领域已坐稳老大哥，但是却也阻挡不了其它实时计算框架在某些细分领域发光。</p><p>本篇主要介绍几款基于wasm的轻量实时计算框架，比如Redpanda、InfinyOn。</p><span id="more"></span><h2 id="wasm是什么"><a href="#wasm是什么" class="headerlink" title="wasm是什么"></a>wasm是什么</h2><p>wasm是WebAssembly的简称，就是一个可移植、体积小、加载快并且兼容Web的全新格式。网上也有很多相关的介绍，可以参考下。</p><h2 id="Redpanda"><a href="#Redpanda" class="headerlink" title="Redpanda"></a>Redpanda</h2><p>来自官方的描述：<em>Redpanda is a Kafka®-compatible streaming data platform that is up to 10x faster and 6x more hardware-efficient. It is also JVM-free, ZooKeeper®-free, Jepsen-tested and source available.</em><br>Redpanda是一个实时数据平台，完全兼容kafka，并且没有外部依赖，比如zookeeper。它是用<code>C++</code>编写，所以也没有<code>JVM</code>。</p><p>由官方的描述可知它主要是对标kafka，其核心功能也就是消息队列。不过它还可以对数据进行实时处理，个人感觉其整体功能有点类似Plusar。</p><p>由于它完全兼容kafka，所以它也有topic、partition、replication这些概念，而且使用方式也与kafka一样，就不再赘述了。这里主要介绍下实时处理也就是<code>Data Transforms</code>功能</p><h3 id="Data-Transforms"><a href="#Data-Transforms" class="headerlink" title="Data Transforms"></a>Data Transforms</h3><p><code>Data Transforms</code>是Redpanda用于实时数据处理的模块，其基于<code>wasm</code>实现。基于<code>wasm</code>实现的好处是用户可以使用自己熟悉的语言(可编译为wasm)开发数据处理逻辑，然后将其编译为<code>wasm</code>文件并注册部署到Redpanda中，就可以对数据进行实时处理，对用户及其友好。</p><p>上面是我个人的理解，下面是官方给出的亮点：</p><ol><li>易用: 用户只需使用wasm支持的语言编写TransForm逻辑，然后将其注册到Redpand中就可以了，无需关kafka的依赖库。</li><li>高效: Transform代码会推送到集群中的所有节点中，Redpanda节点会像调用RPC那样调用这些本地代码。</li><li>简单: Transform管理较简单，只需将其注册到Redpanda即可，其会存储在一个单独的topic中，由Redpanda自己管理。</li></ol><h3 id="Data-Transforms架构"><a href="#Data-Transforms架构" class="headerlink" title="Data Transforms架构"></a>Data Transforms架构</h3><p>Data Transforms由4部分组成，分别是<code>客户端工具</code>、<code>存储和Transform code</code>、<code>Routing streams</code>和<code>执行引擎</code>。</p><p><img src="/blogimgs/wasm-realtime/arch.png" title="架构图"></p><blockquote><p>客户端工具(Client-side tooling)</p></blockquote><p>客户端工具<code>rpk</code>可以生成一个标准工程模版，开发者只需填充数据转换逻辑即可。还可通过<code>rpk</code>进行部署、更新<code>wasm</code>文件。</p><blockquote><p>存储和Transform code(Storage and distribution of scripts)</p></blockquote><p>Redpanda核心是一个可线性扩展、支持事务的存储引擎，底层使用raft协议保证数据副本之间的一致性。Redpanda完全支持kafka协议，所以也是按照topic、partition和replication进行存储的，同样也支持压缩存储。</p><p>开发者注册的<code>.wasm</code>文件存在一个单独的内置topic中，其topic也是支持压缩的。<code>wasm</code>文件通过名字来区分，相同名字的wasm根据时间顺序进行更新，压缩时会将历史版本移除。</p><blockquote><p>Routing streams(pacemaker)</p></blockquote><p>Routing streams主要用来将数据根据规则路由给不同的transform进行处理，这个组件被称为<code>pacemaker</code>。它是整个系统的核心，它需要在保证高效的前提下还需要保证数据的顺序性。其整个工作流包含3步：</p><ol><li>并行从<code>input</code>中读取数据</li><li>每个协处理器通过RPC调用<code>wasm</code>执行引擎执行传过来的数据和相关的元数据</li><li>将执行结果和offset写入结果topic中</li></ol><p><img src="/blogimgs/wasm-realtime/pacemaker.png" title="pacemaker工作流"><br>需要注意的是在单个协处理器中只有在第3步执行结束之后，第1步才能再次被执行，否则结果中的数据就会乱序。</p><p>peacemaker中还会记录每个transform处理的offset状态，以便当处理失败时已记录的offset处进行重放，以保证幂等性。</p><blockquote><p>执行引擎(execution engine)</p></blockquote><p>执行引擎有两种，一种是同步函数调用，另一种是基于异步的状态转换。</p><ul><li>同步执行引擎<br>同步执行引擎主要应用在一些简单的数据过滤、数据加密等较为纯粹的数据处理场景下，<code>wasm</code>文件就像调用同步函数那样被执行。其架构如图：</li></ul><p><img src="/blogimgs/wasm-realtime/sync.png" title="同步执行引擎"></p><ul><li>异步执行引擎<br>异步执行引擎主要用于在transform时需要外部依赖或者一些状态的场景中。因为在这些情况下<code>wasm</code>的执行时长是不受控制的，容易造成阻塞，所以在异步执行引擎中会新建一个与原topic分区一摸一样的子分区，这样将producer、transform和consumer解偶，提升数据处理能力。其架构如图：</li></ul><p><img src="/blogimgs/wasm-realtime/async.png" title="异步执行引擎"></p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p><a href="https://redpanda.com/blog/change-data-capture-postgres-debezium-kafka-connect">这里</a>是官方的一个demo，从pg中通过cdc将数据传入Redpanda中，流程较为简单，而且都是基于docker环境的，就不再重复了。</p><!--https://www.youtube.com/watch?v=skzWrp8eU-Yhttps://redpanda.com/blog/data-transformation-engine-with-wasm-runtimehttps://redpanda.com/blog/wasm-architecture--><h2 id="fluvio"><a href="#fluvio" class="headerlink" title="fluvio"></a>fluvio</h2><p>fluvio出自InfinyOn，它也是开源的，可对数据进行实时聚合、关联和可编程。</p><p><img src="/blogimgs/wasm-realtime/fluvio.png" title="fluvio"></p><p>分为4部分，分别为<code>SmartModules</code>、<code>Data Streams</code>、<code>Immutable Store</code>和<code>Clients &amp; Connectors</code>。</p><ul><li><code>SmartModules</code>是可编程模块，可以实时对数据进行清洗、过滤和计算，是用<code>Rust</code>编写然后编译为<code>wasm</code>进行执行。</li><li><code>Data Streams</code>是分布式模块，支持冗余和自动恢复。</li><li><code>Immutable Store</code>是一个持久不变的存储层，用于持久化数据</li><li><code>Clients &amp; Connectors</code>包含一些封装好的API，可以进行生产数据和消费数据，还包括一些已封装好的connector用于连接一些常见数据源，比如pgsql</li></ul><h3 id="fluvio架构"><a href="#fluvio架构" class="headerlink" title="fluvio架构"></a>fluvio架构</h3><p>fluvio由2个组件组成，分别为<code>Streaming Controller(SC)</code>和<code>Streaming Processing Units(SPU)</code>，采用master/worker形式，其架构如图：</p><p><img src="/blogimgs/wasm-realtime/fluvio-arch.png" title="fluvio架构图"></p><p>SC负责SPU的生命周期，包括整个集群各个节点的拓扑图和分布式数据流相关的优化。SPU负责实时数据。SC和SPU是相互独立的，每个服务都可单独重启、升级。</p><h3 id="SmartModules"><a href="#SmartModules" class="headerlink" title="SmartModules"></a>SmartModules</h3><p>SmartModules是开发者可编程的模块，开发者使用Rust语言进行开发，然后将其编译为wasm提交给fluvio，就允许开发者直接控制数据流。<br>目前官方提供的类型有<code>Filter</code>、<code>Map</code>，<code>FilterMap</code>，<code>ArrayMap</code>和<code>Aggregate</code>，不过官方还提供了一个Hub，方便开发者贡献自己的SmartModules和下载所需的非官方SmartModules</p><p>官方也提供了一些Demo，都比较简单，感兴趣的可以自行查看。</p><!-- https://www.infinyon.com/blog/2021/08/smartmodule-aggregates/https://www.infinyon.com/blog/2021/08/smartmodule-map-use-cases/https://www.infinyon.com/blog/2021/06/smartmodule-filters/--><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这两个实时框架都是基于消息队列之上的，都是通过<code>wasm</code>将数据处理功能开发给开发者，其功能有点像Plusar，只不过Plusar是用java语言开发的，其数据处理能力并没有使用<code>wasm</code>，而是使用的是原生java语言，个人感觉可能是因为java语言受众比较广吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着各行各业对实时计算的需求越来越强烈，实时计算领域的竞争也越来越激烈，呈现百花齐放的状态。&lt;/p&gt;
&lt;p&gt;虽说Flink在实时计算领域已坐稳老大哥，但是却也阻挡不了其它实时计算框架在某些细分领域发光。&lt;/p&gt;
&lt;p&gt;本篇主要介绍几款基于wasm的轻量实时计算框架，比如Redpanda、InfinyOn。&lt;/p&gt;</summary>
    
    
    
    <category term="Realtime, BigData" scheme="http://yuanba.tech/categories/Realtime-BigData/"/>
    
    
    <category term="Wasm" scheme="http://yuanba.tech/tags/Wasm/"/>
    
    <category term="Redpanda" scheme="http://yuanba.tech/tags/Redpanda/"/>
    
    <category term="InfinyOn" scheme="http://yuanba.tech/tags/InfinyOn/"/>
    
    <category term="Pulsar" scheme="http://yuanba.tech/tags/Pulsar/"/>
    
    <category term="Realtime" scheme="http://yuanba.tech/tags/Realtime/"/>
    
  </entry>
  
  <entry>
    <title>scratch自定义扩展</title>
    <link href="http://yuanba.tech/scratch-extensions-demo.html"/>
    <id>http://yuanba.tech/scratch-extensions-demo.html</id>
    <published>2021-12-14T14:30:20.000Z</published>
    <updated>2021-12-14T16:10:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>今日想搞一搞scratch，使用过程中发现官方给的扩展组件中有些在国内用不了，所以就想把这个问题给修复下，方便国内用户使用。</p><p>在修复这个问题之前，现熟悉下scratch，以及如何自定义扩展。</p><span id="more"></span><h2 id="scratch"><a href="#scratch" class="headerlink" title="scratch"></a>scratch</h2><p>scratch是MIT开源的少儿编程工具，提供可视化的，积木式编程，降低学习门槛，丰富创作形式。<br>我使用的是scratch3.0，它是由多个模块组成的，与本篇文章涉及比较紧密的是<code>scratch-gui</code>和<code>scratch-vm</code>，其中<code>scratch-gui</code>提供了可视化的操作界面，<code>scratch-vm</code>是提供了运行环境和扩展模块。</p><h2 id="自定义扩展插件"><a href="#自定义扩展插件" class="headerlink" title="自定义扩展插件"></a>自定义扩展插件</h2><h3 id="scratch-vm中的改动"><a href="#scratch-vm中的改动" class="headerlink" title="scratch-vm中的改动"></a>scratch-vm中的改动</h3><p>扩展插件的具体实现在<code>scratch-vm</code>模块中的<code>src/extensions</code>，当前目录中已有一些官方集成的插件，比如翻译、乐高互联相关的插件，每个扩展中都有个<code>index.js</code>文件，这个文件就是该扩展的主要实现入口。</p><p>自定义扩展中可以使用的积木块所在<code>getInfo()</code>方法中定义的，看下翻译扩展中<code>getInfo()</code>方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">getInfo () &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;translate&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: formatMessage(&#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="string">&#x27;translate.categoryName&#x27;</span>,</span><br><span class="line">            <span class="attr">default</span>: <span class="string">&#x27;Translate&#x27;</span>,</span><br><span class="line">            <span class="attr">description</span>: <span class="string">&#x27;Name of extension that adds translate blocks&#x27;</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="attr">blockIconURI</span>: blockIconURI,</span><br><span class="line">        <span class="attr">menuIconURI</span>: menuIconURI,</span><br><span class="line">        <span class="attr">blocks</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">opcode</span>: <span class="string">&#x27;getTranslate&#x27;</span>,</span><br><span class="line">                <span class="attr">text</span>: formatMessage(&#123;</span><br><span class="line">                    <span class="attr">id</span>: <span class="string">&#x27;translate.translateBlock&#x27;</span>,</span><br><span class="line">                    <span class="attr">default</span>: <span class="string">&#x27;translate [WORDS] to [LANGUAGE]&#x27;</span>,</span><br><span class="line">                    <span class="attr">description</span>: <span class="string">&#x27;translate some text to a different language&#x27;</span></span><br><span class="line">                &#125;),</span><br><span class="line">                <span class="attr">blockType</span>: BlockType.REPORTER,</span><br><span class="line">                <span class="attr">arguments</span>: &#123;</span><br><span class="line">                    <span class="attr">WORDS</span>: &#123;</span><br><span class="line">                        <span class="attr">type</span>: ArgumentType.STRING,</span><br><span class="line">                        <span class="attr">defaultValue</span>: formatMessage(&#123;</span><br><span class="line">                            <span class="attr">id</span>: <span class="string">&#x27;translate.defaultTextToTranslate&#x27;</span>,</span><br><span class="line">                            <span class="attr">default</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">                            <span class="attr">description</span>: <span class="string">&#x27;hello: the default text to translate&#x27;</span></span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">LANGUAGE</span>: &#123;</span><br><span class="line">                        <span class="attr">type</span>: ArgumentType.STRING,</span><br><span class="line">                        <span class="attr">menu</span>: <span class="string">&#x27;languages&#x27;</span>,</span><br><span class="line">                        <span class="attr">defaultValue</span>: <span class="built_in">this</span>._randomLanguageCode</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">opcode</span>: <span class="string">&#x27;getViewerLanguage&#x27;</span>,</span><br><span class="line">                <span class="attr">text</span>: formatMessage(&#123;</span><br><span class="line">                    <span class="attr">id</span>: <span class="string">&#x27;translate.viewerLanguage&#x27;</span>,</span><br><span class="line">                    <span class="attr">default</span>: <span class="string">&#x27;language&#x27;</span>,</span><br><span class="line">                    <span class="attr">description</span>: <span class="string">&#x27;the languge of the project viewer&#x27;</span></span><br><span class="line">                &#125;),</span><br><span class="line">                <span class="attr">blockType</span>: BlockType.REPORTER,</span><br><span class="line">                <span class="attr">arguments</span>: &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>blocks</code>对应的值就是积木块类型，<code>opcode</code>是具体某个积木块的实现内容，如果要修改积木块的功能就修改此方法就可以。</p><p>自定义扩展的功能在此实现之后，还需要在<code>src/extension-support/extension-manager.js</code>中注册，这样在编译的时候，将其自定义扩展进行编译，已注册的扩展如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> builtinExtensions = &#123;</span><br><span class="line">    <span class="comment">// This is an example that isn&#x27;t loaded with the other core blocks,</span></span><br><span class="line">    <span class="comment">// but serves as a reference for loading core blocks as extensions.</span></span><br><span class="line">    <span class="attr">coreExample</span>: <span class="function">() =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;../blocks/scratch3_core_example&#x27;</span>),</span><br><span class="line">    <span class="comment">// These are the non-core built-in extensions.</span></span><br><span class="line">    <span class="attr">pen</span>: <span class="function">() =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;../extensions/scratch3_pen&#x27;</span>),</span><br><span class="line">    <span class="attr">wedo2</span>: <span class="function">() =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;../extensions/scratch3_wedo2&#x27;</span>),</span><br><span class="line">    <span class="attr">music</span>: <span class="function">() =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;../extensions/scratch3_music&#x27;</span>),</span><br><span class="line">    <span class="attr">microbit</span>: <span class="function">() =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;../extensions/scratch3_microbit&#x27;</span>),</span><br><span class="line">    <span class="attr">text2speech</span>: <span class="function">() =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;../extensions/scratch3_text2speech&#x27;</span>),</span><br><span class="line">    <span class="attr">translate</span>: <span class="function">() =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;../extensions/scratch3_translate&#x27;</span>),</span><br><span class="line">    <span class="attr">videoSensing</span>: <span class="function">() =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;../extensions/scratch3_video_sensing&#x27;</span>),</span><br><span class="line">    <span class="attr">ev3</span>: <span class="function">() =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;../extensions/scratch3_ev3&#x27;</span>),</span><br><span class="line">    <span class="attr">makeymakey</span>: <span class="function">() =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;../extensions/scratch3_makeymakey&#x27;</span>),</span><br><span class="line">    <span class="attr">boost</span>: <span class="function">() =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;../extensions/scratch3_boost&#x27;</span>),</span><br><span class="line">    <span class="attr">gdxfor</span>: <span class="function">() =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;../extensions/scratch3_gdx_for&#x27;</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="scratch-gui中的改动"><a href="#scratch-gui中的改动" class="headerlink" title="scratch-gui中的改动"></a>scratch-gui中的改动</h3><p>scratch-vm修改结束之后，还需要在<code>scratch-gui</code>中导入该扩展的一些信息与入口，修改<code>/src/lib/libraries/extensions/index.jsx</code>文件，<br>首先导入自定义扩展显示图标，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> translateIconURL <span class="keyword">from</span> <span class="string">&#x27;./translate/translate.png&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> translateInsetIconURL <span class="keyword">from</span> <span class="string">&#x27;./translate/translate-small.png&#x27;</span>;</span><br></pre></td></tr></table></figure><p>其次在<code>export default </code>代码块中增加自定义扩展的一些描述信息，需要注意的是其中的<code>extensionId</code>的值需要与<code>scratch-vm</code>中<code>builtinExtensions</code>的值对应。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span>: (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">FormattedMessage</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">defaultMessage</span>=<span class="string">&quot;Translate&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">description</span>=<span class="string">&quot;Name for the Translate extension&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">id</span>=<span class="string">&quot;gui.extension.translate.name&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        /&gt;</span></span></span><br><span class="line">    ),</span><br><span class="line">    <span class="attr">extensionId</span>: <span class="string">&#x27;translate&#x27;</span>,</span><br><span class="line">    <span class="attr">collaborator</span>: <span class="string">&#x27;YuanbaLab&#x27;</span>,</span><br><span class="line">    <span class="attr">iconURL</span>: translateIconURL,</span><br><span class="line">    <span class="attr">insetIconURL</span>: translateInsetIconURL,</span><br><span class="line">    <span class="attr">description</span>: (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">FormattedMessage</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">defaultMessage</span>=<span class="string">&quot;Translate text into many languages.&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">description</span>=<span class="string">&quot;Description for the Translate extension&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">id</span>=<span class="string">&quot;gui.extension.translate.description&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        /&gt;</span></span></span><br><span class="line">    ),</span><br><span class="line">    <span class="attr">featured</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">internetConnectionRequired</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译调试"><a href="#编译调试" class="headerlink" title="编译调试"></a>编译调试</h3><p>编译调试需要具备node.js环境，安装<code>npm install -g webpack</code>和<code>npm install -g webpack-dev-server</code>。<br>进入<code>scratch-vm</code>项目目录中，执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm link</span><br><span class="line">npm run watch</span><br></pre></td></tr></table></figure><p>然后再开一个终端，进入<code>scratch-gui</code>目录中，执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm link scratch-vm </span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p>没有任何错误信息之后，就可以在<code>http://127.0.0.1:8601/</code>地址使用scratch3.0了。</p><h2 id="编译成桌面程序"><a href="#编译成桌面程序" class="headerlink" title="编译成桌面程序"></a>编译成桌面程序</h2><p>git clone <a href="mailto:&#103;&#x69;&#116;&#x40;&#103;&#105;&#x74;&#x68;&#117;&#98;&#46;&#99;&#111;&#x6d;">&#103;&#x69;&#116;&#x40;&#103;&#105;&#x74;&#x68;&#117;&#98;&#46;&#99;&#111;&#x6d;</a>:hunshenshi/scratch-desktop.git</p><p>cd scratch-gui<br>npm install<br>npm link</p><p>cd scratch-desktop<br>npm install<br>npm link scratch-gui<br>npm run dist</p><p>electron 报错<br>进入 electron目录，执行node install.js</p><p>Cannot find module ‘autoprefixer’”<br>npm install –save autoprefixer@^9.0.1</p><p>将 本地scratch-vm和scratch-gui cp到desktop中   or     npm link scratch-vm scratch-blocks<br>npm run clean &amp;&amp; npm run compile &amp;&amp; npm run doBuild – –mode=dev</p><p>npm run dist # 编译后的安装包Scratch Desktop-3.8.0.AppImage和scratch-desktop_3.8.0_amd64.snap保存在scratch-desktop/dist/文件夹中。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今日想搞一搞scratch，使用过程中发现官方给的扩展组件中有些在国内用不了，所以就想把这个问题给修复下，方便国内用户使用。&lt;/p&gt;
&lt;p&gt;在修复这个问题之前，现熟悉下scratch，以及如何自定义扩展。&lt;/p&gt;</summary>
    
    
    
    <category term="kidsCode" scheme="http://yuanba.tech/categories/kidsCode/"/>
    
    
    <category term="scratch" scheme="http://yuanba.tech/tags/scratch/"/>
    
    <category term="扩展" scheme="http://yuanba.tech/tags/%E6%89%A9%E5%B1%95/"/>
    
    <category term="kidsCode" scheme="http://yuanba.tech/tags/kidsCode/"/>
    
  </entry>
  
  <entry>
    <title>metabase导入IDE调试</title>
    <link href="http://yuanba.tech/metabase-import-ide.html"/>
    <id>http://yuanba.tech/metabase-import-ide.html</id>
    <published>2021-12-13T15:31:22.000Z</published>
    <updated>2021-12-13T15:51:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在调研BI报表相关的工具，最后决定深入调研下metabase，于是就有了这篇文章。</p><p>之所以选择metabase是因为一下几点：</p><ol><li>低门槛，对无sql基础的人员友好</li><li>分析功能较全，支持join</li><li>图表功能OK</li><li>部署方便<br>对于我来说，唯一不足的是它是由clojure开发的，二开成本有点高，这才是这篇文章的诞生的真正原因，因为导入IDE编译成功就用了好几天。        </li></ol><span id="more"></span><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>metabase前端依赖node，后端以来jdk和clojure。</p><blockquote><p>我是在mac环境下的，下面的命令都是基于mac的。</p></blockquote><p>1、安装node<br>之前在电脑上装过node，使用tar安装的，只是版本比较老，于是用tar包升级了node，版本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ cnpm -v</span><br><span class="line">cnpm@7.1.0 </span><br><span class="line">npm@6.14.15 </span><br><span class="line">node@16.13.0 </span><br><span class="line">npminstall@5.2.2 </span><br></pre></td></tr></table></figure><p>2、安装yarn<br>node安装好之后，再安装yarn，安装时要选择全局安装，使用命令<br><code>npm install --global yarn</code></p><p>3、安装jdk<br>jdk的安装只强调一点，<strong>一定要jdk11、jdk11、jdk11</strong></p><p>4、安装clojure<br>利用brew安装<br><code>brew install clojure/tools/clojure</code></p><blockquote><p>由于Clojure也依赖maven，默认的maven源在国内经常无法访问，所以需要替换maven源</p></blockquote><p>在Clojure的安装目录中找到<code>deps.edn</code>，修改内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:mvn/repos &#123;</span><br><span class="line">  &quot;central&quot; &#123;:url &quot;http://maven.aliyun.com/nexus/content/repositories/central/&quot;&#125; </span><br><span class="line">  &quot;clojars&quot; &#123;:url &quot;https://repo.clojars.org/&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在命令行输入<code>clj</code> 或者 <code>clojure</code>，即可进入交互界面。</p><p>5、IDE开发环境设置<br>我使用的是intellij idea，安装插件<code>cursive</code>即可，不过需要注意的是cursive与一些插件有冲突，而且对IDE的版本也有要求。(可以说是为了搞这套环境，我把我的老古董开发环境全都升级了一下。)</p><blockquote><p><code>cursive</code>插件与La Clojure、 clojure-kit、 Leiningen冲突，需要IDE为2018.x, 2019.x, 2020.1 and the 2020.2</p></blockquote><h2 id="本地编译"><a href="#本地编译" class="headerlink" title="本地编译"></a>本地编译</h2><p>1、准备源码<br>从github上clone最新的代码<code>git clone git@github.com:metabase/metabase.git</code><br>clone下来的代码默认上master分支，我切了下分支，切到了最新的release版本，<code>git checkout -b 1.41.2 v1.41.2</code></p><p>2、导入IDE<br>选择File -&gt; Open -&gt; 在metabase目录中选择<code>deps.edn</code> -&gt; Open an Project<br>剩下的就是自动加载依赖。</p><p>3、编译uberjar<br>在metabase_home目录下执行<code>clojure -X:deps prep</code><br>成功之后执行<code>cd modules/drivers &amp;&amp; clojure -X:deps prep</code></p><blockquote><p>以上两个命令执行一次就行</p></blockquote><p>再次到metabase_home目录下，执行<code>./bin/build</code>进行编译，在<code>target/uberjar</code>目录下会出现一个jar包，最后执行<code>java -jar metabase.jar</code>即可启动。</p><h2 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h2><p>在<code>deps.edn</code>中找到程序的入口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:run</span><br><span class="line">&#123;:main-opts [&quot;-m&quot; &quot;metabase.core&quot;]</span><br><span class="line"> :jvm-opts  [&quot;-Dmb.run.mode=dev&quot;</span><br><span class="line">             &quot;-Djava.awt.headless=true&quot;                   ; prevent Java icon from randomly popping up in macOS dock</span><br><span class="line">             &quot;-Dmb.jetty.port=3000&quot;]&#125;</span><br></pre></td></tr></table></figure><p><code>main-opts</code>就是程序的入口，是<code>metabase</code>包的<code>core</code>，相关代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;;; ------------------------------------------------ <span class="type">App</span> <span class="type">Entry</span> <span class="type">Point</span> -------------------------------------------------</span><br><span class="line"></span><br><span class="line">(defn -main</span><br><span class="line">  <span class="string">&quot;Launch Metabase in standalone mode.&quot;</span></span><br><span class="line">  [&amp; [cmd &amp; args]]</span><br><span class="line">  (maybe-enable-tracing)</span><br><span class="line">  (<span class="keyword">if</span> cmd</span><br><span class="line">    (run-cmd cmd args) ; run a command like `java -jar metabase.jar migrate release-locks` or `clojure -<span class="type">M</span>:run migrate release-locks`</span><br><span class="line">    (start-normally))) ; <span class="keyword">with</span> no command line args just start <span class="type">Metabase</span> normally</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这就可以跟读调试代码了。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>接触一个新事物，其过程没有一帆风顺的，这次也不例外，这里记录下遇到的问题及解决方案。<br>1、<strong>方向性错误</strong><br>在着手本地编译时做了些调研工作，网上也有些相关教程，不过这些导入IDE的教程都是基于<code>Leiningen</code>的，metabase之前是基于<code>Leiningen</code>，但是在前段时间从<code>Leiningen</code>切到了<code>tools.deps</code>，这就导致网上所有的教程都过时了。具体信息见<a href="https://github.com/metabase/metabase/wiki/Migrating-from-Leiningen-to-tools.deps">官方信息</a></p><p><code>Leiningen</code>和<code>tools.deps</code>的明显区别是代码中的<code>project.clj</code>文件变成了<code>deps.edn</code>文件(当初傻傻的以为<code>project.clj</code>中project只是个变量呢。。。)</p><p>后来意识到<code>project.clj</code>就是一个文件时，查看源码的提交记录发现了其从<code>Leiningen</code>切到了<code>tools.deps</code>，所以IDE的插件需要变为<code>cursive</code></p><p>2、使用Clojure时maven源报UnknownHostException<br>安装完Clojure之后，验证是否可用时，在终端输入<code>clj</code>，报<code>UnknownHostException: repo.maven.apache.org</code><br>第一感觉去修改本机的maven配置，修改之后依然报同样的错。<br>去Clojure的安装目录中关键字检索<code>repo.maven.apache.org</code>，发现在<code>deps.edn</code>中配置的，改成国内的源即可，具体修改方式见上面的安装步骤。</p><p>3、本地编译报<code>SSL_ERROR_SYSCALL in connection to github.com:443</code><br>是因为github通过http链接时需要安全认证，所以执行<code>git config --global http.sslVerify false</code>关闭，(有时间好用有时间不好用，多次几次，随缘吧)。</p><p>4、运行jar包报错，错误内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021-11-30 00:24:59,891 WARN servicelocator.DefaultPackageScanClassResolver :: Cannot search jar file &#x27;/Users/metabase/target/uberjar/metabase.jar&#x27; for classes due to an IOException: invalid code lengths set</span><br><span class="line">java.util.zip.ZipException: invalid code lengths set</span><br></pre></td></tr></table></figure><p>网上并没有什么解决方案，想到我的代码拉的是master分支，是不是代码的问题，于是切到了最新的release版本，打包之后依然报错。<br>下载了官方release版本的jar包，在本地正常运行，排除代码问题，那问题就出在编译环境上，此时想到<strong>文档上要求jdk版本为11</strong>，升级jdk为11之后，再次打包运行成功。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在调研BI报表相关的工具，最后决定深入调研下metabase，于是就有了这篇文章。&lt;/p&gt;
&lt;p&gt;之所以选择metabase是因为一下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;低门槛，对无sql基础的人员友好&lt;/li&gt;
&lt;li&gt;分析功能较全，支持join&lt;/li&gt;
&lt;li&gt;图表功能OK&lt;/li&gt;
&lt;li&gt;部署方便&lt;br&gt;对于我来说，唯一不足的是它是由clojure开发的，二开成本有点高，这才是这篇文章的诞生的真正原因，因为导入IDE编译成功就用了好几天。        &lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="BigData" scheme="http://yuanba.tech/categories/BigData/"/>
    
    
    <category term="BigData" scheme="http://yuanba.tech/tags/BigData/"/>
    
    <category term="metabase" scheme="http://yuanba.tech/tags/metabase/"/>
    
    <category term="BI" scheme="http://yuanba.tech/tags/BI/"/>
    
  </entry>
  
  <entry>
    <title>Flink Connector调研</title>
    <link href="http://yuanba.tech/flink-connector-example.html"/>
    <id>http://yuanba.tech/flink-connector-example.html</id>
    <published>2021-11-10T14:30:20.000Z</published>
    <updated>2021-11-10T14:51:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇<a href="https://bigdatadecode.top/Flink-standlone-Flinkx.html">Flink standlone模式下Flinkx测试</a>介绍了使用Flinkx同步mysql，但是Flinkx在同步binlog日志时，个人感觉有点不方便，所以就对比下Flink Connector。</p><span id="more"></span><h2 id="Flink-standlone部署"><a href="#Flink-standlone部署" class="headerlink" title="Flink standlone部署"></a>Flink standlone部署</h2><p>部署比较简单，具体可以参考这篇<a href="https://bigdatadecode.top/Flink-standlone-Flinkx.html">Flink standlone模式下Flinkx测试</a></p><h2 id="启动sql-client"><a href="#启动sql-client" class="headerlink" title="启动sql client"></a>启动sql client</h2><p>主要是为了测试下sql功能，所以我就简单采用了sql client模式。<br>在${Flink_HOME}目录执行<code>./bin/sql-client.sh embedded</code>启动sql client</p><h2 id="mysql开启binlog"><a href="#mysql开启binlog" class="headerlink" title="mysql开启binlog"></a>mysql开启binlog</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server_id=1  # 不同节点的server_id必须不同</span><br><span class="line">log_bin=/opt/data/mysql-data/mysql-bin  # binlog日志目录</span><br><span class="line">binlog_format=ROW   </span><br><span class="line">expire_logs_days=30</span><br></pre></td></tr></table></figure><p>重启mysql服务，执行<code>show variables like &#39;%bin%&#39;;</code>检查是否已经开启成功。</p><h2 id="Flink-sql实时同步mysql"><a href="#Flink-sql实时同步mysql" class="headerlink" title="Flink sql实时同步mysql"></a>Flink sql实时同步mysql</h2><p>创建source表，mysql数据源表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> source</span><br><span class="line">(</span><br><span class="line">    id          <span class="type">int</span>,</span><br><span class="line">    name        <span class="type">varchar</span>,</span><br><span class="line">    money       <span class="type">decimal</span>,</span><br><span class="line">    dateone     <span class="type">timestamp</span>,</span><br><span class="line">    age         <span class="type">bigint</span>,</span><br><span class="line">    datethree   <span class="type">timestamp</span>,</span><br><span class="line">    datesix     <span class="type">timestamp</span>,</span><br><span class="line">    phone       <span class="type">bigint</span>,</span><br><span class="line">    wechat      STRING,</span><br><span class="line">    income      <span class="type">decimal</span>,</span><br><span class="line">    birthday    <span class="type">timestamp</span>,</span><br><span class="line">    dtdate      <span class="type">date</span>,</span><br><span class="line">    dttime      <span class="type">time</span>,</span><br><span class="line">    today       <span class="type">date</span>,</span><br><span class="line">    timecurrent <span class="type">time</span>,</span><br><span class="line">    aboolean    <span class="type">boolean</span>,</span><br><span class="line">    adouble     <span class="keyword">double</span>,</span><br><span class="line">    afloat      <span class="type">float</span>,</span><br><span class="line">    achar       <span class="type">char</span>,</span><br><span class="line">    abinary     BYTES,</span><br><span class="line">    atinyint    tinyint</span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">      <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;mysql-cdc&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;hostname&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;192.168.2.1&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;port&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;3306&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;username&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;password&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;root@321&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;database-name&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;table-name&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;flink_type&#x27;</span></span><br><span class="line">      );</span><br></pre></td></tr></table></figure><p>创建sink表，这里为了顺便测试下connector连mysql，所以sink到mysql中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mysql_sink</span><br><span class="line">(</span><br><span class="line">    id          <span class="type">int</span>,</span><br><span class="line">    name        <span class="type">varchar</span>,</span><br><span class="line">    money       <span class="type">decimal</span>,</span><br><span class="line">    dateone     <span class="type">timestamp</span>,</span><br><span class="line">    age         <span class="type">bigint</span>,</span><br><span class="line">    datethree   <span class="type">timestamp</span>,</span><br><span class="line">    datesix     <span class="type">timestamp</span>,</span><br><span class="line">    phone       <span class="type">bigint</span>,</span><br><span class="line">    wechat      STRING,</span><br><span class="line">    income      <span class="type">decimal</span>,</span><br><span class="line">    birthday    <span class="type">timestamp</span>,</span><br><span class="line">    dtdate      <span class="type">date</span>,</span><br><span class="line">    dttime      <span class="type">time</span>,</span><br><span class="line">    today       <span class="type">date</span>,</span><br><span class="line">    timecurrent <span class="type">time</span>,</span><br><span class="line">    aboolean    <span class="type">boolean</span>,</span><br><span class="line">    adouble     <span class="keyword">double</span>,</span><br><span class="line">    afloat      <span class="type">float</span>,</span><br><span class="line">    achar       <span class="type">char</span>,</span><br><span class="line">    abinary     BYTES,</span><br><span class="line">    atinyint    tinyint,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id) <span class="keyword">NOT</span> ENFORCED <span class="comment">-- 增量时，必须指定主键</span></span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">      <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;jdbc&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;driver&#x27;</span><span class="operator">=</span><span class="string">&#x27;com.mysql.jdbc.Driver&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;url&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;jdbc:mysql://192.168.2.1:3306/test?useUnicode=true&amp;characterEncoding=utf8&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;table-name&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;flink_type_cp&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;username&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;password&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;root@321&#x27;</span></span><br><span class="line">      );</span><br></pre></td></tr></table></figure><p>通过sql insert到sink表中，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mysql_sink</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> source u;</span><br></pre></td></tr></table></figure><p>执行完这个语句之后，任务会提交到flink集群，在源表中修改表内容之后，会实时同步到目标表中。</p><p>具体使用方式请参考以下内容<br><a href="https://ververica.github.io/flink-cdc-connectors/master/content/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/mysql-postgres-tutorial-zh.html">Flink CDC</a><br><a href="https://ci.apache.org/projects/flink/flink-docs-master/zh/docs/connectors/table/jdbc/">Flink jdbc</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇&lt;a href=&quot;https://bigdatadecode.top/Flink-standlone-Flinkx.html&quot;&gt;Flink standlone模式下Flinkx测试&lt;/a&gt;介绍了使用Flinkx同步mysql，但是Flinkx在同步binlog日志时，个人感觉有点不方便，所以就对比下Flink Connector。&lt;/p&gt;</summary>
    
    
    
    <category term="Flink" scheme="http://yuanba.tech/categories/Flink/"/>
    
    
    <category term="BigData" scheme="http://yuanba.tech/tags/BigData/"/>
    
    <category term="Flink" scheme="http://yuanba.tech/tags/Flink/"/>
    
    <category term="Connector" scheme="http://yuanba.tech/tags/Connector/"/>
    
    <category term="CDC" scheme="http://yuanba.tech/tags/CDC/"/>
    
  </entry>
  
  <entry>
    <title>Flink standlone模式下Flinkx测试</title>
    <link href="http://yuanba.tech/Flink-standlone-Flinkx.html"/>
    <id>http://yuanba.tech/Flink-standlone-Flinkx.html</id>
    <published>2021-11-06T15:05:20.000Z</published>
    <updated>2021-11-06T15:55:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>FlinkX是一个基于Flink的批流统一的数据同步工具，既可以采集静态的数据，比如MySQL，HDFS等，也可以采集实时变化的数据，比如MySQL binlog，Kafka等。 同时，FlinkX也是支持原生FlinkSql所有语法和特性的计算框架，具体使用方式可以参考<a href="https://github.com/DTStack/flinkx">github上的项目介绍</a></p><p>本篇记录下在Flink standlone模式下使用Flinx同步mysql数据。</p><span id="more"></span><h2 id="Flink部署standlone模式"><a href="#Flink部署standlone模式" class="headerlink" title="Flink部署standlone模式"></a>Flink部署standlone模式</h2><p>下载flink-1.12.2版本（因为flinkx使用的是1.12版本），简单配置下即可。修改内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vim masters</span><br><span class="line">127.0.0.1</span><br><span class="line"></span><br><span class="line">vim workers</span><br><span class="line">127.0.0.1</span><br><span class="line"></span><br><span class="line">vim flink-conf.yaml</span><br><span class="line">jobmanager.rpc.address: 127.0.0.1</span><br><span class="line">jobmanager.rpc.port: 6124 # 6123端口可能会冲突，改成6124</span><br><span class="line">jobmanager.memory.process.size: 5120m</span><br><span class="line">taskmanager.memory.process.size: 10240m</span><br><span class="line">taskmanager.numberOfTaskSlots: 2  </span><br><span class="line">parallelism.default: 1 </span><br><span class="line"></span><br><span class="line">bin/jobmanager.sh start</span><br><span class="line">bin/taskmanager.sh start # 也可直接执行bin/start-cluster.sh</span><br></pre></td></tr></table></figure><p>Flink standlone模式部署是不是很简单，下面部署Flinkx</p><h2 id="编译Flinkx"><a href="#编译Flinkx" class="headerlink" title="编译Flinkx"></a>编译Flinkx</h2><p>从github上下载了最新release版本，发现目录结构和文档中的不一样，所以就下载了源码进行编译。</p><p>由于flinkx支持的connector较多，编译时间较长，而且有些jar包仓库中也没有，需要一些额外的操作，所以我注释了些connector，可以在<code>flinkx/flinkx-connectors/pom.xml</code>文件中注释。</p><p>编译命令为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -DskipTests </span><br></pre></td></tr></table></figure><p>编译之后的目录结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--   1 test test    11K 10 21 11:26 LICENSE</span><br><span class="line">-rw-r--r--   1 test test   7.1K 10 21 11:26 README.md</span><br><span class="line">-rw-r--r--   1 test test   9.1K 10 21 11:26 README_CH.md</span><br><span class="line">drwxr-xr-x   5 test test   160B 11  3 13:02 bin</span><br><span class="line">drwxr-xr-x   3 test test    96B 10 21 14:36 build</span><br><span class="line">drwxr-xr-x   4 test test   128B 10 21 11:26 ci</span><br><span class="line">drwxr-xr-x  17 test test   544B 10 21 11:26 docs</span><br><span class="line">drwxr-xr-x   7 test test   224B 11  3 09:41 flinkx-clients</span><br><span class="line">drwxr-xr-x  41 test test   1.3K 10 22 16:25 flinkx-connectors</span><br><span class="line">drwxr-xr-x   7 test test   224B 11  3 09:39 flinkx-core</span><br><span class="line">drwxr-xr-x   6 test test   192B 10 22 16:10 flinkx-dirtydata-collectors</span><br><span class="line">drwxr-xr-x   6 test test   192B 11  3 09:40 flinkx-dist                    ## 编译之后的目录</span><br><span class="line">drwxr-xr-x   6 test test   192B 11  3 09:41 flinkx-docker</span><br><span class="line">drwxr-xr-x   4 test test   128B 10 21 11:26 flinkx-examples</span><br><span class="line">drwxr-xr-x   4 test test   128B 10 22 16:10 flinkx-formats</span><br><span class="line">drwxr-xr-x   4 test test   128B 10 21 11:26 flinkx-local-test</span><br><span class="line">drwxr-xr-x   7 test test   224B 10 22 16:10 flinkx-metrics</span><br><span class="line">-rw-r--r--   1 test test   1.9K 10 22 16:10 flinkx-parent.iml</span><br><span class="line">drwxr-xr-x  12 test test   384B 10 21 11:26 jars</span><br><span class="line">drwxr-xr-x   3 test test    96B 10 22 16:31 lib</span><br><span class="line">-rw-r--r--   1 test test   627B 10 21 11:26 license.txt</span><br><span class="line">-rw-------   1 test test    98K 10 22 18:07 nohup.out</span><br><span class="line">-rw-r--r--   1 test test   6.7K 10 21 11:26 pom.xml</span><br></pre></td></tr></table></figure><h2 id="Flinkx-json模式批量同步mysql表"><a href="#Flinkx-json模式批量同步mysql表" class="headerlink" title="Flinkx json模式批量同步mysql表"></a>Flinkx json模式批量同步mysql表</h2><p>Flinkx同步mysql表有两种方式，一种是job，另一种是sql。job形式需要配置一个json文件，主要是需要同步的库表信息，内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;job&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;content&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;reader&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;mysqlreader&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;column&quot;</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;id&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;varchar&quot;</span></span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;varchar&quot;</span></span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;category&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;varchar&quot;</span></span><br><span class="line">              &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;root@321&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;connection&quot;</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;jdbcUrl&quot;</span>: [</span><br><span class="line">                  <span class="string">&quot;jdbc:mysql://192.168.0.1:3306/test?useSSL=false&quot;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">&quot;table&quot;</span>: [</span><br><span class="line">                  <span class="string">&quot;t&quot;</span></span><br><span class="line">                ]</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;writer&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;mysqlwriter&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;root@321&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;connection&quot;</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;jdbcUrl&quot;</span>: <span class="string">&quot;jdbc:mysql://192.168.0.1:3306/test1?useSSL=false&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;table&quot;</span>: [</span><br><span class="line">                  <span class="string">&quot;t_1&quot;</span></span><br><span class="line">                ]</span><br><span class="line">              &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;writeMode&quot;</span>: <span class="string">&quot;insert&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;column&quot;</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;id&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;varchar&quot;</span></span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;varchar&quot;</span></span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;category&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;varchar&quot;</span></span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;setting&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;speed&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;channel&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;bytes&quot;</span>: <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在Flinx的home目录中执行job启动命令，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/flinkx -mode standalone -jobType sync -job /$&#123;FLINKX_HOME&#125;/flinkx-examples/json/mysql/mysql_mysql_batch.json -flinkxDistDir flinkx-dist -flinkConfDir $FLINK_HOME/conf -confProp &quot;&#123;\&quot;flink.checkpoint.interval\&quot;:60000&#125;&quot;</span><br></pre></td></tr></table></figure><p>任务很顺利的执行结束，下面看使用sql如何同步mysql表。</p><h2 id="Flinkx-sql模式同步mysql表"><a href="#Flinkx-sql模式同步mysql表" class="headerlink" title="Flinkx sql模式同步mysql表"></a>Flinkx sql模式同步mysql表</h2><p>在<code>flinkx-examples</code>下面有很多例子，这里执行下sql实时增量同步mysql，sql为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> source</span><br><span class="line">(</span><br><span class="line">    id          <span class="type">int</span>,</span><br><span class="line">    name        <span class="type">varchar</span>,</span><br><span class="line">    money       <span class="type">decimal</span>,</span><br><span class="line">    dateone     <span class="type">timestamp</span>,</span><br><span class="line">    age         <span class="type">bigint</span>,</span><br><span class="line">    datethree   <span class="type">timestamp</span>,</span><br><span class="line">    datesix     <span class="type">timestamp</span>,</span><br><span class="line">    phone       <span class="type">bigint</span>,</span><br><span class="line">    wechat      STRING,</span><br><span class="line">    income      <span class="type">decimal</span>,</span><br><span class="line">    birthday    <span class="type">timestamp</span>,</span><br><span class="line">    dtdate      <span class="type">date</span>,</span><br><span class="line">    dttime      <span class="type">time</span>,</span><br><span class="line">    today       <span class="type">date</span>,</span><br><span class="line">    timecurrent <span class="type">time</span>,</span><br><span class="line">    aboolean    <span class="type">boolean</span>,</span><br><span class="line">    adouble     <span class="keyword">double</span>,</span><br><span class="line">    afloat      <span class="type">float</span>,</span><br><span class="line">    achar       <span class="type">char</span>,</span><br><span class="line">    abinary     BYTES,</span><br><span class="line">    atinyint    tinyint</span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">      <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;mysql-x&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;url&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;jdbc:mysql://192.168.0.1:3306/test&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;table-name&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;flink_type&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;username&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;password&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;Shujupingtai@321&#x27;</span></span><br><span class="line"></span><br><span class="line">      ,<span class="string">&#x27;scan.polling-interval&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;3000&#x27;</span> <span class="comment">--间隔轮训时间。非必填(不填为离线任务)，无默认</span></span><br><span class="line"></span><br><span class="line">      ,<span class="string">&#x27;scan.parallelism&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="comment">-- 并行度</span></span><br><span class="line">      ,<span class="string">&#x27;scan.fetch-size&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;2&#x27;</span> <span class="comment">-- 每次从数据库中fetch大小。默认：1024条</span></span><br><span class="line">      ,<span class="string">&#x27;scan.query-timeout&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;10&#x27;</span> <span class="comment">-- 数据库连接超时时间。默认：不超时</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">-- ,&#x27;scan.partition.column&#x27; = &#x27;id&#x27; -- 多并行度读取的切分字段，必须是表中字段。无默认</span></span><br><span class="line">      <span class="comment">-- ,&#x27;scan.partition.strategy&#x27; = &#x27;range&#x27; -- 数据分片策略。默认：range，如果并行度大于1，且是增量任务或者间隔轮询，则会使用mod分片</span></span><br><span class="line"></span><br><span class="line">      ,<span class="string">&#x27;scan.increment.column&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;id&#x27;</span> <span class="comment">-- 增量字段名称，必须是表中的字段。非必填，无默认</span></span><br><span class="line">      ,<span class="string">&#x27;scan.increment.column-type&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;int&#x27;</span>  <span class="comment">-- 增量字段类型。非必填，无默认</span></span><br><span class="line">      ,<span class="string">&#x27;scan.start-location&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;10&#x27;</span> <span class="comment">-- 增量字段开始位置,如果不指定则先同步所有，然后在增量。非必填，无默认。如果没配置scan.increment.column，则不生效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--       ,&#x27;scan.restore.columnname&#x27; = &#x27;id&#x27; -- 开启了cp，任务从sp/cp续跑字段名称。如果续跑，则会覆盖scan.start-location开始位置，从续跑点开始。非必填，无默认</span></span><br><span class="line"><span class="comment">--       ,&#x27;scan.restore.columntype&#x27; = &#x27;int&#x27; -- 开启了cp，任务从sp/cp续跑字段类型。非必填，无默认</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sink</span><br><span class="line">(</span><br><span class="line">    id          <span class="type">int</span>,</span><br><span class="line">    name        <span class="type">varchar</span>,</span><br><span class="line">    money       <span class="type">decimal</span>,</span><br><span class="line">    dateone     <span class="type">timestamp</span>,</span><br><span class="line">    age         <span class="type">bigint</span>,</span><br><span class="line">    datethree   <span class="type">timestamp</span>,</span><br><span class="line">    datesix     <span class="type">timestamp</span>,</span><br><span class="line">    phone       <span class="type">bigint</span>,</span><br><span class="line">    wechat      STRING,</span><br><span class="line">    income      <span class="type">decimal</span>,</span><br><span class="line">    birthday    <span class="type">timestamp</span>,</span><br><span class="line">    dtdate      <span class="type">date</span>,</span><br><span class="line">    dttime      <span class="type">time</span>,</span><br><span class="line">    today       <span class="type">date</span>,</span><br><span class="line">    timecurrent <span class="type">time</span>,</span><br><span class="line">    aboolean    <span class="type">boolean</span>,</span><br><span class="line">    adouble     <span class="keyword">double</span>,</span><br><span class="line">    afloat      <span class="type">float</span>,</span><br><span class="line">    achar       <span class="type">char</span>,</span><br><span class="line">    abinary     BYTES,</span><br><span class="line">    atinyint    tinyint</span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">      <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;stream-x&#x27;</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sink</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> source;</span><br></pre></td></tr></table></figure><p>在Flinx的home目录中执行sql执行命令，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/finkx -mode standalone -jobType sql -job /$&#123;FLINKX_HOME&#125;/flinkx-examples/sql/mysql/mysql_source_realtime.sql -flinkxDistDir flinkx-dist -flinkConfDir /Users/hunhun/dev/flink/conf -confProp &quot;&#123;\&quot;flink.checkpoint.interval\&quot;:60000&#125;&quot;</span><br></pre></td></tr></table></figure><p>提交之后，提示job失败，报错信息为找不到类，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassNotFoundException：com.dtstack.flinkx.metrics.prometheus.PrometheusReport</span><br></pre></td></tr></table></figure><p>将<code>flinkx-dist/metrics/prometheus</code>目录下的<code>flinkx-metrics-prometheus-master.jar</code>放到flink的lib目录下，重启flink集群，再次提交又提示<code>com.dtstack.flinkx.conf.MetricParam</code>类找不到，将<code>flinkx-core-master.jar</code>包放到flink的lib下，重启之后依然报找不到类，应该是类加载冲突了。</p><p>再看报错信息是将<code>metrics</code>上报到<code>prometheus</code>时，找不到相关的类，那禁止上报就可以了，而且我也没有配置相关的信息，难道是默认配置的？而且json模式下并没有触发这个错误。</p><p>于是对比下sql和json这两个任务的区别(<em>为什么对比呢？是因为我没有找到禁止metrics上报到prometheus的配置。。。</em>)，发现sql是增量拉取表，于是将sql中的增量拉取配置注释掉：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--       ,&#x27;scan.polling-interval&#x27; = &#x27;3000&#x27; --间隔轮训时间。非必填(不填为离线任务)，无默认</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--       ,&#x27;scan.increment.column&#x27; = &#x27;id&#x27; -- 增量字段名称，必须是表中的字段。非必填，无默认</span></span><br><span class="line"><span class="comment">--       ,&#x27;scan.increment.column-type&#x27; = &#x27;int&#x27;  -- 增量字段类型。非必填，无默认</span></span><br><span class="line"><span class="comment">--       ,&#x27;scan.start-location&#x27; = &#x27;10&#x27; -- 增量字段开始位置,如果不指定则先同步所有，然后在增量。非必填，无默认。如果没配置scan.increment.column，则不生效</span></span><br></pre></td></tr></table></figure><p>注释掉再次提交，任务运行成功了。</p><p>由此推断并不是sql默认会上报prometheus，而是增量拉取时触发了上报的逻辑，那接下来跟下代码，看下具体逻辑是什么，是否可以找到对应的配置项进行调整。</p><p>从错误日志中定位<code>BaseRichInputFormat</code>类的<code>175</code>行附近，看到当<code>useCustomReporter</code>为true时，会自定义metrics上报逻辑，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (useCustomReporter()) &#123;</span><br><span class="line">    customReporter =</span><br><span class="line">            DataSyncFactoryUtil.discoverMetric(</span><br><span class="line">                    config, getRuntimeContext(), makeTaskFailedWhenReportFailed());</span><br><span class="line">    customReporter.open();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在<code>BaseRichInputFormat</code>类中，<code>useCustomReporter</code>为false，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** BaseRichInputFormat.class */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">useCustomReporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在返回true，应该是在其子类中被重写了，定位<code>JdbcInputFormat</code>子类，发现<code>useCustomReporter</code>的值与<code>jdbcConf.isIncrement()</code>绑定在一起了，当job是增量任务时，则<code>useCustomReporter</code>为true，这也解释了为什么sql的增量任务报错，而批量任务不报错。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">useCustomReporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jdbcConf.isIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么有这个逻辑，不太好揣摩其用途，不过将其改成false，不会影响主流程，遂将其修改成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">useCustomReporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    return jdbcConf.isIncrement();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先别着急编译打包运行，还有一处需要修改，在<code>initMetric</code>方法中的<code>customReporter</code>处增加判断逻辑，当<code>customReporter</code>为<code>true</code>时，进行设置，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initMetric</span><span class="params">(InputSplit inputSplit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!jdbcConf.isIncrement()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加customReporter相关的判断，</span></span><br><span class="line">    <span class="keyword">if</span> (useCustomReporter()) &#123;</span><br><span class="line">        customReporter.registerMetric(startLocationAccumulator, Metrics.START_LOCATION);</span><br><span class="line">        customReporter.registerMetric(endLocationAccumulator, Metrics.END_LOCATION);</span><br><span class="line">    &#125;</span><br><span class="line">    getRuntimeContext().addAccumulator(start, startLocationAccumulator);</span><br><span class="line">    getRuntimeContext().addAccumulator(end, endLocationAccumulator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次可以打包，提交sql任务了。</p><h2 id="Flinkx-sql模式binlog同步mysql表"><a href="#Flinkx-sql模式binlog同步mysql表" class="headerlink" title="Flinkx sql模式binlog同步mysql表"></a>Flinkx sql模式binlog同步mysql表</h2><p>上面的sql增量同步mysql表，从任务配置上可以推断其增量同步的逻辑是周期性的执行sql，通过某个字段来判断哪些是增量数据，这种模式有个明显的缺点就是数据的更新不够实时。<br>我们可以通过订阅mysql的binlog方式(<strong>前提是mysql开启binlog配置</strong>)，实时同步表的变化。其任务配置如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> source</span><br><span class="line">(</span><br><span class="line">    id          <span class="type">int</span>,</span><br><span class="line">    name        <span class="type">varchar</span>,</span><br><span class="line">    money       <span class="type">decimal</span>,</span><br><span class="line">    dateone     <span class="type">timestamp</span>,</span><br><span class="line">    age         <span class="type">bigint</span>,</span><br><span class="line">    datethree   <span class="type">timestamp</span>,</span><br><span class="line">    datesix     <span class="type">timestamp</span>,</span><br><span class="line">    phone       <span class="type">bigint</span>,</span><br><span class="line">    wechat      STRING,</span><br><span class="line">    income      <span class="type">decimal</span>,</span><br><span class="line">    birthday    <span class="type">timestamp</span>,</span><br><span class="line">    dtdate      <span class="type">date</span>,</span><br><span class="line">    dttime      <span class="type">time</span>,</span><br><span class="line">    today       <span class="type">date</span>,</span><br><span class="line">    timecurrent <span class="type">time</span>,</span><br><span class="line">    aboolean    <span class="type">boolean</span>,</span><br><span class="line">    adouble     <span class="keyword">double</span>,</span><br><span class="line">    afloat      <span class="type">float</span>,</span><br><span class="line">    achar       <span class="type">char</span>,</span><br><span class="line">    abinary     BYTES,</span><br><span class="line">    atinyint    tinyint</span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">      <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;binlog-x&#x27;</span></span><br><span class="line">      ,<span class="string">&#x27;username&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span></span><br><span class="line">      ,<span class="string">&#x27;password&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span></span><br><span class="line">      ,<span class="string">&#x27;cat&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;insert,delete,update&#x27;</span></span><br><span class="line">      ,<span class="string">&#x27;url&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;jdbc:mysql://localhost:3306/tudou?useSSL=false&#x27;</span></span><br><span class="line">      ,<span class="string">&#x27;host&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;localhost&#x27;</span>  <span class="comment">--  canal 地址</span></span><br><span class="line">      ,<span class="string">&#x27;port&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;3306&#x27;</span></span><br><span class="line"><span class="comment">--   ,&#x27;journal-name&#x27; = &#x27;mysql-bin.000001&#x27;</span></span><br><span class="line">      ,<span class="string">&#x27;table&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;tudou.type&#x27;</span></span><br><span class="line">      ,<span class="string">&#x27;timestamp-format.standard&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;SQL&#x27;</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sink</span><br><span class="line">(</span><br><span class="line">    id          <span class="type">int</span>,</span><br><span class="line">    name        <span class="type">varchar</span>,</span><br><span class="line">    money       <span class="type">decimal</span>,</span><br><span class="line">    dateone     <span class="type">timestamp</span>,</span><br><span class="line">    age         <span class="type">bigint</span>,</span><br><span class="line">    datethree   <span class="type">timestamp</span>,</span><br><span class="line">    datesix     <span class="type">timestamp</span>,</span><br><span class="line">    phone       <span class="type">bigint</span>,</span><br><span class="line">    wechat      STRING,</span><br><span class="line">    income      <span class="type">decimal</span>,</span><br><span class="line">    birthday    <span class="type">timestamp</span>,</span><br><span class="line">    dtdate      <span class="type">date</span>,</span><br><span class="line">    dttime      <span class="type">time</span>,</span><br><span class="line">    today       <span class="type">date</span>,</span><br><span class="line">    timecurrent <span class="type">time</span>,</span><br><span class="line">    aboolean    <span class="type">boolean</span>,</span><br><span class="line">    adouble     <span class="keyword">double</span>,</span><br><span class="line">    afloat      <span class="type">float</span>,</span><br><span class="line">    achar       <span class="type">char</span>,</span><br><span class="line">    abinary     BYTES,</span><br><span class="line">    atinyint    tinyint</span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">      <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;print&#x27;</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sink</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> source u;</span><br></pre></td></tr></table></figure><p>flinkx的binlog同步需要结合canal，这种方式个人感觉不太方便，组件较多，而且扩展性也较差，没再进行尝试，而打算使用<code>Flink CDC</code>功能进行测试，随后会有一篇文章进行介绍。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>测试使用了flinkx的json模式和sql模式对mysql表进行批量和增量同步，flinkx还支持很多source，功能比较丰富，而且批量同步不管是json模式还是sql模式配置都比较方便而且也比较简单，但是如果想要通过binlog同步mysql的话，就比较麻烦了，需要配合canal，个人感觉不太方便。</p><p>如果对数据的实时性要求不高的话，flinkx可以开箱即用，还是不错的选择。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;FlinkX是一个基于Flink的批流统一的数据同步工具，既可以采集静态的数据，比如MySQL，HDFS等，也可以采集实时变化的数据，比如MySQL binlog，Kafka等。 同时，FlinkX也是支持原生FlinkSql所有语法和特性的计算框架，具体使用方式可以参考&lt;a href=&quot;https://github.com/DTStack/flinkx&quot;&gt;github上的项目介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本篇记录下在Flink standlone模式下使用Flinx同步mysql数据。&lt;/p&gt;</summary>
    
    
    
    <category term="Flink" scheme="http://yuanba.tech/categories/Flink/"/>
    
    
    <category term="BigData" scheme="http://yuanba.tech/tags/BigData/"/>
    
    <category term="Flink" scheme="http://yuanba.tech/tags/Flink/"/>
    
    <category term="Flinkx" scheme="http://yuanba.tech/tags/Flinkx/"/>
    
    <category term="Connector" scheme="http://yuanba.tech/tags/Connector/"/>
    
  </entry>
  
  <entry>
    <title>openGauss极简版安装使用</title>
    <link href="http://yuanba.tech/openGauss-deploy.html"/>
    <id>http://yuanba.tech/openGauss-deploy.html</id>
    <published>2021-05-13T14:35:20.000Z</published>
    <updated>2021-05-13T15:55:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>openGauss是GaussDB的开源版，从<a href="https://opengauss.org/zh/download.html">官网</a>下载即可。</p><p>这里只是为了测试一些基本功能，所以只下载了极简版。下面记录下安装步骤和遇到的问题。</p><span id="more"></span><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>GaussDB安装不能用root用户，先新建一个专用用户<code>gaussdb</code>，执行命令<code>groupadd gaussdb &amp;&amp; useradd -d /home/gaussdb -m gaussdb -g gaussdb</code><br>解压安装包，执行命令<code>tar -jxvf openGauss-2.0.0-CentOS-64bit.tar.bz2 -C gaussdb-2.0.0</code><br>然后进入<code>simpleInstall</code>目录，执行<code>sh install.sh -w xx</code>命令进行安装。</p><p>如果上述流程正常，则GaussDB安装初步完成。但是我没有这么顺利，遇到些问题。</p><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>执行<code>install.sh</code>命令时，报错<code>SEMMNI</code>参数设置不对，错误信息如下：<br><code>On systemwide basis, the maximum number of SEMMNI is not correct. the current SEMMNI value is: 128. Please check it.</code></p><blockquote><p>解决<br>SEMMNI是在<code>/proc/sys/kernel/sem</code>文件中配置的，修改下就好了，需要注意的是修改方式不能直接vim，需要用echo命令写入，否则会写入不成功。<br>执行命令<code>echo 250    32000    32    2048 &gt; /proc/sys/kernel/sem</code></p></blockquote><p>安装成功之后，需要先验证下能否正常使用，比较安装不报错和能正常使用是两回事。</p><p>执行<code>gsql -d postgres -p 5432</code>，其中端口<code>5432</code>是默认端口，具体端口信息可以在<code>$&#123;GAUSSDB_HOME&#125;/data/single_node/postgresql.conf</code>中查看。</p><p>又报错了。。</p><h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p>是openssl的问题，错误信息如下：<br><code>openssl: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory</code></p><blockquote><p>解决<br>执行<code>openssl version</code>查看当前openssl的版本，我的版本是1.0.2，需要先将openssl升级到1.1，如果还报上面的错，在执行如下命令：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/lib64/libssl.so.1.1 /usr/lib64/libssl.so.1.1</span><br><span class="line">ln -s /usr/local/lib64/libcrypto.so.1.1 /usr/lib64/libcrypto.so.1.1</span><br></pre></td></tr></table></figure><p>这个问题解决完就可以正常使用了，一些常用命令有<code>\c</code>切换数据库，<code>\l</code>查看数据库、<code>\dt</code>查看表、<code>\d tablename</code>查看表结构。</p><h2 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h2><p>管理员帐号无法进行远程连接，新建个用户用于测试远程连接功能，新建用户命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER test PASSWORD &#x27;Test@123&#x27;;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 school库赋权给<span class="built_in">test</span>用户</span></span><br><span class="line">GRANT ALL PRIVILEGES ON DATABASE school to test;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 更改<span class="built_in">test</span>角色</span></span><br><span class="line">ALTER ROLE test CREATEDB;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 赋予用户权限</span></span><br><span class="line">GRANT ALL PRIVILEGES To test;</span><br></pre></td></tr></table></figure><p>使用新建的用户连接测试，执行命令<code>gsql -h xx.xx.xx.xx -d school -U test -p 5432 -r</code><br>报错无法连接，报权限错误，执行命令<code>gs_guc set -N all -I all -h &quot;host all test 192.168.xx.xx/32 sha256&quot;</code>，悲催的是又报错了，错误信息如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">realpath(/home/gaussdb/gaussdb-2.0.0/bin/cluster_static_config) failed : 没有那个文件或目录!</span><br><span class="line">The gs_guc run with the following arguments: [gs_guc -N all -I all -h host all jack 192.168.xx.xx/32 sha256 set ].</span><br><span class="line">gs_guc: malloc 0</span><br></pre></td></tr></table></figure><p>之所以没有这个文件是因为极简版中很多命令都没有，比如<code>gs_om</code>。</p><p>极简版少很多命令文件怎么解决，我只能从新安装个企业版？好麻烦。突然想到在搜索<code>gs_guc</code>这个命令的时候，它修改的是<code>pg_hba.conf</code>这个配置文件，我是不是可以绕过<code>gs_guc</code>命令直接修改配置文件就可以解决，立马去实践。</p><p><code>pg_hba.conf</code>在<code>$&#123;GAUSSDB_HOME&#125;/data/single_node</code>中，通过vim修改，增加<code>host    all             all             192.168.xx.xx/32            sha256</code><br>修改完之后重启下服务就行，搞笑的事情发生了，重启服务需要用到<code>gs_om</code>命令，可是没有咋办。。。</p><p>极简版是通过执行<code>install.sh</code>命令进行安装启动的，那么这个里面应该有启动命令，果然发现了，极简版的启停命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gs_ctl start -D /home/gaussdb/gaussdb-2.0.0/data/single_node -Z single_node</span><br><span class="line">gs_ctl stop -D /home/gaussdb/gaussdb-2.0.0/data/single_node -Z single_node</span><br></pre></td></tr></table></figure><p>终于搞定了，可以远程连接了。</p><h2 id="JDBC连接测试"><a href="#JDBC连接测试" class="headerlink" title="JDBC连接测试"></a>JDBC连接测试</h2><p>代码用官方的就行，加个依赖包，官方也提供了。<br>关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建数据库连接</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">GetConnection</span><span class="params">(String username, String passwd)</span> </span>&#123;</span><br><span class="line">    String driver = <span class="string">&quot;org.postgresql.Driver&quot;</span>;</span><br><span class="line">    String sourceURL = <span class="string">&quot;jdbc:postgresql://192.168.xx.xx:5432/school?useUnicode=true&amp;characterEncoding=utf8&quot;</span>;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//加载数据库驱动。</span></span><br><span class="line">        Class.forName(driver).newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建数据库连接。</span></span><br><span class="line">        conn = DriverManager.getConnection(sourceURL, username, passwd);</span><br><span class="line">        System.out.println(<span class="string">&quot;Connection succeed!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> conn;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="幸运之想"><a href="#幸运之想" class="headerlink" title="幸运之想"></a>幸运之想</h2><p>整个安装测试过程比较坎坷但也很幸运，所遇的问题都能比较简单，比较容易搞定。</p><p>安装使用过程中遇到些问题，有的问题比较普遍可以通过搜索引擎解决，但是有些问题比较独特，无法通过搜索引擎解决，此时就需要我们有解决问题的能力，这个能力从何而来，我认为能力是从思路中而来，而思路又是从经验见识中而来。所以呢还是那句老话，遇到问题不要慌，要多想想，要记住一点，问题肯定是能解决的，只是有的问题解决完就没有了，而有的问题解决完一个又会出现N个。</p><p>也许现在说这些都是风凉话，但现在想想如果当时解决远程连接问题时，没有去多想下，可能就直接更换企业版，然后安装部署，遇到新的问题继续解决问题。<br>但是我很庆幸我没有立马去更换企业版，而是多想了一步，并靠着自己的经验把遇到的问题给解决了，节省了一些时间也增加了自己独立解决问题的信心。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;openGauss是GaussDB的开源版，从&lt;a href=&quot;https://opengauss.org/zh/download.html&quot;&gt;官网&lt;/a&gt;下载即可。&lt;/p&gt;
&lt;p&gt;这里只是为了测试一些基本功能，所以只下载了极简版。下面记录下安装步骤和遇到的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="BigData" scheme="http://yuanba.tech/categories/BigData/"/>
    
    
    <category term="BigData" scheme="http://yuanba.tech/tags/BigData/"/>
    
    <category term="GaussDB" scheme="http://yuanba.tech/tags/GaussDB/"/>
    
    <category term="deploy" scheme="http://yuanba.tech/tags/deploy/"/>
    
  </entry>
  
  <entry>
    <title>姗姗来迟的果实</title>
    <link href="http://yuanba.tech/my-book.html"/>
    <id>http://yuanba.tech/my-book.html</id>
    <published>2021-04-26T15:35:20.000Z</published>
    <updated>2021-04-26T15:55:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>2021年也接近一半了，过去的2020年对谁都是不平凡的一年，对我尤是。<br>2020年在各位编辑老师的帮助下，对书进行了微调，终于在2021年要跟读者见面了，虽然整个战线由于疫情原因被拉了很长，但现在心里依然很激动。</p><p>这是一本关于Hadoop 3的书，书的名字叫《Hadoop 3实战指南》</p><span id="more"></span><p>其实本书按原先的计划是打算在2020年跟大家见面的，当时国内并没有关于Hadoop 3的相关书籍，而当时正在搞一些Hadoop 3的事情，所以我就打算把自己对Hadoop 3的理解以及工作之后在从事Hadoop相关工作时积累的经验分享给大家，所以就有了这本书，由于本人能力有限，书中难免会有理解不到位的地方，请各位大佬帮忙指正。</p><p>本书长这个样子，预计5月份在各大电商开售。<br><img src="/blogimgs/my-book/book.png"></p><p>本书目录：<br>第1章 Hadoop<br>    1.1 简介<br>        1.1.1 Hadoop 1.0<br>        1.1.2 Hadoop 2.0<br>    1.2 Hadoop 3.0<br>    1.3 阅读 Hadoop 源码<br>        1.3.1 单元测试<br>        1.3.2 断点调试代码<br>    1.4 小结<br>第2章 HDFS<br>    2.1 HDFS 简介<br>    2.2 解析NameNode中的元数据及其内存结构<br>        2.2.1 解析NameNode中的元数据<br>        2.2.2 解析NameNode的内存结构<br>    2.3 解析NameNode的HA功能<br>        2.3.1 基于QJM的HA<br>        2.3.2 故障转移<br>        2.3.3 多NameNode模式<br>    2.4 HDFS 的 Federation<br>        2.4.1 基于 viewfs 的 Federation<br>        2.4.2 基于Router的Federation<br>    2.5 纠删码<br>        2.5.1 纠删码的原理<br>        2.5.2 HDFS EC<br>        2.5.3 HDFS EC 的实现<br>        2.5.4 对比HDFS EC策略与三副本策略<br>    2.6 下一代对象存储系统Ozone<br>        2.6.1 Ozone 初体验<br>        2.6.2 Ozone 架构<br>    2.7 小结<br>第3章 YARN<br>    3.1 YARN 简介<br>    3.2 解析ResourceManager的HA功能<br>        3.2.1 故障转移<br>        3.2.2 数据恢复<br>    3.3 YARN Federation<br>        3.3.1 架构<br>        3.3.2 Router<br>        3.3.3 State Store和Policy Store<br>        3.3.4 AMRMProxy<br>        3.3.5 跨子集群运行<br>    3.4 中央调度器<br>        3.4.1 Capacity 调度器<br>        3.4.2 Fair 调度器<br>        3.4.3 调度扩展<br>    3.5 分布式调度器<br>        3.5.1 分布式调度器的架构<br>        3.5.2 opportunistic container<br>    3.6 YARN Shared Cache<br>        3.6.1 资源本地化<br>        3.6.2 Shared Cache 的架构<br>        3.6.3 Shared Cache 实例<br>    3.7 小结<br>第4章 Application on YARN<br>    4.1 MapReduce 的简介<br>    4.2 MapReduce 的源码分析<br>        4.2.1 InputSplit<br>        4.2.2 环形缓冲区<br>        4.2.3 溢写和归并<br>        4.2.4 Shuffle<br>    4.3 MapReduce on YARN<br>        4.3.1 YARN 的事件机制和状态机机制<br>        4.3.2 MR ApplicationMaster<br>    4.4 Application on YARN<br>    4.5 小结<br>第5章 实战指南<br>    5.1 Hadoop 3.x 的部署<br>        5.1.1 Hadoop 3.x HA的部署<br>        5.1.2 Hadoop 3.x Federation 的部署<br>    5.2 Hadoop 升级<br>        5.2.1 Hadoop 2.0 升级为 Hadoop 3.0<br>        5.2.2 Hadoop 3.0 降级为 Hadoop 2.0<br>        5.2.3 升级/降级中遇到的问题<br>    5.3 二次开发<br>        5.3.1 与其他自研系统融合<br>        5.3.2 自身功能扩展之自动识别修复后的数据盘<br>        5.3.3 合并社区 Patch<br>        5.3.4 提交PullRequest<br>    5.4 周边系统平台<br>        5.4.1 任务调度平台<br>        5.4.2 监控平台<br>        5.4.3 集群诊断分析平台<br>    5.5 小结</p><p>希望大家多多支持，有什么问题可以随时找我沟通。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2021年也接近一半了，过去的2020年对谁都是不平凡的一年，对我尤是。&lt;br&gt;2020年在各位编辑老师的帮助下，对书进行了微调，终于在2021年要跟读者见面了，虽然整个战线由于疫情原因被拉了很长，但现在心里依然很激动。&lt;/p&gt;
&lt;p&gt;这是一本关于Hadoop 3的书，书的名字叫《Hadoop 3实战指南》&lt;/p&gt;</summary>
    
    
    
    <category term="Hadoop" scheme="http://yuanba.tech/categories/Hadoop/"/>
    
    
    <category term="Hadoop" scheme="http://yuanba.tech/tags/Hadoop/"/>
    
    <category term="BigData" scheme="http://yuanba.tech/tags/BigData/"/>
    
    <category term="YARN" scheme="http://yuanba.tech/tags/YARN/"/>
    
    <category term="HDFS" scheme="http://yuanba.tech/tags/HDFS/"/>
    
  </entry>
  
  <entry>
    <title>坑娃-防沉迷App</title>
    <link href="http://yuanba.tech/android-app-timeup.html"/>
    <id>http://yuanba.tech/android-app-timeup.html</id>
    <published>2021-02-11T02:31:19.000Z</published>
    <updated>2021-02-12T05:30:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>猿爸：屁孩，已经看了很长xx了，该让眼睛休息下了。<br>屁孩：不情不愿的关了，去玩别的。<br>很和谐是不是？当你不在家的时候，屁孩就没这么乖了，是不是，认同不？<br>这时就需要有一个强势的“人”来阻止他，这个可别奢望老人来阻止他，于是只能让“机器人”来搞了。</p><p>于是搞了个App，名字叫<strong>坑娃神器</strong>（不知道若干年后，屁孩看到这个文章心里是什么滋味。。。），功能比较简单，就是监控指定app的活动状态，如果连续运行一段时间，坑娃神器就会自动从后台切到前台进行倒计时，倒计时结束之后可以继续娱乐。</p><p>这个App目前只是处于原始社会版，希望有能力的猿爸们加入，我们一起将其完善，帮助下一代养成一个好的自律能力，此App已在github上开源，欢迎贡献，项目地址<a href="https://github.com/hunshenshi/timeup.git">https://github.com/hunshenshi/timeup.git</a></p><span id="more"></span><h2 id="调研–准备工作"><a href="#调研–准备工作" class="headerlink" title="调研–准备工作"></a>调研–准备工作</h2><p>找了下目前市面已有的工具和一些手机自带的健康使用的功能，不太满足我的需求，<br>1、大多数都是限制每天累计使用时长，而我希望每使用一段时间就休息一会，而不关注累计时长<br>2、由于市面上都是一些面向广大用户的产品，达到时长之后会有提示，而不会有更激烈的行为。而我的需求强硬，再强硬（反正用户只有家长的娃）</p><blockquote><p>我想要的功能也比较简单，就是当检测到前台视频类的软件连续运行一段时间之后，依然在运行，就将其切换到后台，并将倒计时页面切换至前台，等待倒计时结束。随后再次进行下一轮监控，不监控累计时长，只监控连续使用时长，并且强制切换App。</p></blockquote><p>没有现成的轮子那就自己造一个吧，梳理下会用到的技术点：<br>1、App保活，因为需要坑娃神器长期存活于后台进行监控<br>2、如何拿到正在运行的app<br>3、定时执行，需要坑娃神器定期检测前台运行的app是什么<br>4、后台唤醒，需要坑娃神器从后台唤醒到前台进行倒计时</p><p>看了些相关的文章，感觉功能大都可以实现，只是安卓的版本太多了，各种功能在各个版本中实现方式又不一样，在这特别同情搞安卓的朋友，真不容易呀。。。</p><h2 id="第一个Android-Application"><a href="#第一个Android-Application" class="headerlink" title="第一个Android Application"></a>第一个Android Application</h2><p>决定要搞了，那就先从Hello World开始吧，首先下载个Android Studio，然后根据向导创建一个android应用，这里语言我选的是java，一路下来就能运行一个demo app了。具体步骤如下：<br><img src="/blogimgs/android-monitor/app01.png" alt="新建project" title="新建project"><br>新建project之后，进入选择模版页面，这里我选的是basic，下面还有很多模版可以选<br><img src="/blogimgs/android-monitor/app02.png" alt="选择project" title="选择project"><br>选择下一步之后，填写project相关的信息，比如project名字，需要的语言和sdk<br><img src="/blogimgs/android-monitor/app03.png" alt="填写project信息" title="填写project信息"><br>点击Finish就结束了，等待IDE加载程序就行了。</p><p>这个过程可能会比较慢，主要是gradle-5.6.4-all.zip下载慢，你可以使用迅雷下载，然后放到指定的目录就OK了。</p><h2 id="App保活"><a href="#App保活" class="headerlink" title="App保活"></a>App保活</h2><p>App保活这个话题，不搜不知道，一搜是打开眼界呀，充分展现了群众的智慧呀。什么双Activity相互唤醒、播放无声音频各种奇淫巧技。<br>不过我这里就自己用，这么多的奇淫巧技我是用不上了（就算需要用上我也没有那么高深的功力），规规矩矩的申请权限吧。</p><p>常驻后台需要申请电池白名单权限，网上有很多代码示例，相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS);</span><br><span class="line">context.startActivity(intent);</span><br></pre></td></tr></table></figure><h2 id="获取正在运行的App"><a href="#获取正在运行的App" class="headerlink" title="获取正在运行的App"></a>获取正在运行的App</h2><p>如何通过代码拿到正在前台展示的app，也是困难重重，对于一无所知的我依然是先网上搜一堆demo，然后测试。<br>搜素的结果大体分为3种，主要分布在不同的sdk版本中，已经过时的有<code>getRunningTasks</code>和<code>getRunningAppProcesses</code>，在新版sdk中都普遍使用<code>UsageStatsManager</code>，使用<code>UsageStatsManager</code>时需要申请权限，而且通过它获取app的方法网上也有好几种，我对比了几种使用的是<code>queryUsageStats</code>方法，还可以使用<code>queryEvents</code>方法，不过我测试发现<code>queryEvents</code>状态变更没有<code>queryUsageStats</code>及时。（不要问我为什么测试了这么多方法。。）</p><p>整体思路是通过<code>queryUsageStats</code>查询一段时间内的App使用信息，然后对App的最后更新时间进行排序，时间最大的就是正在前台展示的App。代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取UsageStats集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;UsageStats&gt;  <span class="title">getUsageStatsList</span><span class="params">(Context context, <span class="keyword">long</span> startTime, <span class="keyword">long</span> endTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        UsageStatsManager manager = (UsageStatsManager) context.getApplicationContext().getSystemService(Context.USAGE_STATS_SERVICE);</span><br><span class="line">        List&lt;UsageStats&gt;  usageStatses = manager.queryUsageStats(UsageStatsManager.INTERVAL_BEST, startTime, endTime);</span><br><span class="line">        <span class="keyword">if</span> (usageStatses == <span class="keyword">null</span> || usageStatses.size() == <span class="number">0</span>) &#123;<span class="comment">// 没有权限，获取不到数据</span></span><br><span class="line">            Log.i(<span class="string">&quot;AppUtil getUsageStatsList &quot;</span>, <span class="string">&quot;no permission for UsageStatsManager&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> usageStatses;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对最后更新时间进行排序获取前台App</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> UsageStats <span class="title">getForegroundUsageStats</span><span class="params">(Context context, <span class="keyword">long</span> startTime, <span class="keyword">long</span> endTime)</span> </span>&#123;</span><br><span class="line">    UsageStats usageStatsResult = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        List&lt;UsageStats&gt; usageStatses = getUsageStatsList(context, startTime, endTime);</span><br><span class="line">        <span class="keyword">if</span> (usageStatses == <span class="keyword">null</span> || usageStatses.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (UsageStats usageStats : usageStatses) &#123;</span><br><span class="line">            <span class="comment">// 通过反射获取App的事件类型</span></span><br><span class="line">            <span class="keyword">int</span> lastEvent = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Field mLastEventField = UsageStats.class.getField(<span class="string">&quot;mLastEvent&quot;</span>);</span><br><span class="line">                mLastEventField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                lastEvent = mLastEventField.getInt(usageStats);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (usageStatsResult == <span class="keyword">null</span> || usageStatsResult.getLastTimeUsed() &lt; usageStats.getLastTimeUsed()) &#123;</span><br><span class="line">                usageStatsResult = usageStats;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> usageStatsResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定时周期执行任务"><a href="#定时周期执行任务" class="headerlink" title="定时周期执行任务"></a>定时周期执行任务</h2><p>由于这只是个坑娃的App，所以这里直接简单粗暴的使用定时任务来check前台App是否为所要监控的App，而没有使用各种Trigger。<br>Android中的定时任务主要是<code>Timer</code>和<code>AlarmManager</code>，推荐使用<code>AlarmManager</code>，而且不需要申请权限。</p><p><code>AlarmManager</code>结合<code>Service</code>使用，在高版本的sdk中，<code>AlarmManager</code>没有重复执行的功能，需要在<code>Service</code>再次调用<code>AlarmManager</code>从而起到重复执行任务的功能。而且在高版中为了节省电量也进行了很多优化，要想精准出发定时器需要使用<code>setExactAndAllowWhileIdle</code>方法，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);</span><br><span class="line"><span class="comment">// CheckService是定时器触发之后要具体执行的任务逻辑</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(context, CheckService.class);</span><br><span class="line">pendingIntent = PendingIntent.getService(context, <span class="number">0</span>, intent, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// AlarmManager.ELAPSED_REALTIME_WAKEUP是为了能主动唤醒CPU</span></span><br><span class="line">am.setExactAndAllowWhileIdle(AlarmManager.ELAPSED_REALTIME_WAKEUP,</span><br><span class="line">                    SystemClock.elapsedRealtime(), pendingIntent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在CheckService的onStartCommand方法中执行定时任务逻辑，并且执行完之后继续设置定时器，起到重复执行的效果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// check前台App是否为需要监控的App，如果是执行相应的操作</span></span><br><span class="line">        <span class="comment">// 再次调用定时器</span></span><br><span class="line">        am.setExactAndAllowWhileIdle(AlarmManager.ELAPSED_REALTIME_WAKEUP,</span><br><span class="line">                    SystemClock.elapsedRealtime() + TIME_INTERVAL, pendingIntent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意两次调用定时器的不同，在<code>CheckService</code>中调用时Trigger为<code>SystemClock.elapsedRealtime() + TIME_INTERVAL</code>，代表延后<code>TIME_INTERVAL</code>之后触发。</p><h2 id="后台唤醒"><a href="#后台唤醒" class="headerlink" title="后台唤醒"></a>后台唤醒</h2><p>后台唤醒是指正在后台运行的App由于某种原因被切换到前台。</p><p>如果是在低版本的sdk中可以使用<code>getRunningTasks</code>，拿到对应package的task信息，其中包括taskId，然后调用<code>moveTaskToFront</code>方法将其任务切换到前台，但是<code>getRunningTasks</code>已被标注为过时的，所以在上面获取前台App时也没用该方法。</p><p>这里使用了新建Activity的方法，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toRunningForeground</span><span class="params">(String packageNameTarget)</span> </span>&#123;</span><br><span class="line">    PackageManager packageManager = getPackageManager();</span><br><span class="line"></span><br><span class="line">    Intent intent = packageManager.getLaunchIntentForPackage(packageNameTarget);</span><br><span class="line">    intent.addCategory(Intent.CATEGORY_LAUNCHER);</span><br><span class="line">    intent.setFlags(Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED | Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**android.intent.action.MAIN：打开另一程序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    intent.setAction(<span class="string">&quot;android.intent.action.MAIN&quot;</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * FLAG_ACTIVITY_SINGLE_TOP:</span></span><br><span class="line"><span class="comment">     * 如果当前栈顶的activity就是要启动的activity,则不会再启动一个新的activity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);</span><br><span class="line">    activity.startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="踩坑实录"><a href="#踩坑实录" class="headerlink" title="踩坑实录"></a>踩坑实录</h2><p>主要功能开发完成，并在IDE中正常运行，下面就要实机测试了，前方冰冷的洪水迎面拍来！！！</p><p>将App安装到平板上之后，进行测试发现应该切换倒计时页面时并没有正常切换，于是下面就开始了取经之后：</p><ol><li>sdk版本不兼容<br>因为Android sdk各版本有可能不兼容，所以首先怀疑是不是sdk的问题，于是在IDE中设置了对应版本，发现确实没有生效，于是搜索对应sdk后台切换前台的相关问题，发现可能是权限问题，sdk 29之后限制了App的相应权限，需要申请浮窗权限，申请代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestOverlayPermission</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION);</span><br><span class="line">    context.startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>获取当前App<br>申请相应权限之后，在IDE中可以正常运行，再次部署到平板上进行测试，发现依然没有生效，继续排查。<br>在IDE中多次排查时偶然发现获取当前App时，有次拿到了<code>com.xx.android.launcher</code>，以为是获取前台App不准确原因造成的，于是就用了好多种方法进行测试，发现始终未生效。但是在真机测试的过程中，发现一个规律，<strong>只要插上usb，App就运行正常</strong>，在IDE中查看App在平板上的运行日志也正常，可是拔掉usb就不生效，也看不到当时的日志，于是就想打印些关键信息在平板上查看进行排查问题。</p></li><li><p>真机上查看运行日志<br>看一些日志教程好复杂，专门搞一下真的不值得呀，于是想到是不是可以把关系信息写到一个可读的文件里，于是将其写入，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">(Context context, String filename, String filecontent)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileOutputStream output = context.openFileOutput(filename, Context.MODE_APPEND);</span><br><span class="line">    output.write(filecontent.getBytes());</span><br><span class="line">    output.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用时只传入文件名就行，默认写到<code>/data/data/app/com.xx/files</code>目录下，去平板上找这个目录，却没有找到。。。不过连上usb可以在IDE的<code>Device File Explorer</code>中找到，于是再次的测试流程就是拔掉usb进行测试，然后连上usb进行文件查看运行信息。</p></li><li><p>怀疑AlarmManger在后台不生效<br>查看App写入文件的信息之后，发现定时器只是第一次启动了，随后的定时器并未触发。<br>在使用<code>AlarmManger</code>时也没有要求申请什么权限，搜索之后也没有找到任何线索，于是资源一些专业人士，朋友说可能是定时器触发间隔时间太短，系统给优化了，并附上了源码中的方法注释，可信度很高呀，我也很开心，要搞定了，可是修改安装之后依然是暴击呀。</p></li></ol><p>此时真的陷入了死胡同，没有任何线索，一连好几天没有任何进展，偶然在手机上查看应用权限的时候，想到是不是平板自动启停的原因，于是将App的自动管理切换为手动管理，再次进行测试，生效了。</p><p>太艰辛了，为了坑个娃太不容易了。。。</p><p>这个App目前只是处于原始社会版，希望有能力的猿爸们加入，我们一起将其完善，帮助下一代养成一个好的自律能力，此App已在github上开源，欢迎贡献，项目地址<a href="https://github.com/hunshenshi/timeup.git">https://github.com/hunshenshi/timeup.git</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>其实写这个App并不完全是为了完全阻止他玩平板，只是为了培养他解决问题，善于思考的能力，让他知道如何去达到自己的目的。因为这个App本身比较简单，可能只能阻止他几天，然后他会发现这个App的逻辑漏洞，然后我再想办法把这个漏洞堵上，继续等待他发现新的漏洞，希望在这个过程中能培养他的好奇欲。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;猿爸：屁孩，已经看了很长xx了，该让眼睛休息下了。&lt;br&gt;屁孩：不情不愿的关了，去玩别的。&lt;br&gt;很和谐是不是？当你不在家的时候，屁孩就没这么乖了，是不是，认同不？&lt;br&gt;这时就需要有一个强势的“人”来阻止他，这个可别奢望老人来阻止他，于是只能让“机器人”来搞了。&lt;/p&gt;
&lt;p&gt;于是搞了个App，名字叫&lt;strong&gt;坑娃神器&lt;/strong&gt;（不知道若干年后，屁孩看到这个文章心里是什么滋味。。。），功能比较简单，就是监控指定app的活动状态，如果连续运行一段时间，坑娃神器就会自动从后台切到前台进行倒计时，倒计时结束之后可以继续娱乐。&lt;/p&gt;
&lt;p&gt;这个App目前只是处于原始社会版，希望有能力的猿爸们加入，我们一起将其完善，帮助下一代养成一个好的自律能力，此App已在github上开源，欢迎贡献，项目地址&lt;a href=&quot;https://github.com/hunshenshi/timeup.git&quot;&gt;https://github.com/hunshenshi/timeup.git&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="tool" scheme="http://yuanba.tech/categories/tool/"/>
    
    
    <category term="android" scheme="http://yuanba.tech/tags/android/"/>
    
    <category term="app" scheme="http://yuanba.tech/tags/app/"/>
    
    <category term="防沉迷" scheme="http://yuanba.tech/tags/%E9%98%B2%E6%B2%89%E8%BF%B7/"/>
    
    <category term="生活" scheme="http://yuanba.tech/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch运维踩坑</title>
    <link href="http://yuanba.tech/elasticsearch-op.html"/>
    <id>http://yuanba.tech/elasticsearch-op.html</id>
    <published>2020-08-03T03:33:12.000Z</published>
    <updated>2020-08-03T03:33:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>接触ES也小半年了，ES虽然使用方便，运维简单但是集群规模和数据量大的话运维也很头疼，这里梳理下这半年的运维经验。</p><span id="more"></span><h2 id="磁盘坑"><a href="#磁盘坑" class="headerlink" title="磁盘坑"></a>磁盘坑</h2><p>集群随着使用，数据会积累越来越多，磁盘消耗也会越来越大，此时为了保护某个磁盘被写满，需要给磁盘设置阈值，配置项为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 磁盘使用超过此值，将不再接受shard的均衡，只接受主shard的写入</span></span><br><span class="line">cluster.routing.allocation.disk.watermark.low</span><br><span class="line"><span class="comment"># 磁盘使用超过此值，磁盘上的shard开始向其他磁盘迁移，释放磁盘空间</span></span><br><span class="line">cluster.routing.allocation.disk.watermark.high</span><br><span class="line"><span class="comment"># 磁盘使用超过此值，节点将不再提供服务</span></span><br><span class="line">cluster.routing.allocation.disk.watermark.flood_stage</span><br></pre></td></tr></table></figure><p>配置项值的默认形式是百分比，也可以是绝对值。<br>如果集群进行了扩容，各个机器的磁盘大小不一，此时依然使用百分比的话对磁盘大机器就会造成存储空间浪费，将百分比改为绝对值可以充分使用各个不同大小的磁盘。</p><h2 id="shard重新分配"><a href="#shard重新分配" class="headerlink" title="shard重新分配"></a>shard重新分配</h2><p>集群中某个DataNode实例挂掉或者集群中某个磁盘的使用率达到上线，就需要对shard进行重新分配，有几个配置项可以对其调整，加快分配的速度，配置项为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实例用来控制接收和分发shard的线程数</span></span><br><span class="line">cluster.routing.allocation.node_concurrent_recoveries</span><br><span class="line"><span class="comment"># 控制从本地恢复主分片的线程数</span></span><br><span class="line">cluster.routing.allocation.node_initial_primaries_recoveries</span><br></pre></td></tr></table></figure><p><code>node_concurrent_recoveries</code>不宜设置的太大，如果集群规模没有超过百台，设置为DataNode实例个数的一半即可。<br><code>node_initial_primaries_recoveries</code>此值可根据机器配置进行设置即可。</p><h2 id="重启坑"><a href="#重启坑" class="headerlink" title="重启坑"></a>重启坑</h2><p>当集群实例宕机出现雪崩无法恢复时，需要重启集群进行恢复。但是由于ES重启之后需要加载所有索引的shard之后集群才可正常使用，而ES会自动对索引shard根据现有的集群状态对shard进行重分配，这个分配过程是比较耗时而且针对<strong>集群重启</strong>的场景是没有意义的，因为集群只是重启，shard并没有丢失。<br>所以在集群重启之时可以将<code>cluster.routing.allocation.enable</code>设置为none，等所有的DataNode实例启动之后再将其设置为all。</p><h2 id="大查询"><a href="#大查询" class="headerlink" title="大查询"></a>大查询</h2><p>数据查询量大，会触发ES的内存保护机制进行熔断，可以增加单独的查询客户端，并增加客户端实例的内存。随后设置集群配置，配置项为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># </span></span><br><span class="line">indices.breaker.total.limit</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">indices.breaker.fielddata.limit</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">indices.breaker.request.limit</span><br></pre></td></tr></table></figure><h2 id="排查问题工具"><a href="#排查问题工具" class="headerlink" title="排查问题工具"></a>排查问题工具</h2><ul><li>集群状态发生变化<ul><li>使用命令<code>ip:9200/_cluster/health?pretty</code>查询集群状态，如果集群状态发生了变化，可以从中分析原因</li></ul></li><li>节点正常，但是集群状态不是green<ul><li>使用命令<code>ip:9200/_cat/indices?v</code>，此命令会返回所有索引的状态，找到非green的索引，然后具体分析。</li></ul></li><li>查询分片失败原因<ul><li>命令<code>ip:9200/_cluster/allocation/explain</code></li></ul></li><li>查询索引分片状态<ul><li>命令<code>ip:9200/_cat/shards/index_name?v</code></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;接触ES也小半年了，ES虽然使用方便，运维简单但是集群规模和数据量大的话运维也很头疼，这里梳理下这半年的运维经验。&lt;/p&gt;</summary>
    
    
    
    <category term="bigdata" scheme="http://yuanba.tech/categories/bigdata/"/>
    
    
    <category term="BigData" scheme="http://yuanba.tech/tags/BigData/"/>
    
    <category term="ElasticSearch" scheme="http://yuanba.tech/tags/ElasticSearch/"/>
    
    <category term="运维" scheme="http://yuanba.tech/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>golang指针*和取址&amp;傻傻分不清楚</title>
    <link href="http://yuanba.tech/golang-point-address.html"/>
    <id>http://yuanba.tech/golang-point-address.html</id>
    <published>2020-05-03T09:24:05.000Z</published>
    <updated>2020-05-03T15:33:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>golang中有指针的概念，有指针相对的就有取址，何时使用指针何时使用取址对于刚接触的同学总是有点傻傻分不清楚。<br>本篇主要介绍下指针和取址的概念和区别。</p><span id="more"></span><p>指针类似于变量和常量，在使用指针前你需要声明指针。指针声明格式如下：<code>var name *Type</code>。<br>指针是指向一个<strong>值的内存地址</strong>，也就是说指针变量存放的是某个值或者对象的<strong>内存地址</strong>，即指针变量占用字节的大小与所指向的值的大小无关。<em>当一个指针被定义后没有分配到任何变量时，它的默认值为nil。</em></p><p>指针变量存放的是一个值的内存地址，那如何获取一个变量的内存地址呢？那就需要使用取址符号<code>&amp;</code>。<br>将一个值的内存地址通过<code>&amp;</code>赋值给了指针，那又应该如何通过指针来读取对应的值？需要使用符号<code>*</code>，需要与指针声明时的<code>*</code>进行区别。</p><p>看个代码感受下吧，代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 声明一个指针</span></span><br><span class="line"><span class="keyword">var</span> addr *<span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> house = <span class="string">&quot;Malibu Point 10880, 90265&quot;</span></span><br><span class="line"><span class="comment">// 通过&amp;将一个变量的内存地址赋值给指针</span></span><br><span class="line">addr = &amp;house</span><br><span class="line"><span class="comment">// 通过*获取指针中存储的地址对应的值</span></span><br><span class="line">value := *addr</span><br><span class="line">fmt.Printf(<span class="string">&quot;addr type: %T\n&quot;</span>, addr)</span><br><span class="line"><span class="comment">// 输出指针存储的内存地址，也就是house的内存地址</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;address: %p\n&quot;</span>, addr)</span><br><span class="line"><span class="comment">// 输出addr自身的内存地址</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;address: %p\n&quot;</span>, &amp;addr)</span><br><span class="line">fmt.Printf(<span class="string">&quot;value type: %T\n&quot;</span>, value)</span><br><span class="line">fmt.Printf(<span class="string">&quot;value: %s\n&quot;</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// addr type: *string</span></span><br><span class="line"><span class="comment">// address: 0xc000010200</span></span><br><span class="line"><span class="comment">// address: 0xc00000e028</span></span><br><span class="line"><span class="comment">// value type: string</span></span><br><span class="line"><span class="comment">// value: Malibu Point 10880, 90265</span></span><br></pre></td></tr></table></figure><p>代码先通过指针声明方式声明了一个<code>addr</code>指针，又通过取址符号<code>&amp;</code>将house的地址赋值给<code>addr</code>，然后又通过<code>*</code>将指针<code>addr</code>存储内存地址对应的值赋值给普通变量<code>value</code>。由于指针<code>addr</code>变量存储的是变量<code>house</code>的内存地址，所以输出的<code>addr</code>的值为一个内存地址，而又因为指针<code>addr</code>本身也是一个变量，也需要一个内存块来存储自己，所以通过取址符号<code>&amp;</code>得到的地址是指针变量的内存地址。</p><p>初看上面的代码，对其中的<code>*</code>和<code>&amp;</code>是不是傻傻分不清楚。<code>&amp;</code>功能比较单一，就是取址，获取变量的内存地址。<code>*</code>有<em>两种含义</em>，第一种是在指针声明时跟在变量的后面，紧跟变量类型，代表该变量是一个指针变量，如果使用<code>%p</code>来输出的话，它将是一个16进制数，第二种是紧跟指针变量，出现在指针变量的前面，代表获取该指针存储内存地址的值，一般是一个和指针类型一致的变量或者常量。在上面的demo代码中都有体现。</p><blockquote><p>Tips<br>go中何时使用指针？</p></blockquote><ul><li>当结构体较大的时候使用指针会更高效，可以避免内存拷贝</li><li>如果要修改结构体内部的数据或状态必须使用指针</li><li>如果方法的receiver是map、slice 、channel等引用类型不要使用指针</li><li>如果该函数需要将传入变量的修改状态传递出去，可以使用指针</li></ul><!--切片slice、字典map、管道channel引用类型的特点是：变量存储的是一个地址，这个地址对应的空间里才是真正存储的值，内存通常在堆中分配golang中到底有没有引用类型按照Golang的说法,Golang中所有的类型都是属于值类型,但是有几个类型比较特殊,表现出引用类型的特征go life, golang[够浪]unsafe是什么引用类型 是什么， 值类型引用类型是什么？golang中是否有引用类型？Go语言中有4个类型比较特别，看起来像引用类型引用类型 与 引用语义引用：就是变量的一个别名。java 引用变量-->]]></content>
    
    
    <summary type="html">&lt;p&gt;golang中有指针的概念，有指针相对的就有取址，何时使用指针何时使用取址对于刚接触的同学总是有点傻傻分不清楚。&lt;br&gt;本篇主要介绍下指针和取址的概念和区别。&lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://yuanba.tech/categories/golang/"/>
    
    
    <category term="go" scheme="http://yuanba.tech/tags/go/"/>
    
    <category term="golang" scheme="http://yuanba.tech/tags/golang/"/>
    
    <category term="指针" scheme="http://yuanba.tech/tags/%E6%8C%87%E9%92%88/"/>
    
    <category term="取址" scheme="http://yuanba.tech/tags/%E5%8F%96%E5%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>golang随波逐流之cache2go知识点解读</title>
    <link href="http://yuanba.tech/golang-cache2go-sec.html"/>
    <id>http://yuanba.tech/golang-cache2go-sec.html</id>
    <published>2020-04-13T16:17:00.000Z</published>
    <updated>2020-05-03T09:22:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://bigdatadecode.top/golang-cache2go-src.html">上篇</a>介绍了cache2go的代码逻辑，梳理代码逻辑时也能从中了解golang的一些语法以及使用技巧，本篇集中将源码中涉及到的知识点梳理下。</p><span id="more"></span><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><blockquote><p>结构体</p></blockquote><p>在mycachedapp.go文件中，看到的第一行有效代码是<code>type myStruct struct</code>，感觉有点像C语言中的结构体。<br>这个语句块定义了一个结构体，结构体是golang中一个比较重要的知识点，功能类似于JAVA中的类。</p><p>使用<code>type xName struct&#123;&#125;</code>定义一个结构体，mycachedapp.go中结构体相关的代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">text     <span class="keyword">string</span></span><br><span class="line">moreData []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实力化myStruct的对象</span></span><br><span class="line">val := myStruct&#123;<span class="string">&quot;This is a test!&quot;</span>, []<span class="keyword">byte</span>&#123;&#125;&#125;</span><br></pre></td></tr></table></figure><!-- // 区别，val相当于一个指针，一个引用类型val := &myStruct{"This is a test!", []byte{}}--><p>上述代码声明了一个名字为<code>myStruct</code>的结构体，其成员变量为<code>string</code>类型的<code>text</code>和<code>byte</code>类型的数组<code>moreData</code>。<br>紧着这初始化了一个<code>myStruct</code>对象并在初始化时对成员变量赋值，默认是按照变成声明的顺序依次赋值，也可以显示的指定变量进行赋值，例如<code>val := myStruct&#123;text: &quot;This xx&quot;&#125;</code>，未赋值的为类型的默认值，有点类似python。</p><p>结构体除了可以定义自己的成员变量，也可以定义成员方法。成员发方法的定义与普通函数的定义类似，只是在关键字<code>func</code>和函数名之间增加了函数归属哪个结构体的信息，如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个结构体</span></span><br><span class="line"><span class="keyword">type</span> Rect <span class="keyword">struct</span> &#123; </span><br><span class="line">x, y <span class="keyword">float64</span></span><br><span class="line">width, height <span class="keyword">float64</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义该结构体的成员方法</span></span><br><span class="line"><span class="comment">// 在关键字func和方法名之间增加方法归属的结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rect)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float64</span></span> &#123; </span><br><span class="line"><span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是结构体虽然类似其他语言中的类，但是golang结构体中并没有构造函数的概念，<strong>对象的创建通常交由一个全局的创建函数来完成</strong>，以<code>NewXXX</code>来命名，表示”构造函数”，例如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRect</span><span class="params">(x, y, width, height <span class="keyword">float64</span>)</span> *<span class="title">Rect</span></span> &#123; </span><br><span class="line"><span class="keyword">return</span> &amp;Rect&#123;x, y, width, height&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过&quot;构造函数&quot;创建Rect</span></span><br><span class="line">rect := NewRect(<span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>, <span class="number">6.6</span>)</span><br></pre></td></tr></table></figure><p>新类型可以像结构体那样新建，也可以基于已有的类型进行创建一个新的类型，语法为<code>type NewType Type</code>，<code>cachetable.go</code>文件中的<code>CacheItemPairList</code>就是基于已有类型进行新建的，代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CacheItemPair <span class="keyword">struct</span> &#123;</span><br><span class="line">Key         <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">AccessCount <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CacheItemPairList []CacheItemPair</span><br></pre></td></tr></table></figure><p>与基于已有类型新建类型的写法类似的是<code>类型别名</code>，其语法为<code>type alias = Type</code>，注意这里是等号。而且新建类型时Type已经发生了变化，而别名的Type并没有发生变化。</p><blockquote><p>数组 VS 切片</p></blockquote><p>数组几乎是所有编程语言中常用的数据结构，想必大家对其也比较了解，可以通过索引快速访问其值。数组的声明方式为<code>var variable_name [SIZE] variable_type</code>，代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x [<span class="number">32</span>]<span class="keyword">byte</span> =</span><br><span class="line"><span class="keyword">var</span> y [<span class="number">1000</span>]*<span class="keyword">float64</span> </span><br><span class="line"><span class="keyword">var</span> z [<span class="number">3</span>][<span class="number">5</span>]<span class="keyword">int</span> </span><br><span class="line"><span class="keyword">var</span> w [<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>]<span class="keyword">float64</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span> = [<span class="number">10</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125; <span class="comment">// 长度为5，...代表自动计算长度</span></span><br></pre></td></tr></table></figure><p>数组在使用过程中有个诟病就是长度在初始化时需要指定，并且后续无法改变。为了解决此问题各种语言都增加其它数据结构，golang中增加的是切片(slice)。<br>切片有一个初始数据长度，使用<code>len</code>函数获取，还有一个预留空间长度，预留空间用光之后会自动扩容，使用<code>cap</code>函数获取预留空间长度。切片的创建有两种方式，一种是直接创建，另一种是根据数组创建。</p><ul><li>直接创建需要使用关键字<code>make</code>，代码为<code>var mySlice []int or mySlice1 := make([]int, 5)</code></li><li>根据数组创建的话需要先创建一个数据，然后将数组的值赋值给切片，代码为</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray [<span class="number">10</span>]<span class="keyword">int</span> = [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125; <span class="comment">// 基于数组创建一个数组切片</span></span><br><span class="line"><span class="keyword">var</span> mySlice []<span class="keyword">int</span> = myArray[:<span class="number">5</span>]</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">mySlice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; <span class="comment">// 注意这里中括号中没有长度，如果有长度就变成数组的创建了</span></span><br></pre></td></tr></table></figure><p>数组和切片还有一个区别就是<em>数组作为参数或者变量之间赋值时，是复制一份，相互之间不影响</em>，例如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="keyword">var</span> b = a</span><br><span class="line">b[<span class="number">1</span>]++</span><br><span class="line">fmt.Println(a, b) <span class="comment">// a和b之间不受影响，print [1 2 3] [1 3 3]</span></span><br></pre></td></tr></table></figure><p>但是<strong>切片却可以在参数传递中，将修改的结果作用在同一份数据上</strong>，例如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">slice1 := []<span class="keyword">int</span>&#123;<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>&#125;</span><br><span class="line">fmt.Println(slice1)</span><br><span class="line">modify(slice1)</span><br><span class="line">fmt.Println(slice1) <span class="comment">// 输出1,6,6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(slice1 []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">fmt.Println(slice1)</span><br><span class="line">slice1[<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片slice表现出来的现象有点像引用类型，但是<strong>要切记slice并不是引用类型，只是表现出来引用语义而已</strong>。在<strong>golang中其实只有值传递</strong>，slice表现出来的引用语义其实只是golang的一个语法糖，具体看下这个语法糖是怎么实现的。<br>slice的声明如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">array unsafe.Pointer</span><br><span class="line"><span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line"><span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>slice结构体有一个<code>unsafe.Poiniter</code>的指针，他指向一个数组，剩下两个属性一个代表数据的长度另一个代表容量。<br>当slice进行变量传递或者参数传递时，依然是将其值拷贝一份，此时<code>unsafe.Poiniter</code>类型的指针<code>array</code>将其存储的<strong>数组地址</strong>也拷贝了一份，所以对传递之后的变量进行修改会影响原始slice的结果。示意图如下：<br><img src="/blogimgs/golang-grammar/slice.png" alt="slice变量" title="slice变量"><br>其中<code>[]int</code>是一个数组，存放slice中的数据，<code>slice1</code>是slice的一个实例，<code>slice1</code>对<code>slice2</code>进行了赋值。赋值时进行了值传递，将<code>slice1</code>中的数据拷贝了一份给<code>slice2</code>，<code>slice1</code>中的<code>array</code>指针将其值也就是<code>[]int</code>的地址拷贝了一份给<code>slice2</code>中的<code>array</code>指针，这就类似指针的赋值，所以对<code>slice2</code>的修改可以影响到<code>slice1</code>。<br>如果不想拷贝一份则可以使用指针传递，直接传递slice的指针，代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">slice1 := []<span class="keyword">int</span>&#123;<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>&#125;</span><br><span class="line">fmt.Println(slice1)</span><br><span class="line">modify(&amp;slice1)</span><br><span class="line">fmt.Println(slice1) <span class="comment">// 输出1,6,6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(slice1 *[]<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">fmt.Println(*slice1)</span><br><span class="line">(*slice1)[<span class="number">0</span>] =<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后记住关键的一句话<strong>golang只有值传递</strong>。</p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><blockquote><p>Timer</p></blockquote><p>Timer是一个定时器，在cache2go中用来定时检查缓存中对象的过期时间。在golang中有两种定时器，分别为<code>Timer</code>和<code>Ticker</code>。<code>Timer</code>只触发一次，如果还需继续触发需要使用Reset进行重置，而<code>Ticker</code>是间隔特定时间触发。</p><p>Timer可以通过<code>NewTimer</code>创建或者使用<code>AfterFunc</code>创建。使用<code>NewTimer</code>创建时，当Timer到期时，会将当时的时间发送给channel。<br>Timer类型定义如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Timer <span class="keyword">struct</span> &#123;</span><br><span class="line">    C &lt;-<span class="keyword">chan</span> Time     <span class="comment">// The channel on which the time is delivered.</span></span><br><span class="line">    r runtimeTimer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的C就是上文中，说的会将当前时间发送的channel，<code>NewTimer</code>创建Timer的demo如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer := time.NewTimer(time.Second * <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>这种形式创建的Timer，使用时需要监听channel C中的信号，使用demo如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d := time.Duration(time.Second*<span class="number">2</span>)</span><br><span class="line">    t := time.NewTimer(d)</span><br><span class="line">    <span class="keyword">defer</span> t.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 等待channel C中的信号</span></span><br><span class="line">        &lt;- t.C</span><br><span class="line"></span><br><span class="line">        fmt.Println(<span class="string">&quot;do someting...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置定时器，因为Timer是一次触发</span></span><br><span class="line"><span class="comment">// Reset 会先调用 stopTimer 再调用 startTimer，类似于废弃之前的定时器，重新启动一个定时器</span></span><br><span class="line">t.Reset(time.Second*<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cache2go中并没有使用这种方式创建Timer，而是使用了<code>AfterFunc</code>，代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">table.cleanupTimer = time.AfterFunc(smallestDuration, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> table.expirationCheck()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>AfterFunc传入两个参数，第一个是时间参数，间隔多久触发，第二个是执行逻辑，使用一个函数作为参数。当Timer经过smallestDuration长时间之后，会执行协程<code>table.expirationCheck()</code>，这个也是一次触发，所以每次都需要通过<code>AfterFunc</code>再次创建一个Timer。</p><p>另一个定时器是Ticker，是周期性的触发，需要注意的是除非程序终止否则定时器会一直触发，停止时应该调用<code>Ticker.Stop</code>来释放相关资源。Ticker使用<code>NewTicker</code>创建，demo如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := time.NewTicker(<span class="number">2</span>*time.Second)</span><br><span class="line">    <span class="keyword">defer</span> t.Stop()</span><br><span class="line"></span><br><span class="line">    fmt.Println(time.Now())</span><br><span class="line">    time.Sleep(<span class="number">5</span>*time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">            fmt.Println(time.Now())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- 需要注意的是golang timer定时器是不能stop停止的，只能在逻辑上通过标示位来退出定时任务， 为什么？？？？ --><blockquote><p>go协程</p></blockquote><p>go关键字表示协程goroutine，是Go语言中的轻量级线程实现，由Go运行时(runtime)管理。</p><p>协程是对线程的一种补充，线程是由系统内核管理的，<strong>线程之间的切换会触发用户态到内核态的切换</strong>，此时需要保存一些上下文信息，比较消耗资源，而且线程太多也会达到线程上限的瓶颈。<br>而协程完全是由程序所控制(也就是在用户态执行，所以也叫<strong>用户态线程</strong>)，是在应用层模拟线程，因此避免了用户态和内核态的频繁切换。<br>程序最终是要由CPU及相关存储器进行执行，而协程在用户态执行，不由系统内核调度，那么他是如何调度到CPU的？在golang中，协程是基于线程的，并且实现了一个逻辑流调度(也就是协程调度器)，可以像调度线程那样在用户态也能根据代码的执行状态进行调度协程，<em>更充分的利用并发的优势，又避免反复系统调用，还有进程切换造成的开销</em>。</p><p>更通俗的说<em>协程是子函数的一个特例</em>，在线程中函数之间的调用只需要将各自的执行状态压入栈中即可，所以协程切换时也是压栈操作，比较轻量。</p><p>了解过协程之后，发现协程确实是个好东西，更好的是golang从编译器和语言基础库多个层面对协程做了实现，例如golang对各种io函数进行了封装，内部调用操作系统的异步io函数，根据这些函数返回的状态将现有的执行序列压栈，让线程去拉另一个协程执行，是目前各类有协程概念的语言中实现的最完整和成熟的，最重要的是使用起来很方便，只需在普通函数之前添加<code>go</code>关键字即可，使开发者更多的关注业务逻辑的实现，更少的在这些关键的基础构件上耗费太多精力。</p><p>cache2go中只有一处使用了协程，代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">expirationCheck</span><span class="params">()</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">table.cleanupTimer = time.AfterFunc(smallestDuration, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> table.expirationCheck()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>go</code>关键字加普通函数代表协程，不同于函数调用，不会等待调用函数结束，而是继续执行剩下的代码片段，被调用的函数会在适当的时间被调度。<em>需要注意的是，如果这个函数有返回值，那么这个 返回值会被丢弃。</em></p><!--协程就是在用户程序中实现了协作式任务调度(当任务得一个到了 CPU 时间，除非它自己放弃使用 CPU ，否则将完全霸占 CPU)并发 一个时间段内，多个任务交替执行并行 同一时刻，多个任务同时执行协程的优势：最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。协程也可以在多个线程之间切换，--><!--> 函数 func(key interface{}, args ...interface{})   可变参数长度函数变量>test golang字符串，byte数组 byte区别## 语法技巧匿名函数匿名属性函数参数res.Data().(*myStruct).text 这是什么用法，强制转换类型？ 接口类型强制转换声明多个变量可以缩写，用小括号括起来<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">cache = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*CacheTable)</span><br><span class="line">mutex sync.RWMutex</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>map 接口<br>t, ok := cache[table] 判断是否有值</p><p>RLock与Lock的区别<br>sync.WaitGroup<br>–&gt;</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://bigdatadecode.top/golang-cache2go-src.html&quot;&gt;上篇&lt;/a&gt;介绍了cache2go的代码逻辑，梳理代码逻辑时也能从中了解golang的一些语法以及使用技巧，本篇集中将源码中涉及到的知识点梳理下。&lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://yuanba.tech/categories/golang/"/>
    
    
    <category term="go" scheme="http://yuanba.tech/tags/go/"/>
    
    <category term="golang" scheme="http://yuanba.tech/tags/golang/"/>
    
    <category term="cache2go" scheme="http://yuanba.tech/tags/cache2go/"/>
    
    <category term="源码" scheme="http://yuanba.tech/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>golang随波逐流之cache2go源码解读</title>
    <link href="http://yuanba.tech/golang-cache2go-src.html"/>
    <id>http://yuanba.tech/golang-cache2go-src.html</id>
    <published>2020-03-30T15:17:05.000Z</published>
    <updated>2020-04-13T16:00:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>想学习golang了，工作中又接触不到，基础语法一看全明白，真到用的时候却是瞪眼瞎，怎么办？<br>可以找简单的开源项目，看下源码，看看这些语法的常用方式，并且也可以自己尝试着去自己实现下。<br><a href="https://github.com/muesli/cache2go">cache2go</a>就是一个比较简单的项目，也是初学者必撸的项目了吧。<br>本篇是我梳理cache2go的学习笔记。</p><span id="more"></span><h2 id="cache2go概览"><a href="#cache2go概览" class="headerlink" title="cache2go概览"></a>cache2go概览</h2><p>cache2go是用Go实现的并发安全的缓存库，主要功能有：</p><ul><li>并发安全</li><li>缓存命中次数</li><li>缓存过期</li></ul><p>项目目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">xx/cache2go</span><br><span class="line">├── LICENSE.txt</span><br><span class="line">├── README.md</span><br><span class="line">├── benchmark_test.go</span><br><span class="line">├── cache.go</span><br><span class="line">├── cache_test.go</span><br><span class="line">├── cacheitem.go</span><br><span class="line">├── cachetable.go</span><br><span class="line">├── errors.go</span><br><span class="line">└── examples</span><br><span class="line">    ├── callbacks</span><br><span class="line">    │   └── callbacks.go</span><br><span class="line">    ├── dataloader</span><br><span class="line">    │   └── dataloader.go</span><br><span class="line">    └── mycachedapp</span><br><span class="line">        └── mycachedapp.go</span><br></pre></td></tr></table></figure><p>是不是很简单，功能代码一共也就四个文件，其中一个还是个error文件，里面只定义了两个error类型，其核心文件也就三个。<br>核心代码虽然不多，但是仔细读这三个文件，还是可以从中学习很多golang语法和知识点的，比如lock、goroutine、匿名函数等等。</p><h2 id="强撸灰飞烟灭"><a href="#强撸灰飞烟灭" class="headerlink" title="强撸灰飞烟灭"></a>强撸灰飞烟灭</h2><p>对于一个程序员来说，阅读代码是一项必备的技能，因为在工作中肯定会遇到开发维护遗留项目的情况。<br>那么如何快速高效的阅读代码呢？俗话说强撸灰飞烟灭，所以肯定不能上来就一顿操作猛如虎。<br>针对不同开发人员开发的项目以及不同类型的项目需要有不同的方法，这里谈下我个人的几点看法：<br>1、公司内部项目可结合口头流传或者wiki以及项目本身的技术框架，从某个功能点进行切入<br>2、开源项目普遍有较为完善的文档和单元测试或者examples，可以从文档入手了解功能及使用方式，然后以单元测试或者examples作为代码的切入点。</p><p>cache2go是一个开源项目，里面有测试相关的代码，也有examples，所以先从examples代码入手。<br>examples中有三个文件，分别为mycachedapp.go、dataloader.go和callbacks.go，看名字应该先看mycachedapp.go这个文件，它应该是缓存的使用方式。</p><p>mycachedapp.go文件中介绍了cache的读写和删等常用操作，解析下关键代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实力化一个缓存cache，名字为myCahe</span></span><br><span class="line">cache := cache2go.Cache(<span class="string">&quot;myCache&quot;</span>)</span><br><span class="line"><span class="comment">// 向缓存中加入元素，kv格式，第二个参数时key的过期时间，0代表用不过期</span></span><br><span class="line">cache.Add(<span class="string">&quot;someKey&quot;</span>, <span class="number">5</span>*time.Second, &amp;val)</span><br><span class="line"><span class="comment">// 缓存中读取key对应的值</span></span><br><span class="line">res, err := cache.Value(<span class="string">&quot;someKey&quot;</span>)</span><br><span class="line"><span class="comment">// 设置删除某个key时的回调函数</span></span><br><span class="line">cache.SetAboutToDeleteItemCallback(<span class="function"><span class="keyword">func</span><span class="params">(e *cache2go.CacheItem)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Deleting:&quot;</span>, e.Key(), e.Data().(*myStruct).text, e.CreatedOn())</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 从缓存中删除某个key</span></span><br><span class="line">cache.Delete(<span class="string">&quot;someKey&quot;</span>)</span><br><span class="line"><span class="comment">// 清空缓存</span></span><br><span class="line">cache.Flush()</span><br></pre></td></tr></table></figure><p>通读mycachedapp.go之后，了解了cache的基本用法，下面我们更深一步，去探寻他具体是如何实现的。</p><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>mycachedapp.go中调用<code>cache2go.Cache()</code>初始化了一个缓存实例，接着跟进这个方法看下具体的细节。此方法位于<code>cache.go</code>文件中，代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">cache = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*CacheTable)</span><br><span class="line">mutex sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Cache</span><span class="params">(table <span class="keyword">string</span>)</span> *<span class="title">CacheTable</span></span> &#123;</span><br><span class="line"><span class="comment">// RLock读锁，读锁之间可以共享，Lock需要等待Rlock释放才能得到锁</span></span><br><span class="line">mutex.RLock()</span><br><span class="line"><span class="comment">// 从map cache中获取table对应的值</span></span><br><span class="line">t, ok := cache[table]</span><br><span class="line">mutex.RUnlock()</span><br><span class="line">    <span class="comment">// ok为true代表有值，false代表无值</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="comment">// 互斥锁</span></span><br><span class="line">mutex.Lock()</span><br><span class="line">t, ok = cache[table]</span><br><span class="line"><span class="comment">// Double check whether the table exists or not.</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="comment">// 创建一个CacheTable对象</span></span><br><span class="line">t = &amp;CacheTable&#123;</span><br><span class="line">name:  table,</span><br><span class="line">items: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*CacheItem),</span><br><span class="line">&#125;</span><br><span class="line">cache[table] = t</span><br><span class="line">&#125;</span><br><span class="line">mutex.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cache.go</code>代码比较简单，先声明了两个全局变量，接着就是<code>Cache()</code>方法。该方法也比较简单，根据传入的参数table从map类型的cache中取出对应的值，有值则直接返回，无值则创建一个<code>CacheTable</code>类型的对象。这里使用了<code>Double check</code>机制来保证线程安全。</p><h2 id="CacheTable"><a href="#CacheTable" class="headerlink" title="CacheTable"></a>CacheTable</h2><p>关键点就在于<code>CacheTable</code>，接下来看下<code>CacheTable</code>的具体实现。</p><p><code>CacheTable</code>位于<code>cachetable.go</code>文件中，是一个结构体，代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CacheTable <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 匿名属性</span></span><br><span class="line">sync.RWMutex</span><br><span class="line"></span><br><span class="line"><span class="comment">// The table&#x27;s name.</span></span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line"><span class="comment">// All cached items.</span></span><br><span class="line">items <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*CacheItem</span><br><span class="line"></span><br><span class="line"><span class="comment">// Timer responsible for triggering cleanup.</span></span><br><span class="line">cleanupTimer *time.Timer</span><br><span class="line"><span class="comment">// 当前计时器持续时间</span></span><br><span class="line"><span class="comment">// Current timer duration.</span></span><br><span class="line">cleanupInterval time.Duration</span><br><span class="line"></span><br><span class="line"><span class="comment">// The logger used for this table.</span></span><br><span class="line">logger *log.Logger</span><br><span class="line"></span><br><span class="line"><span class="comment">// Callback method triggered when trying to load a non-existing key.</span></span><br><span class="line">loadData <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, args ...<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">CacheItem</span></span></span><br><span class="line"><span class="comment">// Callback method triggered when adding a new item to the cache.</span></span><br><span class="line"><span class="comment">// 触发回调函数，回调函数可以不止一个</span></span><br><span class="line">addedItem []<span class="function"><span class="keyword">func</span><span class="params">(item *CacheItem)</span></span></span><br><span class="line"><span class="comment">// Callback method triggered before deleting an item from the cache.</span></span><br><span class="line">aboutToDeleteItem []<span class="function"><span class="keyword">func</span><span class="params">(item *CacheItem)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CacheTable</code>的成员变量重点介绍下<code>items</code>、<code>cleanupTimer</code>和一些用于回调函数的函数变量，其中<code>items</code>是一个map，以key/value的形式存储具体的缓存数据；<code>cleanupTimer</code>是一个定时器，用于检查缓存对象的过期时间；剩下的<code>loadData、addedItem和aboutToDeleteItem</code>用于某些操作的回调函数。</p><p>接下来看下mycachedapp.go文件中对缓存使用相关的方法，增加缓存的方法Add，读取缓存中数据的方法Value和删除缓存中数据的方法Delete，这几个方法的首字母都是大写，代表方法是public。</p><blockquote><p>Add</p></blockquote><p>先看下Add方法，代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key是缓存对象的key，data是缓存对象的值，lifeSpan是对象的过期时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">Add</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, lifeSpan time.Duration, data <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">CacheItem</span></span> &#123;</span><br><span class="line"><span class="comment">// golang中的“构造函数”</span></span><br><span class="line">item := NewCacheItem(key, lifeSpan, data)</span><br><span class="line"><span class="comment">// 将item加入CacheTable中，这里涉及到多线程，所以需要加锁</span></span><br><span class="line"><span class="comment">// 锁的释放在addInternal方法中，是对锁粒度进行的优化</span></span><br><span class="line">table.Lock()</span><br><span class="line">table.addInternal(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Add方法会根据传入的参数调用<code>NewCacheItem</code>方法构建一个CacheItem对象，由于golang中的结构体并没有构造函数的概念，对于需要构造函数的场景，一般都会使用<code>NewStructName()</code>的方式声明一个方法，作为结构体的构造函数使用。NewCacheItem位于cacheitem.go中，会在下一节介绍。</p><p>item创建成功之后，需要将其加入到map类型的items中，以便于后续数据的读取。由于此操作涉及到读写操作，在多线程下需要保证线程安全，所以在调用<code>addInternal</code>方法之前先获取锁，但是释放锁并没有在<code>addInternal</code>方法执行结束再释放，而是在<code>addInternal</code>代码中对相应资源读写结束之后释放，这样做减少了持有锁的时间，提高了并行度。<code>addInternal</code>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">addInternal</span><span class="params">(item *CacheItem)</span></span> &#123;</span><br><span class="line"><span class="comment">// Careful: do not run this method unless the table-mutex is locked!</span></span><br><span class="line"><span class="comment">// It will unlock it for the caller before running the callbacks and checks</span></span><br><span class="line">table.log(<span class="string">&quot;Adding item with key&quot;</span>, item.key, <span class="string">&quot;and lifespan of&quot;</span>, item.lifeSpan, <span class="string">&quot;to table&quot;</span>, table.name)</span><br><span class="line"><span class="comment">// 将数据加入缓存中</span></span><br><span class="line">table.items[item.key] = item</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将值进行提前缓存，及时释放锁</span></span><br><span class="line">expDur := table.cleanupInterval</span><br><span class="line"><span class="comment">// 得到Add的回调函数列表</span></span><br><span class="line">addedItem := table.addedItem</span><br><span class="line"><span class="comment">// 未持有锁，而直接进行释放时，会报异常</span></span><br><span class="line">table.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trigger callback after adding an item to cache.</span></span><br><span class="line"><span class="keyword">if</span> addedItem != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, callback := <span class="keyword">range</span> addedItem &#123;</span><br><span class="line">callback(item)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we haven&#x27;t set up any expiration check timer or found a more imminent item.</span></span><br><span class="line"><span class="comment">// 如果item的过期时间小于下次检查的时间间隔，则触发过期检查，重置过期时间间隔</span></span><br><span class="line"><span class="keyword">if</span> item.lifeSpan &gt; <span class="number">0</span> &amp;&amp; (expDur == <span class="number">0</span> || item.lifeSpan &lt; expDur) &#123;</span><br><span class="line">table.expirationCheck()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addInternal</code>方法才会真正的将数据添加到缓存中，并且调用相应的回调函数，并且这里还会触发过期检查。<br>数据的过期检查使用了<code>Timer</code>的定时功能，但是细心的童鞋会发现<code>CacheTable</code>在创建的时候并没有给<code>Timer</code>进行赋值，<code>Timer</code>是通过第一个加入到缓存中的数据激活的。<br>这样好处是缓存初始化之后，在添加数据之前不用让<code>Timer</code>去定期执行一些无意义的操作，而且在每加入一个数据就触发过期检查更能更及时的调整进行过期检查的时间点，<strong>因为缓存中数据的过期时间不定，无法设置一个合理的定期时间去周期性的执行，而且遍历一遍所有数据找出最先过期的数据，将其剩余时间作为下次检查的时间间隔</strong>。<br><code>expirationCheck</code>方法代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">expirationCheck</span><span class="params">()</span></span> &#123;</span><br><span class="line">table.Lock()</span><br><span class="line"><span class="comment">// Timer定时功能的一种用法，结合下面对cleanupTimer的赋值方式即可理解</span></span><br><span class="line"><span class="keyword">if</span> table.cleanupTimer != <span class="literal">nil</span> &#123;</span><br><span class="line">table.cleanupTimer.Stop()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> table.cleanupInterval &gt; <span class="number">0</span> &#123;</span><br><span class="line">table.log(<span class="string">&quot;Expiration check triggered after&quot;</span>, table.cleanupInterval, <span class="string">&quot;for table&quot;</span>, table.name)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// cleanupInterval 为0时，代表没有定时去执行过期检查任务</span></span><br><span class="line">table.log(<span class="string">&quot;Expiration check installed for table&quot;</span>, table.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// To be more accurate with timers, we would need to update &#x27;now&#x27; on every</span></span><br><span class="line"><span class="comment">// loop iteration. Not sure it&#x27;s really efficient though.</span></span><br><span class="line">now := time.Now()</span><br><span class="line">smallestDuration := <span class="number">0</span> * time.Second</span><br><span class="line"><span class="comment">// 遍历缓存中的数据，找出最先过期的时间差</span></span><br><span class="line"><span class="keyword">for</span> key, item := <span class="keyword">range</span> table.items &#123;</span><br><span class="line"><span class="comment">// Cache values so we don&#x27;t keep blocking the mutex.</span></span><br><span class="line">item.RLock()</span><br><span class="line">lifeSpan := item.lifeSpan</span><br><span class="line">accessedOn := item.accessedOn</span><br><span class="line">item.RUnlock()</span><br><span class="line"><span class="comment">// lifeSpan为0，代表用不过期</span></span><br><span class="line"><span class="keyword">if</span> lifeSpan == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> now.Sub(accessedOn) &gt;= lifeSpan &#123;</span><br><span class="line"><span class="comment">// 过期的则删掉</span></span><br><span class="line">table.deleteInternal(key)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Find the item chronologically closest to its end-of-lifespan.</span></span><br><span class="line"><span class="comment">// 这个分支中 lifeSpan-now.Sub(accessedOn) 一定大于 0，如果小于0的话，会被if拦截</span></span><br><span class="line"><span class="keyword">if</span> smallestDuration == <span class="number">0</span> || lifeSpan-now.Sub(accessedOn) &lt; smallestDuration &#123;</span><br><span class="line">smallestDuration = lifeSpan - now.Sub(accessedOn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup the interval for the next cleanup run.</span></span><br><span class="line">table.cleanupInterval = smallestDuration</span><br><span class="line"><span class="comment">// smallestDuration &lt;= 0时，不再执行定时检查任务</span></span><br><span class="line"><span class="comment">// smallestDuration 只能等于或者大于0</span></span><br><span class="line"><span class="keyword">if</span> smallestDuration &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// smallestDuration大于0，则设置定时执行任务</span></span><br><span class="line">table.cleanupTimer = time.AfterFunc(smallestDuration, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 协程</span></span><br><span class="line"><span class="keyword">go</span> table.expirationCheck()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">table.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Add相关的代码就介绍到这里，下面看下Value</p><blockquote><p>Value</p></blockquote><p>Value方法代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*CacheItem, error)</span></span> &#123;</span><br><span class="line">table.RLock()</span><br><span class="line">r, ok := table.items[key]</span><br><span class="line"><span class="comment">// 缓存中没有命中时到回调函数</span></span><br><span class="line">loadData := table.loadData</span><br><span class="line">table.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="comment">// 缓存中有数据，调用CacheItem的KeepAlive更新访问时间和访问次数</span></span><br><span class="line">r.KeepAlive()</span><br><span class="line"><span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数不为null时，执行具体的回调函数，</span></span><br><span class="line"><span class="comment">// args参数是传递给回调函数的</span></span><br><span class="line"><span class="keyword">if</span> loadData != <span class="literal">nil</span> &#123;</span><br><span class="line">item := loadData(key, args...)</span><br><span class="line"><span class="keyword">if</span> item != <span class="literal">nil</span> &#123;</span><br><span class="line">table.Add(key, item.lifeSpan, item.data)</span><br><span class="line"><span class="keyword">return</span> item, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义错误类型</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrKeyNotFoundOrLoadable</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义错误类型</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrKeyNotFound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在mycachedapp.go中调用的Value方法是<code>cache.Value(&quot;someKey&quot;)</code>，而这里的Value函数却是传入两个参数，这里的第二个参数是可变长度的参数，长度可以为0，所以可以传如一个参数。</p><blockquote><p>Delete</p></blockquote><p>Delete方法代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*CacheItem, error)</span></span> &#123;</span><br><span class="line">table.Lock()</span><br><span class="line"><span class="comment">// 在方法执行完之后，执行Unlock</span></span><br><span class="line"><span class="keyword">defer</span> table.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> table.deleteInternal(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">deleteInternal</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*CacheItem, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// golang从map中取值避免null值的语法</span></span><br><span class="line">r, ok := table.items[key]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrKeyNotFound</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cache value so we don&#x27;t keep blocking the mutex.</span></span><br><span class="line"><span class="comment">// 删除数据时的回调函数</span></span><br><span class="line">aboutToDeleteItem := table.aboutToDeleteItem</span><br><span class="line">table.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trigger callbacks before deleting an item from cache.</span></span><br><span class="line"><span class="keyword">if</span> aboutToDeleteItem != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, callback := <span class="keyword">range</span> aboutToDeleteItem &#123;</span><br><span class="line">callback(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r.RLock()</span><br><span class="line"><span class="comment">// 这里的defer是在函数的最后执行RUnlock吧</span></span><br><span class="line"><span class="keyword">defer</span> r.RUnlock()</span><br><span class="line"><span class="comment">// 为什么两个回调函数</span></span><br><span class="line"><span class="keyword">if</span> r.aboutToExpire != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, callback := <span class="keyword">range</span> r.aboutToExpire &#123;</span><br><span class="line">callback(key)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">table.Lock()</span><br><span class="line">table.log(<span class="string">&quot;Deleting item with key&quot;</span>, key, <span class="string">&quot;created on&quot;</span>, r.createdOn, <span class="string">&quot;and hit&quot;</span>, r.accessCount, <span class="string">&quot;times from table&quot;</span>, table.name)</span><br><span class="line"><span class="comment">// map的系统函数进行数据删除</span></span><br><span class="line"><span class="built_in">delete</span>(table.items, key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Delete方法于Add类似，都是在其内部调用了另一个内部函数，具体的逻辑在其内部函数中，这里是<code>deleteInternal</code>方法。代码和语法都比较简单，就不过多展开了。<br>接下来看下如何清空缓存，方法是<code>Flush</code>。</p><blockquote><p>Flush</p></blockquote><p>Flush方法的代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">Flush</span><span class="params">()</span></span> &#123;</span><br><span class="line">table.Lock()</span><br><span class="line"><span class="keyword">defer</span> table.Unlock()</span><br><span class="line"></span><br><span class="line">table.log(<span class="string">&quot;Flushing table&quot;</span>, table.name)</span><br><span class="line"><span class="comment">// 直接将一个新的map赋值给items，老map等着自动回收</span></span><br><span class="line">table.items = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*CacheItem)</span><br><span class="line">table.cleanupInterval = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> table.cleanupTimer != <span class="literal">nil</span> &#123;</span><br><span class="line">table.cleanupTimer.Stop()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>介绍到这里，<code>cachetable.go</code>中的代码就几乎撸完了，不过还有个功能需要提下，就是统计缓存中访问次数最多的数据，方法名为<code>MostAccessed</code>，代码也比较简单，重点介绍下这个排序功能。<br>排序是先将缓存中的数据放入切片中，然后调用<code>sort.Sort</code>对切片进行排序，调用<code>sort.Sort</code>时，需要传入的集合是可比类型的，而且还可以重写比较器，类似java中的使用方式。<br>代码中先声明了一个<code>CacheItemPair</code>结构体，用来作为比较对象，只存储Key和访问次数关键信息，减少内存消耗，其次声明一个切片类型的<code>CacheItemPairList</code>，并实现了可比的相关函数，代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CacheItemPair <span class="keyword">struct</span> &#123;</span><br><span class="line">Key         <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">AccessCount <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CacheItemPairList []CacheItemPair</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p CacheItemPairList)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p CacheItemPairList)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p CacheItemPairList)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> p[i].AccessCount &gt; p[j].AccessCount &#125;</span><br></pre></td></tr></table></figure><p>至此，<code>cachetable.go</code>的相关代码就算介绍完了，剩下的就是些回调函数的设置以及一些常规用法，比较简单。<br>了解了<code>cachetable.go</code>相关代码之后，缓存的内存结构其实也就清楚了，也就对整个缓存的架构有了初步的了解，就感觉其实很简单，其内存结构图如下：<br><img src="/blogimgs/cache2go-src/cache2go.png" alt="cache2go内存结构" title="cache2go内存结构"></p><h2 id="CacheItem"><a href="#CacheItem" class="headerlink" title="CacheItem"></a>CacheItem</h2><p>CacheTable了解之后，再来看下CacheItem，在读CacheTable相关代码的时候其实已经涉及到一些CacheItem相关的代码，从中可以看出CacheItem代码并不复杂，比较简单易懂。</p><p>CacheItem相关的属性如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CacheItem <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 匿名变量</span></span><br><span class="line">sync.RWMutex</span><br><span class="line"></span><br><span class="line"><span class="comment">// The item&#x27;s key.</span></span><br><span class="line">key <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="comment">// The item&#x27;s data.</span></span><br><span class="line">data <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="comment">// How long will the item live in the cache when not being accessed/kept alive.</span></span><br><span class="line">lifeSpan time.Duration</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creation timestamp.</span></span><br><span class="line">createdOn time.Time</span><br><span class="line"><span class="comment">// Last access timestamp.</span></span><br><span class="line">accessedOn time.Time</span><br><span class="line"><span class="comment">// How often the item was accessed.</span></span><br><span class="line">accessCount <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Callback method triggered right before removing the item from the cache</span></span><br><span class="line">aboutToExpire []<span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在golang中，针对结构体并没有对行的<strong>构造函数</strong>，但是对于习惯使用构造函数的人来说该怎么办呢？于是有了一种约定俗成的语法，那就是将函数命名为<code>NewXXX</code>形式，以此表示该结构体的构造函数，cacheitem.go中就用到了这种命名方式，代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCacheItem</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, lifeSpan time.Duration, data <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">CacheItem</span></span> &#123;</span><br><span class="line">t := time.Now()</span><br><span class="line"><span class="keyword">return</span> &amp;CacheItem&#123;</span><br><span class="line">key:           key,</span><br><span class="line">lifeSpan:      lifeSpan,</span><br><span class="line">createdOn:     t,</span><br><span class="line">accessedOn:    t,</span><br><span class="line">accessCount:   <span class="number">0</span>,</span><br><span class="line">aboutToExpire: <span class="literal">nil</span>,</span><br><span class="line">data:          data,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码看到这里应该对cache2go整个源码都已了解了，而且对golang也有了进一步的理解吧，只是其中还有很多语法以及用法不太熟悉，随后多看多写就OK了，下一篇我会根据这个项目中涉及到的知识点进行梳理扩展。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;想学习golang了，工作中又接触不到，基础语法一看全明白，真到用的时候却是瞪眼瞎，怎么办？&lt;br&gt;可以找简单的开源项目，看下源码，看看这些语法的常用方式，并且也可以自己尝试着去自己实现下。&lt;br&gt;&lt;a href=&quot;https://github.com/muesli/cache2go&quot;&gt;cache2go&lt;/a&gt;就是一个比较简单的项目，也是初学者必撸的项目了吧。&lt;br&gt;本篇是我梳理cache2go的学习笔记。&lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://yuanba.tech/categories/golang/"/>
    
    
    <category term="go" scheme="http://yuanba.tech/tags/go/"/>
    
    <category term="golang" scheme="http://yuanba.tech/tags/golang/"/>
    
    <category term="cache2go" scheme="http://yuanba.tech/tags/cache2go/"/>
    
    <category term="源码" scheme="http://yuanba.tech/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Flink window解密</title>
    <link href="http://yuanba.tech/Flink-Window-Decode.html"/>
    <id>http://yuanba.tech/Flink-Window-Decode.html</id>
    <published>2019-12-05T13:52:53.000Z</published>
    <updated>2019-12-10T15:52:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>近几年流处理简直火的一塌糊涂，Flink也在阿里的推广下逐渐成为业界主流，正在逐步取代Storm和Spark Streaming。<br>Flink天生就是为了处理流，而且相对于其他流处理框架集成了很多实用功能，比如状态管理；Flink还丰富了window的功能，使window也成为了Flink的一个特色。<br>本篇主要对window从多种角度进行解密，主要包括：</p><ul><li>何为window</li><li>如何使用</li><li>如何实现</li><li>各组件原理</li></ul><blockquote><p>在解密window之前，简单介绍下何为流处理？</p></blockquote><span id="more"></span><p>流是指一种源源不断的形态，流处理是一种被设计来处理无界数据集的数据处理系统引擎，无界的数据集是指没有边界，数量上是无穷的一类数据集。<br>Flink将流处理总结为四个单词： what where when how</p><ul><li><p>what – What results are calculated(计算的结果是什么)</p></li><li><p>where – Where in event time are results calculated(在事件时间中的哪个位置计算结果)</p></li><li><p>when – When in processing time are results materialized(在处理时间中的哪个时刻触发计算结果)</p></li><li><p>how – How do refinements of results relate(如何修正结果)</p></li></ul><!-- 为什么Flink天生就是用来处理流的？？？？ window不也相当于一个微批吗？ --><blockquote><p>既然流处理有这么多的问题需要解决，那么为什么还要进行流计算？</p></blockquote><ol><li>在商业竞争中极度渴望更快的数据，而转换成流计算则是一个好的方法来降低延迟。</li><li>海量的、无穷数据集在现在的商业环境里变的越来越常见，而用专门设计来处理这样数据的系统来应对这些数据则更为容易。</li><li>在数据到达时就对他们进行处理能够更加平均地把负载进行均衡，取得更好的一致性和更可预测的计算资源消耗。</li></ol><!--流数据，when where what how 特点 无界    计算的结果是什么（What results are calculated）？ 通过transformations操作 transformations是以一个或多个stream作为输入的某种operation  数据集之间的转换    在事件时间中的哪个位置计算结果（Where in event time are results calculated）？ 使用窗口（windowing）的概念    在处理时间中的哪个时刻触发计算结果（When in processing time are results materialized）？ 使用triggers + watermarks进行触发计算    如何修正结果（How do refinements of results relate）？通过accumulation的类型修正结果数据--><h2 id="何为window"><a href="#何为window" class="headerlink" title="何为window"></a>何为window</h2><p>window回答了where这个问题，因为在流处理应用中，数据是连续不断的，我们不可能等到所有数据都到了才开始处理，况且我们也无法判断所有的数据何时能完整到来。而且在实际的环境中也需要做一些聚合计算，例如计算过去5分钟某个页面的UV，这就必须定义一个窗口，用来收集并计算这5分钟内的数据。所以window很好的回答了where这个问题，他决定了数据在哪里被计算。</p><p>window是无限流上一种核心机制，其按照时间边界对数据源进行切分，切分方式分为固定窗口、滑动窗口和会话窗口三种，同时，在可以在窗口内进行聚合，从而把源源不断产生的数据根据不同的条件划分成一段一段有边界的数据区间，使用户能够利用窗口功能实现很多复杂的统计分析需求。具体实现时，窗口又可以是严格按照时间来驱动，例如TimeWindow；也可以由数据驱动，例如CountWindow。切分方式如图<br><img src="/blogimgs/flink-window/windowing-chop.jpg" alt="window切分方式" title="window切分方式"></p><blockquote><p>固定窗口(Fixed windows)</p></blockquote><p>固定窗口按照固定的长度进行分片，这个固定的长度可以时间维度也可以是数据维度。如上图中红色的划分方式，这个固定的长度可以是每1分钟也可以是每100个元素。<br>固定窗口典型地会对所有的数据集进行等份划分，也叫对齐窗口。在某些情形下，可能会希望对不同的数据子集应用不同的相位偏移，从而能让分片的完整度更加的平均。这时就不再是对齐窗口，而是非对齐窗口。</p><blockquote><p>滑动窗口(Sliding windows)</p></blockquote><p>滑动窗口是固定窗口的一个更一般化的形式，滑动窗口一般会定义两个属性，即窗口大小（时间长短）和滑动时间。<strong>如果滑动时间比窗口要小，则窗口会重叠；如果相等，这就是固定窗口；如果滑动时间比窗口大，就产生了一种特殊的数据采样，也就是按时间只看数据集里的一部分子集的数据。</strong>类似于固定窗口，滑动窗口一般也是对齐的。出于性能考虑也会在某些情况下是非对齐的。需要注意的是，上图中蓝色部分为了能表明滑动的性质而没有把每个窗口对应到所有的键。实际情况里是都要对应到的。</p><blockquote><p>会话窗口(Sessions)</p></blockquote><p>会话是指在不活跃时间段之间的一连串事件，这个不活跃时间一般是设定的比超时的时间要长，会话窗口是一种动态窗口。<strong>会话单元一般用来做用户行为分析</strong>，即观察在一个会话单元里用户的一系列事件。会话单元的长度一般都没法提前确定，完全取决于实际数据的情况。会话单元也是非对齐窗口的一个经典案例，因为实际情况下，不同子集数据的会话单元长度几乎不可能一致地对齐。</p><p>一般而言，window是在无限的流上定义了一个有限的元素集合。这个集合可以是基于时间的，元素个数的，时间和个数结合的，会话间隙的，或者是自定义的。Flink提供了简洁的算子来满足常用的窗口操作，同时提供了通用的窗口机制来允许用户自己定义窗口分配逻辑。下面看下Flink内置的窗口。</p><h2 id="Flink提供的内置窗口使用及其实现"><a href="#Flink提供的内置窗口使用及其实现" class="headerlink" title="Flink提供的内置窗口使用及其实现"></a>Flink提供的内置窗口使用及其实现</h2><p>Flink将窗口的切分规则分为3种，3种切分规则Flink都有对应内置窗口实现，内置窗口包括滚动时间窗口、滑动时间窗口、滚动计数窗口、滑动计数窗口和会话窗口。这里为了方便将内置窗口分为3类进行介绍，依次为计数窗口countWindow、时间窗口timeWindow和会话窗口sessionWindow。</p><ul><li>计数窗口<br>计数窗口是根据元素个数对数据流进行分组的，分为滚动计数窗口和滑动计数窗口。使用计数窗口时先将DataStream转换为KeyedStream，然后通过调用countWindow函数进行使用。</li></ul><p>例如需要统计每100个订单中的总数，则使用滚动计数窗口，每100个元素滚动一次，代码实现为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream of (userId, buyCnts)</span></span><br><span class="line"><span class="keyword">val</span> buyCnts: <span class="type">DataStream</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> tumblingCnts: <span class="type">DataStream</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = buyCnts</span><br><span class="line">  .keyBy(<span class="number">0</span>)</span><br><span class="line">  <span class="comment">// 滚动计数窗口，每100个元素滚动一次</span></span><br><span class="line">  .countWindow(<span class="number">100</span>)</span><br><span class="line">  .sum(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>与滚动计数窗口相对的是滑动计数窗口，如果要计算每10个元素计算一次最近100个元素的总和，使用滑动窗口，窗口大小为100，每10个元素滑动一次，代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> slidingCnts: <span class="type">DataStream</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = vehicleCnts</span><br><span class="line">  .keyBy(<span class="number">0</span>)</span><br><span class="line">  <span class="comment">// 滑动计数窗口，窗口大小为100，每10个滑动一次</span></span><br><span class="line">  .countWindow(<span class="number">100</span>, <span class="number">10</span>)</span><br><span class="line">  .sum(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>使用方式很简单，这里看下countWindow的具体是如何实现的，两个countWindow函数代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动计数窗口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowedStream&lt;T, KEY, GlobalWindow&gt; <span class="title">countWindow</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> window(GlobalWindows.create()).trigger(PurgingTrigger.of(CountTrigger.of(size)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滑动计数窗口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowedStream&lt;T, KEY, GlobalWindow&gt; <span class="title">countWindow</span><span class="params">(<span class="keyword">long</span> size, <span class="keyword">long</span> slide)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> window(GlobalWindows.create())</span><br><span class="line">            .evictor(CountEvictor.of(size))</span><br><span class="line">            .trigger(CountTrigger.of(slide));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由countWindow的实现可以看出window丰富的功能是由一些关键组件组合实现的，这些组件包括evictor和trigger。两者使用的窗口分配器都是<code>GlobalWindows</code>，两者的区别是trigger，因为GlobalWindows的默认trigger是<code>NeverTrigger</code>，意思是不触发窗口计算。滚动窗口的trigger是将<code>CountTrigger</code>封装成<code>PurgingTrigger</code>，根据窗口分配的元素个数进行触发计算，并且在计算之后清除窗口中的数据，从而达到滚动窗口的效果。滑动窗口的trigger只是一个单纯的<code>CountTrigger</code>，根据滑动元素的个数进行计算，由于countWindow使用的是GlobalWindows，只有一共全局窗口，trigger触发计算时又只是单纯的计算结果，并未像滚动窗口那样清除数据，所以滑动窗口中的数据会越来越多，不仅性能上会受影响，而且数据也可能会被重复计算，这里增加了evictor对数据进行过滤。</p><!-- 计数窗口无论是滚动还是滑动窗口，都只有一个窗口，是一个全局窗口，不像时间窗口那样，一个元素可以归属多个窗口 --><ul><li>时间窗口<br>时间窗口是根据时间对数据流进行分组对，也分为滚动时间窗口和滑动时间窗口。时间窗口按照时间划分，这个时间在Flink中有三种概念，分别是event time(事件时间：事件发生时的时间)，ingestion time(摄取时间：事件进入流处理系统的时间)，processing time(处理时间：消息被计算处理的时间)。<strong>注：Flink 中窗口机制和时间类型是完全解耦的，也就是说当需要改变时间类型时不需要更改窗口逻辑相关的代码。</strong></li></ul><p>例如我们需要统计每一分钟中用户购买的商品的总数，需要将用户的行为事件按每一分钟进行切分汇总，这种切分被称为滚动时间窗口，代码如下:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream of (userId, buyCnt)</span></span><br><span class="line"><span class="keyword">val</span> buyCnts: <span class="type">DataStream</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = ...</span><br><span class="line"><span class="comment">// 将DataStream转换为KeyedStream，然后再使用窗口函数</span></span><br><span class="line"><span class="keyword">val</span> tumblingCnts: <span class="type">DataStream</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = buyCnts</span><br><span class="line">  .keyBy(<span class="number">0</span>) </span><br><span class="line">  <span class="comment">// 窗口长度为1分钟的滚动时间窗口</span></span><br><span class="line">  .timeWindow(<span class="type">Time</span>.minutes(<span class="number">1</span>))</span><br><span class="line">  .sum(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>窗口计算时，可以选择窗口切分时使用的时间方式，默认使用的是processtime，使用<code>env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)</code>对时间方式进行更改。</p><p>时间窗口的另一种方式是滑动时间窗口，主要用于平滑地进行窗口聚合计算。如果，需要每分钟统计下最近5分钟用户购买的商品总数，就可以使用滑动时间窗口进行计算，代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> slidingCnts: <span class="type">DataStream</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = buyCnts</span><br><span class="line">  .keyBy(<span class="number">0</span>) </span><br><span class="line">  <span class="comment">// 窗口长度为5分钟，每1分钟滑动一次</span></span><br><span class="line">  .timeWindow(<span class="type">Time</span>.minutes(<span class="number">5</span>), <span class="type">Time</span>.minutes(<span class="number">1</span>))</span><br><span class="line">  .sum(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>时间窗口使用时依然很简单方便，将DataStream流转换为KeyedStream流，调用<code>timeWindow</code>进行使用，传入一个参数代表滚动时间窗口，传入两个参数时代表滑动时间窗口，其中第一个参数代表窗口的长度，第二个参数代表滑动的长度。其具体的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动时间窗口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowedStream&lt;T, KEY, TimeWindow&gt; <span class="title">timeWindow</span><span class="params">(Time size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (environment.getStreamTimeCharacteristic() == TimeCharacteristic.ProcessingTime) &#123;</span><br><span class="line">        <span class="keyword">return</span> window(TumblingProcessingTimeWindows.of(size));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> window(TumblingEventTimeWindows.of(size));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滑动时间窗口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowedStream&lt;T, KEY, TimeWindow&gt; <span class="title">timeWindow</span><span class="params">(Time size, Time slide)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (environment.getStreamTimeCharacteristic() == TimeCharacteristic.ProcessingTime) &#123;</span><br><span class="line">        <span class="keyword">return</span> window(SlidingProcessingTimeWindows.of(size, slide));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> window(SlidingEventTimeWindows.of(size, slide));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>时间窗口的实现比计数窗口较复杂，每种窗口类型根据不同的时间设置都有专门的实现，滚动窗口的实现是<code>TumblingProcessingTimeWindows</code>和<code>TumblingEventTimeWindows</code>，而滑动窗口的实现是<code>SlidingProcessingTimeWindows</code>和<code>SlidingEventTimeWindows</code>。<code>TumblingProcessingTimeWindows</code>和<code>TumblingEventTimeWindows</code>的实现逻辑一样，都是根据元素的时间指定一个时间窗口<code>TimeWindow</code>，每个元素只能属于一个窗口，不同点只是触发计算的trigger，根据设置的时间策略指定相应的trigger，其中<code>TumblingProcessingTimeWindows</code>的trigger是<code>ProcessingTimeTrigger</code>，<code>TumblingEventTimeWindows</code>的trigger是<code>EventTimeTrigger</code>。<code>SlidingProcessingTimeWindows</code>和<code>SlidingEventTimeWindows</code>划分窗口的逻辑跟<code>TumblingProcessingTimeWindows</code>和<code>TumblingEventTimeWindows</code>一样，只是滑动窗口中一个元素可以归属多个窗口，所以返回的是一个窗口集合，至于触发器trigger和滚动窗口中的一样。</p><ul><li>会话窗口<br>此处的会话类似浏览页面时所指的会话，会话窗口并没有固定时间长度，而是根据事件之间的时间间隔来决定的，如果两个事件之间的时间间隔超过阈值，则被划分到不同的窗口中。例如，需要计算每个用户在活跃期间总共购买的商品数量，由于每个用户的活跃时长不固定，不能统一设置窗口时长，所以此时应该使用会话窗口，代码如下：</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream of (userId, buyCnts)</span></span><br><span class="line"><span class="keyword">val</span> buyCnts: <span class="type">DataStream</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sessionCnts: <span class="type">DataStream</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = vehicleCnts</span><br><span class="line">  .keyBy(<span class="number">0</span>)</span><br><span class="line">  <span class="comment">// 事件之间超过30秒则划分新窗口</span></span><br><span class="line">  .window(<span class="type">ProcessingTimeSessionWindows</span>.withGap(<span class="type">Time</span>.seconds(<span class="number">30</span>)))</span><br><span class="line">  .sum(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>使用会话窗口调用<code>KeydeStream.window</code>方法，同样此方法也在<code>countWindow</code>和<code>timeWindow</code>中被调用，并没有为会话窗口封装单独的函数，使用时传入对应时间的会话窗口分配器即可。</p><!--滚动窗口其实是滑动窗口的一种特殊情况--><!--全天UV日增UV过滤每5分钟未下单的订单    滚动窗口--><h2 id="窗口进阶"><a href="#窗口进阶" class="headerlink" title="窗口进阶"></a>窗口进阶</h2><p>内置窗口使用比较简单，<code>WindowedStream</code>也提供了一些简单的计算函数，但是如果自定义一些计算逻辑时就用到了窗口函数。<br>窗口函数分为ReduceFunction、AggregateFunction、FoldFunction和ProcessWindowFunction。前两个是增量聚合函数，性能比较高效；ProcessWindowFunction中会包含一个迭代器，这个迭代器中记录了窗口中的所有元素，除此之外还包含一些窗口的元信息。接下来看下每个窗口函数具体怎么用。</p><ul><li>ReduceFunction<br>将输入的两个元素进行计算，得到一个相同类型的元素做为输出。此函数是增量的对窗口中的元素进行计算，类似于MR中Reduce。具体使用代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(&lt;window assigner&gt;)</span><br><span class="line">    .reduce(<span class="keyword">new</span> ReduceFunction&lt;Tuple2&lt;String, Long&gt;&gt; &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Long&gt; <span class="title">reduce</span><span class="params">(Tuple2&lt;String, Long&gt; v1, Tuple2&lt;String, Long&gt; v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(v1.f0, v1.f1 + v2.f1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><ul><li>AggregateFunction<br>AggregateFunction也是一个增量聚合窗口函数，比ReduceFunction更加通用，包含三个参数，第一个是窗口流中输入的元素，第二个是累加器，第三个元素是计算之后的输出，累加器和输出结果的类型都可以自定义。使用样例如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AverageAggregate</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">AggregateFunction</span>&lt;<span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Long</span>&gt;, <span class="title">Tuple2</span>&lt;<span class="title">Long</span>, <span class="title">Long</span>&gt;, <span class="title">Double</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title">createAccumulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(<span class="number">0L</span>, <span class="number">0L</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title">add</span><span class="params">(Tuple2&lt;String, Long&gt; value, Tuple2&lt;Long, Long&gt; accumulator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(accumulator.f0 + value.f1, accumulator.f1 + <span class="number">1L</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Double <span class="title">getResult</span><span class="params">(Tuple2&lt;Long, Long&gt; accumulator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">double</span>) accumulator.f0) / accumulator.f1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title">merge</span><span class="params">(Tuple2&lt;Long, Long&gt; a, Tuple2&lt;Long, Long&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(a.f0 + b.f0, a.f1 + b.f1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(&lt;window assigner&gt;)</span><br><span class="line">    .aggregate(<span class="keyword">new</span> AverageAggregate());</span><br></pre></td></tr></table></figure><ul><li>FoldFunction<br>窗口中的元素与累加器进行计算，此时累加器有初始值，并且输出的结果类型和累加器相同。此窗口函数不能用在合并窗口中，比如会话窗口。使用样例代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(&lt;window assigner&gt;)</span><br><span class="line">    .fold(<span class="string">&quot;&quot;</span>, <span class="keyword">new</span> FoldFunction&lt;Tuple2&lt;String, Long&gt;, String&gt;&gt; &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">fold</span><span class="params">(String acc, Tuple2&lt;String, Long&gt; value)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> acc + value.f1;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><ul><li>ProcessWindowFunction<br>ProcessWindowFunction最灵活，包含的信息也较多，可以对整个窗口中的元素进行迭代计算，还可以访问窗口的一些元信息。但是单纯使用ProcessWindowFunction时，由于要缓存窗口中的所有元素，所以会消耗一些资源。使用样例代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">  .keyBy(t -&gt; t.f0)</span><br><span class="line">  .timeWindow(Time.minutes(<span class="number">5</span>))</span><br><span class="line">  .process(<span class="keyword">new</span> MyProcessWindowFunction());</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProcessWindowFunction</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Long</span>&gt;, <span class="title">String</span>, <span class="title">String</span>, <span class="title">TimeWindow</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String key, Context context, Iterable&lt;Tuple2&lt;String, Long&gt;&gt; input, Collector&lt;String&gt; out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Tuple2&lt;String, Long&gt; in: input) &#123;</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">    out.collect(<span class="string">&quot;Window: &quot;</span> + context.window() + <span class="string">&quot;count: &quot;</span> + count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProcessWindowFunction中记录的窗口信息在抽象类Context中，ProcessWindowFunction抽象类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">IN</span>, <span class="title">OUT</span>, <span class="title">KEY</span>, <span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window</span>&gt; <span class="keyword">implements</span> <span class="title">Function</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            KEY key,</span></span></span><br><span class="line"><span class="params"><span class="function">            Context context,</span></span></span><br><span class="line"><span class="params"><span class="function">            Iterable&lt;IN&gt; elements,</span></span></span><br><span class="line"><span class="params"><span class="function">            Collector&lt;OUT&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The context holding window metadata.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * Returns the window that is being evaluated.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> W <span class="title">window</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/** Returns the current processing time. */</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">currentProcessingTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/** Returns the current event-time watermark. */</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">currentWatermark</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * State accessor for per-key and per-window state.</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt;If you use per-window state you have to ensure that you clean it up</span></span><br><span class="line"><span class="comment">            * by implementing &#123;<span class="doctag">@link</span> ProcessWindowFunction#clear(Context)&#125;.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> KeyedStateStore <span class="title">windowState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * State accessor for per-key global state.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> KeyedStateStore <span class="title">globalState</span><span class="params">()</span></span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然ProcessWindowFunction比较耗资源，但是在有些场景下他可以和之前介绍的增量聚合窗口函数一起使用，这样不仅可以将元素进行增量聚合减少资源消耗，也可以访问ProcessWindowFunction中记录的窗口元信息。下面的例子是ReduceFunction和ProcessWindowFunction结合使用的，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;SensorReading&gt; input = ...;</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">  .keyBy(&lt;key selector&gt;)</span><br><span class="line">  .timeWindow(&lt;duration&gt;)</span><br><span class="line">  .reduce(<span class="keyword">new</span> MyReduceFunction(), <span class="keyword">new</span> MyProcessWindowFunction());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function definitions</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReduceFunction</span> <span class="keyword">implements</span> <span class="title">ReduceFunction</span>&lt;<span class="title">SensorReading</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SensorReading <span class="title">reduce</span><span class="params">(SensorReading r1, SensorReading r2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> r1.value() &gt; r2.value() ? r2 : r1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProcessWindowFunction</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">SensorReading</span>, <span class="title">Tuple2</span>&lt;<span class="title">Long</span>, <span class="title">SensorReading</span>&gt;, <span class="title">String</span>, <span class="title">TimeWindow</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String key,</span></span></span><br><span class="line"><span class="params"><span class="function">                    Context context,</span></span></span><br><span class="line"><span class="params"><span class="function">                    Iterable&lt;SensorReading&gt; minReadings,</span></span></span><br><span class="line"><span class="params"><span class="function">                    Collector&lt;Tuple2&lt;Long, SensorReading&gt;&gt; out)</span> </span>&#123;</span><br><span class="line">      SensorReading min = minReadings.iterator().next();</span><br><span class="line">      out.collect(<span class="keyword">new</span> Tuple2&lt;Long, SensorReading&gt;(context.window().getStart(), min));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="窗口底层实现"><a href="#窗口底层实现" class="headerlink" title="窗口底层实现"></a>窗口底层实现</h2><p>窗口的实现包含三个组件，分别是窗口分配器(WindowAssigner)、触发器(Trigger)和驱逐器(Evictor)。其中窗口分配器决定元素该分发到哪个窗口；触发器决定窗口中的元素何时计算或者清除该窗口中的元素，每个窗口都有自己的trigger；驱逐器类似过滤器，根据一定规则将窗口中部分数据清除掉。将这三个组件的不同实现组合在一起，就能实现各种窗口计算。</p><ul><li>窗口分配器(WindowAssigner)</li></ul><blockquote><p>先看下核心函数<br>assignWindows: 将对应的元素分配到指定的窗口中<br>getDefaultTrigger: 获取该窗口分配器默认指定的Trigger<br>isEventTime: 是否基于event time对元素进行分配</p></blockquote><p>countWindow中用的是GlobalWindow，所以该分配器只是返回当前窗口即可。<br>重点看下timeWindow的assignWindows方法，这里只关注下<code>SlidingEventTimeWindows</code>的<code>assignWindows</code>，因为滚动窗口的分配逻辑和滑动窗口类似。<code>SlidingEventTimeWindows.assignWindows</code>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;TimeWindow&gt; <span class="title">assignWindows</span><span class="params">(Object element, <span class="keyword">long</span> timestamp, WindowAssignerContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timestamp &gt; Long.MIN_VALUE) &#123;</span><br><span class="line">        <span class="comment">// 计算窗口可以有多少个滑动窗口</span></span><br><span class="line">        List&lt;TimeWindow&gt; windows = <span class="keyword">new</span> ArrayList&lt;&gt;((<span class="keyword">int</span>) (size / slide));</span><br><span class="line">        <span class="comment">// 当前元素时间所在的最近窗口的起始位置</span></span><br><span class="line">        <span class="keyword">long</span> lastStart = TimeWindow.getWindowStartWithOffset(timestamp, offset, slide);</span><br><span class="line">        <span class="comment">// 生成该元素的窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> start = lastStart;</span><br><span class="line">            start &gt; timestamp - size;</span><br><span class="line">            start -= slide) &#123;</span><br><span class="line">            <span class="comment">// 窗口的区间是前闭后开</span></span><br><span class="line">            windows.add(<span class="keyword">new</span> TimeWindow(start, start + size));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> windows;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Record has Long.MIN_VALUE timestamp (= no timestamp marker). &quot;</span> +</span><br><span class="line">                <span class="string">&quot;Is the time characteristic set to &#x27;ProcessingTime&#x27;, or did you forget to call &quot;</span> +</span><br><span class="line">                <span class="string">&quot;&#x27;DataStream.assignTimestampsAndWatermarks(...)&#x27;?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码逻辑在<code>TimeWindow.getWindowStartWithOffset</code>中，代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Method to get the window start for a timestamp.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timestamp epoch millisecond to get the window start.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset The offset which window start would be shifted by.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> windowSize The size of the generated windows.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> window start</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 滑动窗口和滚动窗口都是调用这个函数获取窗口的起始位置</span></span><br><span class="line"><span class="comment"> * 滑动窗口传入的windowSize是滑动的大小，对于滑动窗口按照slide滑动，其实可以理解成长度为slide的滚动窗口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getWindowStartWithOffset</span><span class="params">(<span class="keyword">long</span> timestamp, <span class="keyword">long</span> offset, <span class="keyword">long</span> windowSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// offset 可以理解成最开始到那个窗口的起始位置</span></span><br><span class="line">    <span class="comment">// timestamp - offset 为 到最开始那个窗口的距离</span></span><br><span class="line">    <span class="comment">// (timestamp - offset + windowSize) % windowSize 离最近窗口的距离，相当于timestamp - offset - windowSize - windowSize ...</span></span><br><span class="line">    <span class="comment">// timestamp - (timestamp - offset + windowSize) % windowSize 则为最近窗口的起始位置</span></span><br><span class="line">    <span class="keyword">return</span> timestamp - (timestamp - offset + windowSize) % windowSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>触发器(Trigger)</li></ul><blockquote><p>先看下核心函数<br>onElement: 处理每个添加到窗口中的元素<br>onEventTime: TriggerContext中注册的event-time timer被触发时调用<br>onProcessingTime: TriggerContext中注册的processing-time timer被触发时调用<br>onMerge: window被merge时触发</p></blockquote><p>在WindowAssigner中，会调用getDefaultTrigger得到该窗口的默认触发器。这里看下<code>SlidingEventTimeWindows</code>的默认trigger–<code>EventTimeTrigger</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TriggerResult <span class="title">onElement</span><span class="params">(Object element, <span class="keyword">long</span> timestamp, TimeWindow window, TriggerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// element 所在的 window，maxTimestamp为end-1</span></span><br><span class="line">    <span class="comment">// wartermark是定期生成的，maxTimestamp正常应该是大于wartermark的</span></span><br><span class="line">    <span class="comment">// window的maxTimestamp是不变的，wartermark是周期性变化的</span></span><br><span class="line">    <span class="comment">// 则onElement一般不会触发FIRE</span></span><br><span class="line">    <span class="comment">// 迟到时会触发</span></span><br><span class="line">    <span class="comment">// 假如一直没有迟到的数据到达是不是就不会在这里触发，</span></span><br><span class="line">    <span class="comment">// 假如迟到的数据到达了，但是该窗口已经由Time触发了FIRE怎么办？？</span></span><br><span class="line">    <span class="comment">// 迟到和乱序的理解：迟到会再次触发window计算，乱序是window等待一段时间进行计算，只计算一次。</span></span><br><span class="line">    <span class="comment">// 迟到会触发多次，只要在规定的最大迟到时间内都会触发计算</span></span><br><span class="line">    <span class="keyword">if</span> (window.maxTimestamp() &lt;= ctx.getCurrentWatermark()) &#123;</span><br><span class="line">        <span class="comment">// if the watermark is already past the window fire immediately</span></span><br><span class="line">        <span class="keyword">return</span> TriggerResult.FIRE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.registerEventTimeTimer(window.maxTimestamp());</span><br><span class="line">        <span class="keyword">return</span> TriggerResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一秒中的第一条数据触发窗口计算，那这之后的数据怎么计算？</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TriggerResult <span class="title">onEventTime</span><span class="params">(<span class="keyword">long</span> time, TimeWindow window, TriggerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> time == window.maxTimestamp() ?</span><br><span class="line">        TriggerResult.FIRE :</span><br><span class="line">        TriggerResult.CONTINUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!--ContinuousEventTimeTrigger：指定的 interval 以及 event window 的边界小于当前 watermark 时触发 onEventTime 计算ContinuousProessingTimeTrigger：指定的 interval 触发 onProcessingTime 计算CountTrigger: 指定的 maxCount 触发，出发后 maxCount 清零重新累加DeltaTrigger: 提供 delta 函数和历史 datapoint 存储，每个元素消费时触发 delta 函数计算EventTimeTrigger：event window 的边界小于当前 watermark 时触发 onEventTime 计算  是小于还是大于？？？ProessingTimeTrigger：event window 的边界小于当前 watermark 时触发 onProcessingTime 计算--><ul><li>驱逐器(Evictor)</li></ul><blockquote><p>先看下核心函数<br>evictBefore: 在触发窗口函数计算之前对窗口中的元素进行过滤<br>evictAfter: 在触发窗口函数计算之后对窗口中的元素进行过滤<br>evict: 过滤窗口中元素的具体实现，在evictBefore或者evictAfter内调用</p></blockquote><p>完整的窗口计算流程，经历了 Window Assigner -&gt; Trigger -&gt; Evictor -&gt; Evaluation Function 的过程，最终获得结果。</p><!--何为window，window类型，如何使用以及自定义 window function实例用起来很爽，但是window是怎么实现的呢？如何实现，借助trigger ev watermarktrigger计时器的作用？在哪用？ 如何触发？ 是定时器还是watermark    trigger会生成窗口，trigger计时器到之后进行窗口function计算触发器（Trigger）提供了一种灵活的机制来决定窗口的计算结果在什么时候对外输出。理论上来说，只有两种类型的触发器，大部分的应用都是选择其一或组合使用：Repeated update triggers：重复更新窗口的计算结果，更新可以是由新消息到达时触发，也可以是每个一段时间（如1分钟）进行触发Completeness triggers：在窗口结束时进行触发，这是更符合直觉的使用方法，也和批处理模式的计算结果相吻合。但是需要一种机制来衡量一个窗口的所有消息都已经被正确地处理了。ev 利用状态进行过滤watermark   Watermark 是用来追踪业务事件的概念，可以理解成 EventTime 世界中的时钟，用来指示当前处理到什么时刻的数据了    水印是针对事件时间的概念，提供了一种事件时间相对于处理时间是乱序的系统中合理推测无界数据集里数据完整性的工具    何为watermark    有何作用    如何生成   自动生成 setAutoWatermarkInterval    watermark与trigger如何相互作用    一个窗口可以有多个watermark，多个watermark如何触发窗口的，当前watermark触发上一个窗口的计算？？？    当前系统的 watermark 为时间 T，那么系统认为所有事件时间小于 T 的消息都已经到达，即系统任务它不会再接收到事件时间小于 T 的消息了多流乱序    watermark 大的数据会缓存吗？https://www.jianshu.com/p/b9b23a7cb880https://www.jianshu.com/p/c8c789ff5570window 都提供了window operator    在windowedStream中的windowFunction指定windowOperator综合early fire、late fire、水印时间与窗口结束时间，综合判断是否触发窗口当未来某个watermark的时间戳大于该trigger的注册时间时，就会触发trigger，执行该trigger所在的window operator的window process进行计算。WindowOperator 定义了window assigner, trigger, windowProcessFunction 的执行顺序如何，它们之间的执行逻辑等trigger过期还是窗口过期 watermark过期Timer怎么触发？apply：自定义window functionprocessElement处理数据流程：a、 获取当前record具有的事件时间，如果是Processing Time模式，从时间服务Service里面获取时间即可b、使用上一步获取的时间，接着调用windowFunction.assignWindow生成窗口，其内部实际上是调用各类型的WindowAssigner生成窗口，windowFunction有三大类，分别是Paned（滑动）、Merge（会话）、General（前两种以外的），WindowAssigner类型大致有5类，分别是Tumbling（翻转）、Sliding（滑动）、Session（会话）、CountTumbling 、CountSlide这几类,根据输入的一条数据和时间，可以生成1到多个窗口c、接下来是遍历涉及的窗口进行聚合，包括从windowState获取聚合前值、使用句柄进行聚合、更新状态至windowState，将当前转态d、上一步聚合完成后，就可以遍历窗口，使用TriggerContext（其实就是不同类型窗口Trigger触发器的代理），综合early fire、late fire、水印时间与窗口结束时间，综合判断是否触发窗口写出e、如果TriggerContext判断出触发条件为true，则调用emitWindowResult写出，其内部有retract判断，更新当前state及previous state，写出数据等操作f、如果TriggerContext判断出触发条件为false，则触发需要注册cleanupTimer,到达指定时间后，触发onEventTime或onProcessingTimeg、onEventTime或onProcessingTime功能十分类似，首先会触发emitWindowResult提交结果，另外会判断窗口结束时间+Lateness和当前时间是否相等，相等则表示可以清除窗口数据、当前state及previous state、窗口对应trigger。元素在streaming dataflow引擎中流动到WindowOperator时，会被分为两拨，分别是普通事件和水印。WatermarkAssignerOperator.advanceWatermark -> OperatorChain.emitWatermark -> operator.processWatermark-->]]></content>
    
    
    <summary type="html">&lt;p&gt;近几年流处理简直火的一塌糊涂，Flink也在阿里的推广下逐渐成为业界主流，正在逐步取代Storm和Spark Streaming。&lt;br&gt;Flink天生就是为了处理流，而且相对于其他流处理框架集成了很多实用功能，比如状态管理；Flink还丰富了window的功能，使window也成为了Flink的一个特色。&lt;br&gt;本篇主要对window从多种角度进行解密，主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;何为window&lt;/li&gt;
&lt;li&gt;如何使用&lt;/li&gt;
&lt;li&gt;如何实现&lt;/li&gt;
&lt;li&gt;各组件原理&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在解密window之前，简单介绍下何为流处理？&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Flink" scheme="http://yuanba.tech/categories/Flink/"/>
    
    
    <category term="BigData" scheme="http://yuanba.tech/tags/BigData/"/>
    
    <category term="Flink" scheme="http://yuanba.tech/tags/Flink/"/>
    
    <category term="window" scheme="http://yuanba.tech/tags/window/"/>
    
  </entry>
  
  <entry>
    <title>golang新手入门</title>
    <link href="http://yuanba.tech/golang-newbie.html"/>
    <id>http://yuanba.tech/golang-newbie.html</id>
    <published>2019-11-02T03:33:12.000Z</published>
    <updated>2019-11-02T03:33:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go开发环境配置"><a href="#Go开发环境配置" class="headerlink" title="Go开发环境配置"></a>Go开发环境配置</h2><p>​    选择操作系统对应的版本，可以直接下载安装包进行一键安装，也可以下载tar/zip包进行自定义安装。自定义安装时需要在环境变量中指定<code>GOROOT</code>和<code>GOPATH</code>，<code>GOROOT</code>是tar包的解压目录，<code>GOPATH</code>是Go工程项目目录，这里不仅存储这自己开发的项目也存放着项目所依赖包的源码及二进制文件。</p><span id="more"></span><h2 id="Go项目目录"><a href="#Go项目目录" class="headerlink" title="Go项目目录"></a>Go项目目录</h2><p>​    使用某种编程语言或者某个编程框架开发的项目都有自己特有的目录结构，所以学习一门新语言或者编程框架时要先熟悉其项目的工程目录结构。Go的工程目录是一个层级目录，第一层有两个目录<code>bin</code>和<code>src</code>两个目录，<code>bin</code>文件中存放的是Go编译之后的可执行文件，<code>src</code>文件夹中存放的都是项目源文件，项目的目录结构可根据代码功能进行划分。Go工程项目结构样例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bin/</span><br><span class="line">    hello                          <span class="comment"># command executable</span></span><br><span class="line">    outyet                         <span class="comment"># command executable</span></span><br><span class="line">src/</span><br><span class="line">    github.com/golang/example/</span><br><span class="line">        .git/                      <span class="comment"># Git repository metadata</span></span><br><span class="line">        hello/</span><br><span class="line">            hello.go               <span class="comment"># command source</span></span><br><span class="line">        outyet/</span><br><span class="line">            main.go                <span class="comment"># command source</span></span><br><span class="line">            main_test.go           <span class="comment"># test source</span></span><br><span class="line">        stringutil/</span><br><span class="line">            reverse.go             <span class="comment"># package source</span></span><br><span class="line">            reverse_test.go        <span class="comment"># test source</span></span><br><span class="line">    golang.org/x/image/</span><br><span class="line">        .git/                      <span class="comment"># Git repository metadata</span></span><br><span class="line">        bmp/</span><br><span class="line">            reader.go              <span class="comment"># package source</span></span><br><span class="line">            writer.go              <span class="comment"># package source</span></span><br><span class="line">    ... (many more repositories and packages omitted) ...</span><br></pre></td></tr></table></figure><p>上面的<code>src</code>目录有两个Go项目，分别是<code>example</code>和<code>image</code>。<code>example</code>中有三个文件夹，其中<code>hello</code>和<code>outyet</code>分别包含可执行命令的文件，<code>stringutil</code>是一个工具包。<code>image</code>中没有包含可执行命令的文件，只有一个bmp的工具包和其它工具包。通过<code>go install</code>命令编译<code>example</code>项目会<code>bin</code>目录中增加两个可执行文件<code>hello</code>和<code>outyet</code></p><p>​    Go的工程目录其实就是在上一节中设置的<code>GOPATH</code>，默认目录名是<code>go</code>，会当前用户home目录下创建此文件夹，例如Linux为<code>$HOME/go</code>，win为<code>C:\Users\YourName\go</code>。可以通过<code>export GOPATH=xx</code>设置任意目录，不过不能是Go的安装目录，也就是<code>GOROOT</code>。</p><p>​    Go提供了<code>env</code>命令，它可以输出环境变量的值，例如执行命令<code>go env GOPATH</code>，如果为了执行Go编译的可执行文件方便，可将<code>GOPATH</code>目录添加到PATH环境变量里，增加<code>export PATH=$PATH:$(go env GOPATH)/bin</code></p><h2 id="Go-Go-Go"><a href="#Go-Go-Go" class="headerlink" title="Go Go Go!"></a>Go Go Go!</h2><p>​    环境部署好，也熟悉了Go项目的目录结构，下面来个<code>Go Go Go!</code>找下Hello World的感觉。在<code>$GOPATH/src</code>目录下创建项目文件夹go-test，然后在此目录新建一个<code>hello.go</code>的文件，内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello, Go Go Go!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是在IDE中可以直接点击右键执行，也可以在命令行执行<code>go run hello.go </code>执行。Go可以生成可执行文件执行运行，执行命令<code>go install go-test</code>，其中go-test是项目相对于GOPATH的相对路径，也可以直接在go-test目录下执行<code>go install</code>，此命令成功之后会在<code>$GOPATH/bin</code>目录下增加一个<code>go-test</code>的可执行文件（如果是win，则是<code>go-test.exe</code>）。<code>go install</code>没有任何输出代表执行成功，执行异常时会有错误输出，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  go-test go install</span><br><span class="line"><span class="comment"># go-test</span></span><br><span class="line">./t.go:3:6: main redeclared <span class="keyword">in</span> this block</span><br><span class="line">        previous declaration at ./hello.go:8:6</span><br></pre></td></tr></table></figure><p>执行成功可以直接执行<code>$GOPATH/bin/go-test</code>。</p><p>​    Go和其它语言类似，也需要在文件开头引入一些包，使用命令<code>import</code>，例如<code>hello.go</code>中的<code>import &quot;fmt&quot;</code>，<code>fmt</code>是Go自带的标准依赖包，如果要引用其它依赖包则需要依赖包在<code>$GOPATH</code>中的相对路径，这个相对路径是每个依赖包的唯一标识。</p><p>​    由于Go语言天生的开源特性，很多依赖包的开源作者都习惯使用GitHub来管理自己的代码，在import时写<code>github.com/user/pro</code>即可，而且还可以选择不同的版本，方便的很。所以我们也可以在<code>$GOPATH</code>中创建自己的GitHub目录（即使你没有GitHub账号，但为了方便你某一天想把自己的代码开源出去让更多的人使用），假如Github账号是go-test，创建目录<code>mkdir -p $GOPATH/src/github.com/go-test</code>，然后将上面的<code>hello.go</code>代码移到该目录中。</p><p>​    如果在代码中引入了Github上的第三方依赖包，使用<code>go get github.com/user/pro</code>下载依赖到本地$GOPATH中，如何引入自己开发的第三方依赖包呢或者如何开发一个依赖包。</p><p>​    开发一个依赖包首先想一个包名，这个包名在自己开发的项目中不能重复，因为Go导入第三方依赖时是导入包路径。这里给<code>hello.go</code>增加一个<code>stringutil</code>的依赖，创建目录<code>mkdir $GOPATH/src/github.com/go-test/stringutil</code>，在此目录中新建一个 <code>reverse.go</code>的文件，复制如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package stringutil contains utility functions for working with strings.</span></span><br><span class="line"><span class="keyword">package</span> stringutil</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reverse returns its argument string reversed rune-wise left to right.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">r := []<span class="keyword">rune</span>(s)</span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(r)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(r)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">r[i], r[j] = r[j], r[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依赖包使用 <code>go build</code>进行编译，命令执行之后与<code>go install</code>一样不会打印任何信息，不同的是<code>go install</code>会在<code>$GOPATH/bin</code>中输出一个二进制文件，而 <code>go build</code>没有任何输出，只是将编译的结果放入本地build cache中。</p><p>​    依赖包编译成功之后就可以引用了，在上述的<code>hello.go</code>中添加依赖，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/go-test/stringutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello, Go Go Go!&quot;</span>)</span><br><span class="line">fmt.Println(stringutil.Reverse(<span class="string">&quot;!oG ,olleH&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>go install</code>，随后就可以执行<code>go-test</code>。</p><p>​    写完上面的代码，此时可能有些疑问为什么<code>hello.go</code>的package是<code>main</code>，而 <code>reverse.go</code>的package是<code>stringutil</code>。Go代码的第一行必须是<code>package name</code>，这个name一般为当前文件所在的目录名，例如<code>reverse.go</code>在<code>stringutil</code>目录中，则第一行为<code>package stringutil</code>，这个name也是依赖此包时导入路径的最后一个目录，如<code>hello.go</code>中要依赖的源码是 <code>reverse.go</code>，而它在<code>stringutil</code>目录中，所以添加<code>import &quot;github.com/go-test/stringutil&quot;</code>。需要注意的是某个package中的所有文件必须有一样的name，而且如果包含可执行命令，name必须为<code>main</code>，也就是像<code>hello.go</code>那样，而且还得包含<code>func main()</code>。</p><!-- 可执行文件的名字是怎么来的？？？？ 目录名 --><h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><p>​    了解上述内容其实就可以去玩Go了，但是在玩的过程中可能会遇到给文件起名字时以 <code>_test.go</code>的问题，在其它语言中对文件名字的内容并没有限制，但在Go中有限制，如果以 <code>_test.go</code>结尾则代表这是一个测试类。</p><p>​    Go有一个轻量的测试框架，使用时导入 <code>testing</code>包，执行<code>go test</code> 。使用测试框架时，创建一个以<code>_test.go</code>结尾文件，测试某个func的方法名为<code>func TestXXX(t *testing.T)</code>，如果这个测试方法调用了 <code>t.Error</code> 或者 <code>t.Fail</code>则认为测试失败。给上述 <code>reverse.go</code>添加一个测试类，在stringutil文件中创建<code>reverse_test.go</code>，复制如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stringutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReverse</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">cases := []<span class="keyword">struct</span> &#123;</span><br><span class="line">in, want <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;<span class="string">&quot;Hello, world&quot;</span>, <span class="string">&quot;dlrow ,olleH&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Hello, 世界&quot;</span>, <span class="string">&quot;界世 ,olleH&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> cases &#123;</span><br><span class="line">got := Reverse(c.in)</span><br><span class="line"><span class="keyword">if</span> got != c.want &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Reverse(%q) == %q, want %q&quot;</span>, c.in, got, c.want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行<code>go test github.com/go-test/stringutil</code>或者直接在stringutil目录中执行<code>go test</code>，执行成功输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> github.com/go-test/stringutil</span><br><span class="line">ok  github.com/user/stringutil 0.165s</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Go开发环境配置&quot;&gt;&lt;a href=&quot;#Go开发环境配置&quot; class=&quot;headerlink&quot; title=&quot;Go开发环境配置&quot;&gt;&lt;/a&gt;Go开发环境配置&lt;/h2&gt;&lt;p&gt;​    选择操作系统对应的版本，可以直接下载安装包进行一键安装，也可以下载tar/zip包进行自定义安装。自定义安装时需要在环境变量中指定&lt;code&gt;GOROOT&lt;/code&gt;和&lt;code&gt;GOPATH&lt;/code&gt;，&lt;code&gt;GOROOT&lt;/code&gt;是tar包的解压目录，&lt;code&gt;GOPATH&lt;/code&gt;是Go工程项目目录，这里不仅存储这自己开发的项目也存放着项目所依赖包的源码及二进制文件。&lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://yuanba.tech/categories/golang/"/>
    
    
    <category term="go" scheme="http://yuanba.tech/tags/go/"/>
    
    <category term="golang" scheme="http://yuanba.tech/tags/golang/"/>
    
    <category term="菜鸟" scheme="http://yuanba.tech/tags/%E8%8F%9C%E9%B8%9F/"/>
    
    <category term="环境" scheme="http://yuanba.tech/tags/%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>YARN Capacity Scheduler</title>
    <link href="http://yuanba.tech/[%E8%AF%91]Yarn-capacity.html"/>
    <id>http://yuanba.tech/[%E8%AF%91]Yarn-capacity.html</id>
    <published>2019-07-28T15:35:23.000Z</published>
    <updated>2019-08-12T15:45:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇译文，<a href="https://hortonworks.com/blog/yarn-capacity-scheduler/">原文地址</a></p><p>主要介绍了Capacity Scheduler相关的内容。</p><p>Capacity Scheduler在资源分配时主要考虑两个主要属性：<em>用户名和应用程序ID</em>。在指定最小用户百分比和用户限制因素的队列中，用户之间共享资源时，关注的是用户名本身。在队列中，应用程序获取资源分配由叶子队列排序策略驱动：FIFO或FAIR，它只关心应用程序而不关心哪个用户正在运行它。在FIFO中，资源首先被分配给队列中最先提交的应用程序，并且只有当它不再需要任何请求时，下一个应用程序才会获得分配。对于使用最少资源的FAIR应用程序，首先询问是否存在待处理的分配，如果存在则分配，则如果不存在，则检查具有最少资源的下一个应用程序；这有助于与通常使用它们的应用程序平均共享队列。</p><span id="more"></span><h2 id="容量和分层设计"><a href="#容量和分层设计" class="headerlink" title="容量和分层设计"></a>容量和分层设计</h2><p>​YARN对其可分配的资源定义了最小分配量和最大分配量，目前这些资源包括内存和内核。可调度资源是由NodeManage提供的，来自所有节点的资源聚合为可被Capacity调度的总资源，总资源组成root队列。</p><p>​Capacity调度的基础设置是如何布置队列以及为它们分配资源。队列以分层设计布局，最顶层的父节点是集群队列的“根”，可以从根分配子队列，或者可以在自己队列的基础上再次分配子队列。资源被分配给这些队列，作为层次结构中父级资源的最小和最大百分比。 最小容量是如果群集上的所有队列都已运行，并且集群总资源已用完，此时各队列应该可以使用的资源量。 最大容量是类似弹性的容量，允许队列利用不用于填充其他队列中的最小容量需求的资源。<br><img src="/blogimgs/capacity/queue.png" alt="队列设计" title="队列设计"></p><h2 id="最低用户百分比和用户限制因素"><a href="#最低用户百分比和用户限制因素" class="headerlink" title="最低用户百分比和用户限制因素"></a>最低用户百分比和用户限制因素</h2><p>​最小用户百分比和用户限制因子是控制如何将正在使用的队列中的资源分配给他们的方法。 最小用户百分比是单个用户在请求时应访问的最小资源量百分比，是一个软限制。 例如，10％的最小用户百分比意味着10个用户将获得10％; 这个值不是硬性规定的，因为如果其中一个用户要求更少，我们可能会将更多用户放入队列。</p><p>​用户限制因子是一种控制单个用户可以使用的最大资源量的方法。 用户限制因子设置为队列最小容量的倍数。如果用户限制因子为1表示用户可以使用队列的整个最小容量， 如果用户限制因子大于1，则用户可能会增长到最大容量，如果该值设置为小于1，例如0.5，则用户只能获得队列最小容量的一半。 如果您希望用户能够增长到队列设置的最大容量，则大于1的值将允许用户多次超过最小容量。<br><img src="/blogimgs/capacity/user.png" alt="限制因子" title="限制因子"></p><p>​最初可能不直观的常见设计点是按工作负载而不是应用程序创建队列，然后使用用户限制因子来防止单个用户<strong>通过使用小于1.0的值单独接管队列</strong>。 此模型支持更简单的操作，不允许通过为每个LoB创建一个队列来创建队列，而是通过按工作负载创建队列来创建可预测的队列行为。 一旦群集完全使用并且应用程序排队等待运行时，较低的用户限制因素将是控制租户之间资源共享的关键。</p><p>​最初，由于使用较小的用户限制来限制用户资源，这可能无法在其Hadoop平台旅程开始时提供群集利用率，有许多方法，但需要考虑的是，最初允许单个租户接管一个小集群（比如10个节点），这可能是合理的，但是当扩展平台占用空间时，降低用户限制因子，以便每个租户保留与添加新节点之前相同数量的可分配资源。 这可以让用户保持最初的体验，但是无法接管整个集群，因为随着整个群集的增长，新用户可以轻松获得分配的容量，同时不会降低原始用户的体验。</p><h2 id="队列设计"><a href="#队列设计" class="headerlink" title="队列设计"></a>队列设计</h2><p>​队列设计时需要考虑如下相关场景：</p><ul><li><strong>即时查询</strong><br>主要是些临时统计需求，任务的出现没有规律，主要集中在工作时间，由用户主动触发</li><li><strong>紧急需求</strong><br>主要用于处理一些紧急需求，比如紧急补数</li><li><strong>机器学习</strong><br>这部分需求是需要大量的资源并且可能会长时间占用资源，但是紧急度和运行时长要求不是很高</li><li><strong>实时计算</strong><br>这部分需求是长时间运行并且没有明确的结束标识，对实时要求较高，不能容忍延迟，需要严格保证资源不被其它需求抢占</li><li><strong>批处理</strong><br>是指一些常规数据ETL，主要关注任务的吞吐量而不是当个任务是否延迟</li></ul><p>​队列中资源使用模型可以认为是一些containers像常量那样一直存在和新启动的。 这种使用模型对于具有良好行为的集群非常重要，因为队列可以快速重新平衡到其最小容量，并公平地平衡其用户之间的队列容量。 不好的使用模式是长期存在的容器，资源一直在被自己使用并且永远不会释放，这样它可以阻止资源的适当重新平衡，在某些情况下它可以完全阻止其他应用程序启动或其他队列恢复其最小容量。 当不使用抢占时，如果队列扩容弹性空间但从不释放其容器，则弹性空间永远不会被返回给其他队列来保证他们的最小容量。 如果在队列中运行的应用程序具有长期存在容器，请特别注意并考虑使用诸如用户限制因子，抢占或甚至没有弹性容量的专用队列等功能来减轻其对其他用户的影响的方法。</p><h2 id="CAPACITY调度特性"><a href="#CAPACITY调度特性" class="headerlink" title="CAPACITY调度特性"></a>CAPACITY调度特性</h2><h3 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h3><p>​默认情况下Capacity调度不支持CPU调度。如果开启CPU调度的话，可能会降低批处理任务的吞吐量。支持CPU调度的算法是Dominant Resource Fairness (DRF)。</p><p>​CPU调度主要包含两部分：</p><ol><li>分配和放置</li><li>强制限制</li></ol><p>​只要开启CPU调度即可解决分配和放置问题，调度器会使用DRF算法和VCores Node Manager的汇报结果。 这解决了一些新问题，例如用户使用1个或2个executors来调度他的Spark应用程序，但是每个executor分配8个core，然后由于可用内存过多而继续向这个节点分配任务，由于core的限制影响这些任务的运行。 通过启用简单的CPU调度，如果正在使用所有core，则不再将其他任务分配到该节点上，并找到群集中其它节点来放置任务。</p><p>​至于强制限制可以通过Cgroup来解决。Cgroup可以让YARN确保分配给某个container的vcore个数不会超过请求的数量。可以启用未使用时共享vcores，也可以仅严格执行已安排的内容。 节点管理器还可以配置为服务器上允许所有任务总和的最大CPU使用量，这样可以保证操作系统的功能正常使用core。</p><h3 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h3><p>​当应用程序在队列A中使用了弹性容量，此时另一个队列B提交了一个应用程序，队列B的资源被队列A的任务抢先使用中，此时正常情况下队列B中的应用程序必须等待队列A中的任务释放自由之后才能运行。如果开启抢占功能，就可以立马回收其他队列中的资源，以便满足队列的最小容量需求。抢占功能并不会彻底杀死一个应用程序，优先抢占map任务的资源，最后才是reduce的资源，因为被kill掉的任务必须重新运行，reduce比map要重复更多的工作。 从排序的角度来看，抢占时优先考虑最新的应用程序和大多数超额订阅的应用程序。</p><p>​抢占有些功能并不能像用户预期的那样发挥作用。<strong>最常见的行为是认为队列可以在其自身内部抢占以平衡所有用户的资源。 这种假设是错误的，因为抢占只能在队列之间</strong>，在队列中用户之间的资源平衡需要查看其他控制方式，例如用户限制因子和队列FIFO / FAIR策略。</p><!--另一个行为是，如果资源不能提供足够的资源来满足另一个资源分配请求，则Preemption不会抢占资源。 虽然对于具有较大最大容器大小的小型集群而言，大型集群通常不会出现问题但是Preemption未配置为回收最大可能容量的容器，因此根本不会执行任何操作。 用于控制此行为的主要属性是每轮总抢占率和自然终止因子。 每轮总抢占率是群集中可以立即被抢占的资源的百分比，自然终止因子是所请求的总群集（100％）中资源的百分比将被抢占到每轮总抢占数。--><h3 id="队列的排序策略"><a href="#队列的排序策略" class="headerlink" title="队列的排序策略"></a>队列的排序策略</h3><p>​Capacity调度目前支持两种排序策略：FIFO和FAIR。队列默认使用的是FIFO，但是这不是用户所希望的排序策略。在叶子队列中配置FIFO或者FAIR，可以在应用程序的吞吐量和共享公平之间合理选择。关于排序策略的一个重要事情是，排序是针对队列中的应用程序级别，而不关心哪个用户拥有应用程序。</p><p>​FIFO策略是按照应用程序提交的顺序来排序的。如果应用程序有未完成的资源请求，则会根据先到先得的原则分配。 这样做的结果是，如果应用程序有足够的未完成请求，它们将在完成之前多次请求，可能会使用整个队列，它们将阻止其他应用程序启动。 用户甚至可以使用自己的应用程序占满整个集群资源而阻止其它应用程序提交，正是这种行为对用户来说是最不可接受的。</p><p>​使用FAIR策略能很容易的解决上面的问题。在子队列上使用FAIR策略时，应首先对应用程序已占用的资源量进行评估，资源使用最少的应用程序会优先分配请求。 这样，进入队列的没有进行资源分配的新应用程序将首先进行资源分配。 一旦队列中的所有应用程序都得到资源，这样就在用户之间得到平衡。</p><p>​最重要的是，只有在队列中有良好的资源交互时才会出现此行为。由于队列内部不存在抢占资源，因此无法在队列中强制重新分配资源，而且FAIR排序策略仅涉及新资源分配而非当前已使用资源的再分配；这是什么意思？ 如果队列中资源被当前任务使用且任务永远不会完成或长时间运行而不允许在队列中发生容器结束，那么将保留资源并仍然阻止应用程序执行。</p><h3 id="默认队列映射"><a href="#默认队列映射" class="headerlink" title="默认队列映射"></a>默认队列映射</h3><p>​通常是在配置文件中指定用户提交的队列，Capacity调度可以使用<strong>默认队列映射</strong>通过用户名或者用户组将用户路由到指定的队列。但是需要注意的是默认队列的路由规则是哪个规则先满足就使用那个规则进行路由。也就是说如果组用户映射规则在用户映射规则前面，则先使用组用户映射规则对用户进行路由。</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>​当资源在队列之间分配时，<strong>具有最低相对容量的队列首先获得资源</strong>。如果你想让某个队列总是比其它队列优先获得资源，那么最简单的方法就是提高这个队列的优先级。</p><p>​在这两个队列之上提供了如何使用未经队列优先级修改的相对容量的示例。在这种情况下，即使队列A小于队列B并且队列B使用更多绝对资源，也会选择继续接收它们，因为它的相对容量低于队列A的相对容量。如果所需行为需要队列A始终接收资源分配首先，队列优先级应该增加到高于队列B的优先级。当分配优先级时，更高的值表示更高的优先级。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一篇译文，&lt;a href=&quot;https://hortonworks.com/blog/yarn-capacity-scheduler/&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主要介绍了Capacity Scheduler相关的内容。&lt;/p&gt;
&lt;p&gt;Capacity Scheduler在资源分配时主要考虑两个主要属性：&lt;em&gt;用户名和应用程序ID&lt;/em&gt;。在指定最小用户百分比和用户限制因素的队列中，用户之间共享资源时，关注的是用户名本身。在队列中，应用程序获取资源分配由叶子队列排序策略驱动：FIFO或FAIR，它只关心应用程序而不关心哪个用户正在运行它。在FIFO中，资源首先被分配给队列中最先提交的应用程序，并且只有当它不再需要任何请求时，下一个应用程序才会获得分配。对于使用最少资源的FAIR应用程序，首先询问是否存在待处理的分配，如果存在则分配，则如果不存在，则检查具有最少资源的下一个应用程序；这有助于与通常使用它们的应用程序平均共享队列。&lt;/p&gt;</summary>
    
    
    
    <category term="Hadoop" scheme="http://yuanba.tech/categories/Hadoop/"/>
    
    
    <category term="Hadoop" scheme="http://yuanba.tech/tags/Hadoop/"/>
    
    <category term="BigData" scheme="http://yuanba.tech/tags/BigData/"/>
    
    <category term="YARN" scheme="http://yuanba.tech/tags/YARN/"/>
    
    <category term="Capacity" scheme="http://yuanba.tech/tags/Capacity/"/>
    
  </entry>
  
  <entry>
    <title>Resource Localization in YARN</title>
    <link href="http://yuanba.tech/YARN-Resource-Localization.html"/>
    <id>http://yuanba.tech/YARN-Resource-Localization.html</id>
    <published>2019-05-20T14:10:01.000Z</published>
    <updated>2019-05-20T17:10:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个Applciation运行在YARN上的流程为，从YARN Client向ResourceManager提交任务，将Applciation所需资源提交到HDFS中，然后ResourceManager启动APPMaster，APPMaster通知各个NodeManager启动container执行具体到计算任务。在启动container之前需要从HDFS上下载该container执行所依赖的资源，这些资源包括jar、依赖的jar或者其它文件，这个过程就称为<strong>资源本地化</strong>(Resource Localization)。</p><p>本篇主要介绍下资源本地化相关的内容。</p><span id="more"></span><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><strong>本地化(Localization)</strong><br>本地化是指将HDFS上的资源下载到本地的<strong>过程</strong>。将资源本地化，使container不用总是访问HDFS上的数据，而是直接访问本地数据，提高效率。</p><p><strong>本地资源(LocalResource)</strong><br>本地资源是指container运行时所需要的资源，可以是某个文件或者依赖的library，这些资源存在HDFS中。NodeManager在container启动之前负责将这些资源进行本地化。对于Application来说，本地资源指：</p><ul><li>URL: 需要从HDFS上下载的本地资源地址</li><li>Size: 本地资源的大小</li><li>timestamp: 本地资源在HDFS上创建时的时间戳</li><li>LocalResourceType: NodeManager本地化资源时指定的资源类型，有FILE、ARCHIVE和PATTERN</li><li>Pattern: 从archive中解压具体内容时使用的规则匹配方式(只有LocalResourceType是PATTERN时才生效)。</li><li>LocalResourceVisibility: NodeManager将资源本地化之后针对该Nodemanager上其它用户和Application的可见性。可见范围为PUBLIC、PRIVATE和APPLICATION。</li></ul><blockquote><p>NOTE: 本地资源并不是指在本地磁盘的资源，而是需要从HDFS下载到本地的资源。</p></blockquote><p>那么container会请求什么样的资源进行本地化呢？可以是任意的文件，但是这些文件对contianer必须是只读的。<br>下面举几个比较适合做本地资源的典型例子：</p><ol><li>container启动的时候需要的代码库，如jar文件</li><li>container启动时所需要的configure文件</li><li>静态的文件目录</li></ol><p>一些动态资源不适合作为本地资源，例如：container需要的资源有可能被其它组件进行更新，application自己会直接更新的文件或者application想跟其它服务共享文件的变化情况的。</p><p><strong>ResourceLocalizationService</strong><br>ResourceLocalizationService是NodeManager内部的一个服务，主要负责下载和管理container所需的各种资源。下载时会对所有可用的磁盘进行负载均衡，对下载的资源会严格控制他们的访问权限。</p><p><strong>DeletionService</strong><br>DeletionService也是NodeManager内部的一个服务，主要负责在收到指令之后删除本地目录</p><p><strong>Localizer</strong><br>Localizer实际上是一个线程，用于资源本地化。Localizer有两种类型，一种是指用与下载PUBLIC访问类型资源的<em>PublicLocalizer</em>，另一种是下载PRIVATE和APPLICATION访问类型的<em>ContainerLocalizers</em>。</p><p><strong>LocalCache</strong><br>LocalCache是NodeManager维护所有下载到本地的文件的local-cache。这些资源通过下载时指定的HDFS地址来唯一标识。</p><h2 id="概念补充"><a href="#概念补充" class="headerlink" title="概念补充"></a>概念补充</h2><h3 id="LOCALRESOURCE-TIMESTAMPS"><a href="#LOCALRESOURCE-TIMESTAMPS" class="headerlink" title="LOCALRESOURCE TIMESTAMPS"></a>LOCALRESOURCE TIMESTAMPS</h3><p>timestamp反应了本地资源的一个版本，NodeManager在下载本地资源时会检查timestamp，这样Application在运行时看到的文件内容都一样。<br>利用timestamp，YARN能发现资源是否发生过变化，如果发生变化将使container失败避免不一致发生。因为在HDFS上的资源一旦被NodeManager本地化到本地磁盘，这个文件就不再与源文件有任何联系，只会记录下原来的URL用来在本地进行唯一标识。此时即使源文件发生变化，NodeManager也不会跟踪此变化再次下载文件。</p><blockquote><p>这里需要注意的是<em>当container启动时，ApplicationMaster会向运行container的NodeManager指定资源的timestamp，同样当运行ApplicationMaster的container启动时，也需要资源的timestamp，此时这个timestamp就需要由client指定</em>。以MapReduce on YARN为例，MapReduce的JobClient决定ApplicationMaster需要的资源的timestamp，然后由ApplicationMaster自己决定map和reduce所需资源的timestamp。</p></blockquote><h3 id="LOCALRESOURCE-TYPES"><a href="#LOCALRESOURCE-TYPES" class="headerlink" title="LOCALRESOURCE TYPES"></a>LOCALRESOURCE TYPES</h3><p>上一节中提到LocalResourceType为FILE、ARCHIVE和PATTERN，下面介绍下三种type的具体含义。<br>FILE类型是指普通的文件，文本类型或者二进制文件<br>ARCHIVE类型是指一些可以被NodeManager自动识别解压的归档文件，比如jars、tars、tar.gz和zip<br>PATTERN是ARCHIVE和FILE的一种混合体。这种类型下载到本地的源文件会保留，并且在本地化时只有解压的文件会留存在本地文件系统中。源文件和解压的文件在同一个目录中。哪些文件需要从ARCHIVE中抽取出来，哪些不需要这些都是由pattern决定的。目前只有jar支持PATTERN，其它都被认为正常的ARCHIVE。</p><h3 id="LOCALRESOURCE-VISIBILITES"><a href="#LOCALRESOURCE-VISIBILITES" class="headerlink" title="LOCALRESOURCE VISIBILITES"></a>LOCALRESOURCE VISIBILITES</h3><p>上一节LocalResourceVisibility中提到本地资源有三种可见性，分别为PUBLIC、PRIVATE和APPLICATION。其中</p><p>PUBLIC的访问权限是指<strong>任何用户的任意Application的container都可以访问</strong>。典型的PUBLIC资源是那些在HDFS上可以被任何人访问的文件，当这些资源被本地化之后会保留相同的访问权限。<em>如果一个资源是PUBLIC，当有container(container可以是当前Attempt，也可以是其它用户的任意Application中的container)请求相同的本地资源时，只要此资源没有被LocalCache删除，都可以直接从LocalCache里直接使用，而不需要再次下载</em>。</p><p>PUBLIC资源存储在NodeManager本地磁盘的<code>&lt;local-dir&gt;/filecache</code>目录下，此目录中的所有文件的owner是NodeManager进程启动时的用户，并且所有用户都有读权限，因此这些资源可以在此NodeManager上运行的所有用户的container共享。</p><p>PRIVATE权限本地资源只能在<strong>当前节点上相同用户的application之间共享</strong>，这些资源存储在NodeManager本地磁盘的<code>&lt;local-dir&gt;/usercache/$username/filecache</code>目录下，这些文件的owner是启动Application的user，并且其它用户没有访问权限。类似PUBLIC，一旦资源本地化，所有的用户都没有写权限，即使是提交任务的user。这样是为了避免恶意的container去修改文件。</p><p>APPLICATION只在<strong>当前节点上同一个application的container之间共享</strong>。这些资源存储在NodeManager本地磁盘的<code>&lt;local-dir&gt;/usercache/$username/appcache/&lt;app-id&gt;/</code>目录下，文件的owner是Application的提交者，并且只有读权限。</p><blockquote><p>这里需要注意的是LOCALRESOURCE VISIBILITIES与LOCALRESOURCE TIMESTAMPS类似，都是由ApplicationMaster指定本地资源的可见性，NodeManager并不会对资源的可见性做任何决定。同样当运行ApplicationMaster的container启动时，也需要资源的可见性，此时这个可见性就需要由client指定。以MapReduce on YARN为例，MapReduce的JobClient决定ApplicationMaster需要的资源的可见性，然后由ApplicationMaster自己决定map和reduce所需资源的可见性。</p></blockquote><h4 id="本地化流程"><a href="#本地化流程" class="headerlink" title="本地化流程"></a>本地化流程</h4><p>PUBLIC资源本地化是由<code>PublicLocalizer</code>实现的，在NodeManager进程中会有一个线程池PublicLocalizers，其个数是由<code>yarn.nodemanager.localizer.fetch.thread-count</code>决定，线程池的大小决定并行下载PUBLIC资源的线程最大个数。当PublicLocalizer本地化PUBLIC资源时，会通过检查这些资源在HDFS上的权限来确定所申请的资源确实为PUBLIC。只要有资源不符合就拒绝本地化。PublicLocalizer能安全的从HDFS上下载资源是向ContainerLaunchContext传递了证书。 </p><p>PRIVATE/APPLICATON资源的本地化是由<code>ContainerLocalizer</code>实现的，不同与PUBLIC的<code>PublicLocalizer</code>实现。<em>PublicLocalizer是直接在NodeManager中启动一个线程池进行本地化，而ContainerLocalizer出于安全问题，并没有在NodeManager进程中直接实现，而是在continer中实现的</em>。</p><p>PRIVATE/APPLICATON资源的本地化是由<code>ContainerLocalizer</code>实现，这是一个单独的进程，这个进程由<code>LocalizerRunner</code>线程管理，<em>LocalizerRunner是NodeManager中的一个线程</em>，只要某个container有资源还没有下载，<em>那么此container就会触发一个LocalizerRunner</em>。下面看下具体的细节：</p><!--LocalResourcesTracker is a per-user or per-application object that tracks all the LocalResources for a given user or an application.--><p>当某个container第一次请求PRIVATE/APPLICATION类型的本地资源时，如果没有在LocalResourcesTracker中找到，则加入pending-resources列表。随后是否需要创建LocalizerRunner线程取决于是否有必要下载资源，如果需要就将本地资源加入<strong>LocalizerRunner</strong>维护的pending-resources列表。</p><p>NodeManager在安全模式时，本地资源本地化时需要所用的user是application的提交用户而不是NodeManager的启动用户。因此<strong>LocalizerRunner会以application提交者的身份启动LinuxContainerExecutor(LCE)进程，然后LCE会执行ContainerLocalizer下载资源</strong>。<em>ContainerLocalizer启动之后会与NodeManager维持一个心跳</em>，通过心跳，LocalizerRunner给ContainerLocalizer分配需要下载的资源或者停止ContainerLocalizer进程，而ContainerLocalizer会通知LocalizerRunner自己的下载进度。如果资源下载失败，这个资源将会从LocalResourcesTracker中移除，并且container最终也会失败。如果下载成功，LocalizerRunner会通过心跳给ContainerLocalizer另一个资源进行下载，直到所有的资源都下载完。</p><!--At present, each ContainerLocalizer doesn’t support parallel download of mutliple PRIVATE/APPLICATION resources which we are trying to fix via YARN-574.Note that because of the above, the maximum parallelism that we can get at present is the number of containers requested for same user on same node manager at THAT point of time. This in the worst case is one when an ApplicationMaster itself is starting. So if AM needs any resources to be localized then today they will be downloaded serially before its container starts.--><h4 id="本地资源的生命周期"><a href="#本地资源的生命周期" class="headerlink" title="本地资源的生命周期"></a>本地资源的生命周期</h4><p>由于本地资源的访问权限不一样，则不同的LocalResourceType在本地保留的时间也会不一样。</p><ul><li>PUBLIC由于是在任何用户的任意Application之间共享，所以并不会在某个container或者application结束之后被删除，只有在本地目录<local-dir>达到存储阈值时才会被删除，这个阈值由<code>yarn.nodemanager.localizer.cache.target-size-mb</code>控制。</li><li>PRIVATE和PUBLIC的生命周期一样。</li><li>APPLICATION会在application结束之后立即删除。</li></ul><!--One thing of note is that for any given application, we may have multiple ApplicationAttempts and each attempt may start zero or more containers on a given node manager. When the first container belonging to an ApplicationAttempt starts, ResourceLocalizationService localizes files for that application as requested in the container’s launch context. If future containers request more such resources then they all will be localized. If one ApplicationAttempt finishes/fails and another is started, ResourceLocalizationService doesn’t do anything w.r.t the previously localized resources. However when eventually the application finishes, ResourceManager communicates that information to NodeManagers which in turn clear the application LocalCache. In summary, APPLICATION LocalResources are truly application scoped and not ApplicationAttempt scoped.--><h4 id="本地化相关的配置"><a href="#本地化相关的配置" class="headerlink" title="本地化相关的配置"></a>本地化相关的配置</h4><p>在<code>yarn-site.xml</code>中有一些资源本地化相关的配置。</p><ul><li><code>yarn.nodemanager.local-dirs</code>: 资源本地化时所在的本地目录，可以是以逗号分隔的多个磁盘目录。</li><li><code>yarn.nodemanager.local-cache.max-files-per-directory</code>: 每个目录中最多本地化文件的个数，PUBLIC / PRIVATE / APPLICATION分别统计。</li><li><code>yarn.nodemanager.localizer.address</code>: ResourceLocalizationService服务监听的RPC地址，用来接收不同localizers</li><li><code>yarn.nodemanager.localizer.client.thread-count</code>: ResourceLocalizationService中用来处理来自localizers请求的线程数。默认是5</li><li><code>yarn.nodemanager.localizer.fetch.thread-count</code>: 本地化PUBLIC资源时PublicLocalizer的线程数。默认是4</li><li><code>yarn.nodemanager.delete.thread-count</code>: DeletionService中删除文件的线程数，默认是4。</li><li><code>yarn.nodemanager.localizer.cache.target-size-mb</code>: 本地化资源所占的最大磁盘空间，单位是MB，比包括APPLICATION资源。</li><li><code>yarn.nodemanager.localizer.cache.cleanup.interval-ms</code>: 每隔固定时间，去检查下磁盘的使用量。在此间隔之后，如果存储的磁盘空间超过了配置的阈值，会删除未用的资源。</li></ul><blockquote><p>未使用的资源是指没有被正在运行的container引用的资源。每次container请求资源时，container会被加入到一个资源引用列表中，直到container结束之后才会被移除。所以当引用数为0时，可以被删除。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.hortonworks.com/blog/management-of-application-dependencies-in-yarn/">Management of Application Dependencies in YARN</a><br><a href="https://zh.hortonworks.com/blog/resource-localization-in-yarn-deep-dive/">Resource Localization in YARN: Deep Dive</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个Applciation运行在YARN上的流程为，从YARN Client向ResourceManager提交任务，将Applciation所需资源提交到HDFS中，然后ResourceManager启动APPMaster，APPMaster通知各个NodeManager启动container执行具体到计算任务。在启动container之前需要从HDFS上下载该container执行所依赖的资源，这些资源包括jar、依赖的jar或者其它文件，这个过程就称为&lt;strong&gt;资源本地化&lt;/strong&gt;(Resource Localization)。&lt;/p&gt;
&lt;p&gt;本篇主要介绍下资源本地化相关的内容。&lt;/p&gt;</summary>
    
    
    
    <category term="Hadoop" scheme="http://yuanba.tech/categories/Hadoop/"/>
    
    
    <category term="Hadoop" scheme="http://yuanba.tech/tags/Hadoop/"/>
    
    <category term="BigData" scheme="http://yuanba.tech/tags/BigData/"/>
    
    <category term="YARN" scheme="http://yuanba.tech/tags/YARN/"/>
    
    <category term="Localization" scheme="http://yuanba.tech/tags/Localization/"/>
    
  </entry>
  
  <entry>
    <title>Use protobuf to FSImage</title>
    <link href="http://yuanba.tech/[%E8%AF%91]FSImage-protocol.html"/>
    <id>http://yuanba.tech/[%E8%AF%91]FSImage-protocol.html</id>
    <published>2019-05-10T15:12:31.000Z</published>
    <updated>2019-05-10T17:10:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇是一篇译文，主要介绍下FSImage改进为protobuf的设计原理，<a href="https://issues.apache.org/jira/secure/attachment/12626179/HDFS-5698-design.pdf">原文地址</a>。</p><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>为了能从故障中快速恢复，HDFS会周期性的将内存中的namespace在磁盘上的文件系统中进行持久化。FSImage的性能和扩展性在保证数据的耐用性和可用性上至关重要。随着越来越多的高级功能被引入HDFS中，FSImage已经从一个简单的blob演变为了一个需要存储在磁盘的复杂的数据结构。FSImage有3个方面需要改进：</p><ul><li>效率<br>在生成环境中，我们观察到持久化到磁盘的FSImage大小能达到二三十GB。因为加载和停机时保存FSImage是NameNode的关键环节，其效率对确保NameNode操作的可用性非常重要。</li><li>兼容性<br>FSImage将随着HDFS的各种功能的不断发展和演变。FSImage的实现将能够被各种不同的版本所使用，这在某些功能下非常重要，比如滚动升级。</li><li>互通性<br>FSImage能被第三方工具访问的需求越来越强烈了。例如某个工具可以通过扫描FSImage收集一些统计信息。因此FSImage应该提供一个使第三方工具能与其进行交互的清晰规范。</li></ul><p>当前FSImage模块有大约2500行代码，但是现在的设计与实现并不能解决上面的需求。首先，对于兼容性而言，当前代码中的一些实现并不理想。例如有些属性比如inode IDs和block IDs被编码为了固定长度的整数而不是变长整数。</p><p>其次，代码依赖与分支上的不同布局版本以保持向后兼容。在代码更新时在修改和测试上需要耗费很大的精力。然而，还不支持向前兼容，这使NameNode降级变的很困难</p><p>再次，FSImage的格式仅由代码的具体实现而决定。如果没有正式的FSImage规范，开发人员构建第三方工具时，只能通过offline image viewer来构建，这种方式时低效的而且还容易出错。</p><p>为了解决上面的挑战，我们提议使用Google的Protocol Buffers协议来定义一种新的FSImage格式。Protocol Buffers是可扩展的，与语言无关的，用于序列化结构数据。Protobuf能解决上面的挑战。首先，Protocol使用一个编译器为序列化和反序列化生成高效的代码。其次，它还支持向前和向后兼容。序列化后的每个属性都包含一个唯一的标签，因此反序列化的代码可以同时处理新加的字段和缺失的字段。最后，Protocol Buffers的源码直接定义了FSImage的格式。第三方工具仅根据protocol文件就能知道FSImage的格式。</p><p><a href="https://issues.apache.org/jira/browse/HDFS-5698">HDFS-5698</a>是关于FSImage新格式的issues。下面的内容介绍了设计的细节，新格式的一些实验参数，未来的方向和结论。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>下图是新FSImage格式的EBNF语法描述。整个FSImage包括4部分，分别为MAGIC、SECTION、FileSummary和FileSummaryLength，其中SECTION包含N个。<br><img src="/blogimgs/fsimage-proto/EBNF.png" alt="FSImage格式" title="FSImage格式"></p><p>FSImage将数据分成不同的部分。每部分在数据中都是相互独立的。开发人员可以添加新的部分来扩展FSImage。</p><p>FileSummary模块包含4个属性，分别为ondiskVersion、layoutVersion、codec和sections，其中sections中记录了每个section的名字、长度和偏移量。所有的section可以使用指定的codec对其进行压缩。每个section都是单独压缩的，而且section中记录的长度和偏移量都是压缩之后的，因此当读取的时候可以直接通过响应的偏移量而直接定位到某个section。</p><p>当解析FSImage时，先从文件的末尾读取4bytes，读取的4bytes数据记录了FileSummary模块的长度，通过解析FileSummary模块能得到所有section的位置信息，这样设计允许写入时按顺序保留FSImage。</p><h3 id="序列化inode"><a href="#序列化inode" class="headerlink" title="序列化inode"></a>序列化inode</h3><p>FSImage将inode序列化为两种section。<code>INodeSection</code>记录了每个inode(<strong>包括INodeFile和INodeDirectory</strong>)的信息，<code>INodeDirectorySection</code>记录了每个目录的子inodes。这种将inodes当作图而不是树的设计模式有两个优点，第一与实际的图更加匹配，因此当快照存在时，inode不用再形成树。不同的目录能通过<code>INodeReference</code>对象指向同一个inode。第二它将结构扁平化，从而为并行性提供了机会。每个inode都独立的存储在FSImage中，因此可以并行的解析和构建不同的inodes。</p><p>在protobuf的规范中，<code>INodeSection</code>并不包含inode列表，而是在INodeSection随后的protobuf消息中隐式的指定了inode列表。这样做的原因时Protocol Buffers在生成代码的时候需要将所有的属性加载到内存，然而inodes列表可能太大而不能加载到内存。文中的这种设计允许FSImage以递增的方式解析。</p><p>令人惊讶的是，我们的初始分析结果表明序列化权限是代码中的瓶颈。权限是一个元组，包含用户名，组名和表示权限位的16位整数。简单的解决方案是直接序列化两个名称和16位整数。 但是，我们发现FSImage中的名称是高度冗余的，反序列化为Java的String对象需要大量的CPU时间。为了优化此用例，FSImage将名称映射为24位ID，以便可以使用64位整数表示权限。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>为了评估新FSImage的性能，我们比较了新旧格式的FSImage文件的大小，和持久化和加载FSImage所需要的时间。我们将生产中使用的FSImage缩放到五种不同的尺寸，以评估具有各种尺度集群的性能。所有的测试都运行在相同的机器上。</p><p>图2比较了新旧FSImage的大小。FSImage都是未压缩的。由图中所知新格式的FSImage能够节省6-13%的磁盘空间。<br><img src="/blogimgs/fsimage-proto/fig2.png" alt="图2" title="图2"></p><p>图3展示了新旧FSImage加载和持久化的处理时间，也都是未压缩的。新FSImage有着较好的写性能。<br><img src="/blogimgs/fsimage-proto/fig3.png" alt="图3" title="图3"></p><p>新FSImage读比旧FSImage所耗的时间长，大约为1.5x-2.3x。分析结果表明，解析字节和构造为protocol buffers生成的对象占用大部分时间。 旧格式的代码读取数据并直接构造HDFS中使用的对象，这不会受到这种类型的开销的影响。</p><h2 id="未来工作"><a href="#未来工作" class="headerlink" title="未来工作"></a>未来工作</h2><h3 id="并行化"><a href="#并行化" class="headerlink" title="并行化"></a>并行化</h3><p>新FSImage的设计格式为并行加载提供了机会。新的FSImage单独存储每个inode，因此可以并行的解析数据和重构inode。同样，新FSImage也可以并行的填充不同目录的子节点。</p><p>重建BlockMap占用CPU时间的大约为20％。在新的FSImage格式下，可以将BlockMap的工作负载转移到单独的线程中，从而隐藏延迟。</p><h3 id="直接构建对象"><a href="#直接构建对象" class="headerlink" title="直接构建对象"></a>直接构建对象</h3><p>新的FSImage需要首先通过Protocol Buffers生成的对象，然后根据生成的对象构造HDFS中使用的对象。实验结果显示构造生成的对象需要大量时间。 可以手动解析Protocol Buffers并直接构造对象，从而消除了开销。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>FSImage的性能和可靠性对于提供HDFS的耐用性和可用性非常重要。本文描述了一种基于Protocol Buffers的新FSImage格式。新格式满足了FSImage的效率，兼容性和互操作性要求。 我们希望新格式可以促进HDFS的创新。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇是一篇译文，主要介绍下FSImage改进为protobuf的设计原理，&lt;a href=&quot;https://issues.apache.org/jira/secure/attachment/12626179/HDFS-5698-design.pdf&quot;&gt;原文地址&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Hadoop" scheme="http://yuanba.tech/categories/Hadoop/"/>
    
    
    <category term="Hadoop" scheme="http://yuanba.tech/tags/Hadoop/"/>
    
    <category term="BigData" scheme="http://yuanba.tech/tags/BigData/"/>
    
    <category term="FSImage" scheme="http://yuanba.tech/tags/FSImage/"/>
    
    <category term="protobuf" scheme="http://yuanba.tech/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title>分布式一致性协议</title>
    <link href="http://yuanba.tech/Consistency-in-Distributed.html"/>
    <id>http://yuanba.tech/Consistency-in-Distributed.html</id>
    <published>2019-04-06T16:10:34.000Z</published>
    <updated>2022-01-17T08:58:24.245Z</updated>
    
    <content type="html"><![CDATA[<p>分布式系统中有个著名的原则CAP原则，C为Consistency(一致性)、A为Availability(可用性)、P为Partition tolerance(分区容错性)。这里主要介绍下分布式环境下如果达到一致性。</p><p>说到一致性不得不说下经典的拜占庭问题。</p><span id="more"></span><!--分布式共识算法是分布式系统的核心，常见的有Paxos、pbft、bft、raft、pow等。区块链中常见的是POW、POS、DPOS、pbft等。 其中：POW、POS、DPOS是开放式的共识协议PBFT为半开放式的共识协议Paxos、raft等是封闭式共识协议区别：开放式，无法确切的知道节点的多少及连接状态，每个节点都可能是恶意的，但是大多数是非恶意的半开放式，可以确定节点的多少及连接状态，每个节点都可能是恶意的，但是有满足一定条件的非恶意节点封闭式，每个节点都是非恶意的，只不过可能断开连接或crash。--><h2 id="拜占庭问题"><a href="#拜占庭问题" class="headerlink" title="拜占庭问题"></a>拜占庭问题</h2><p>话说一组拜占庭将军分别各率领一支军队共同围困一座城市。为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。因为部分军队进攻部分军队撤离可能会造成灾难性后果，因此各位<em>将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离</em>。因为各位将军分处城市不同方向，他们<em>只能通过信使互相联系</em>。在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道共同的投票结果而决定行动策略。</p><p>系统的问题在于，<strong>将军中可能出现叛徒，他们不仅可能向较为糟糕的策略投票，还可能选择性地发送投票信息。假设有9位将军投票，其中1名叛徒。8名忠诚的将军中出现了4人投进攻，4人投撤离的情况。这时候叛徒可能故意给4名投进攻的将领送信表示投票进攻，而给4名投撤离的将领送信表示投撤离。这样一来在4名投进攻的将领看来，投票结果是5人投进攻，从而发起进攻；而在4名投撤离的将军看来则是5人投撤离。这样各支军队的一致协同就遭到了破坏</strong>。</p><p>拜占庭问题其实是指在一个可妥协的通信网络中实现分布式协议的问题，也就是<em>在不可靠的环境中建立一个可靠的系统的问题</em>。</p><p>假始那些忠诚（或是没有出错）的将军仍然能通过多数决策来决定他们的战略，便称达到了<strong>拜占庭容错</strong>。</p><!--在点对点式数字货币系统比特币里，比特币网络的运作是平行的（parallel）。各结点与终端都运算著区块链来达成工作量证明（PoW）。工作量证明的链条是解决比特币系统中拜占庭问题的关键，避免有问题的结点（即前文提到的“反叛的将军”）破坏数字货币系统里交易帐的正确性，是对整个系统的运行状态有着重要的意义。比特币使用经过工作量证明区块链技术解决了拜占庭容错问题。 POW增加了提出提案的成本，不是任意节点可以随意提出提案，在源头减少了干扰信息--><h2 id="PBFT"><a href="#PBFT" class="headerlink" title="PBFT"></a>PBFT</h2><p>PBFT是Practical Byzantine Fault Tolerance的缩写，意为<em>实用拜占庭容错算法</em>，复杂度过高<code>O(N^2)</code>。PBFT是一种<em>状态机副本复制算法</em>，即服务作为状态机进行建模，状态机在分布式系统的不同节点进行副本复制。每个状态机的副本都保存了服务的状态，同时也实现了服务的操作。</p><p>PBFT是一个<strong>三阶段算法</strong>，分为<code>Pre-Prepare</code>、<code>Prepare</code>和<code>Commit</code>。<br>PBFT中有几个概念需要了解下，所有的节点称为<code>副本</code>，这些副本有两个角色，分别为主节点(primary)和备份节点(backups)，所有的副本在一个被称为<code>视图</code>(View)的轮换过程中运作。<em>主节点和备份节点是针对视图而言，视图是连续编号的整数</em>。在某个视图中，从副本中选出一个副本为主节点，选择算法为<code>p = v mod |R|</code>，其中v是视图编号，|R|为副本个数，p为副本编号，除主节点之外所有的节点都为备份节点。当<strong>主节点失效</strong>的时候就需要启动视图更换过程。</p><p>知道上述概念之后，来看下算法的具体流程：<br><img src="/blogimgs/PBFT-Paxos-Raft/pbft.png" alt="PBFT" title="PBFT"><br>其中0为主节点，123为备份节点，3宕机无法响应请求</p><ol><li>主节点0接收到客户端C发来的请求request，给请求分配一个序列号n，然后向所有<strong>备份节点</strong>群发预准备消息，预准备消息的格式为&lt;&lt;PRE-PREPARE,v,n,d&gt;,m&gt;，这里v是视图编号，m是客户端发送的请求消息，d是请求消息m的摘要。</li><li>备份节点收到主节点广播的消息之后，check下自己是否接受，接受之后向<strong>其它副本</strong>进行prepare广播</li><li>某个副本在接收到<code>2f</code>个prepare信息之后，向<strong>其它副本</strong>广播commit<!--(*备份节点的2f中有一个是未广播给自己的prepare信息*)--></li><li>某个副本在接收到<code>2f+1</code>个commit信息之后，向客户端C发送reply<!--之所以这里是2f+1，是因为主节点加入了广播序列--></li><li>客户端C在接收到<code>f+1</code>个相同的reply之后则达成共识<!--需要注意的是主节点没有收到pre-prepare广播，没有自己的prepare信息，但是可以收到备份节点的prepare信息，收到2f个之后就可以进行广播commit信息--></li></ol><!--同所有的状态机副本复制技术一样，PBFT对每个副本节点提出了两个限定条件：（1）所有节点必须是确定性的。也就是说，在给定状态和参数相同的情况下，操作执行的结果必须相同；（2）所有节点必须从相同的状态开始执行。在这两个限定条件下，即使失效的副本节点存在，PBFT算法对所有非失效副本节点的请求执行总顺序达成一致，从而保证安全性。--><p>拜占庭问题是一个理论性的模型，解决起来比较困难，工程实践上可以将其模型的某些条件进行假设，这样可以解决一些特定的问题。<br>将集群中是否存在背叛者作为一个已知条件来将拜占庭问题细分下：</p><ol><li>假如集群中存在背叛者，也就是有一些伪造信息，这种情况称为<em>拜占庭错误</em>，伪造信息的节点称为拜占庭节点。其一致性算法为BFT（Byzantine Fault Tolerance），上文介绍的PBFT就是一个拜占庭容错算法。</li><li>如果集群中不存在背叛者，都是忠诚者，只是这些忠诚者由于某种原因无法正常工作，这种情况称为<em>非拜占庭错误</em>。其一致性算法为CFT（Crash Fault Tolerance）。</li></ol><p>下面我们就介绍两个非拜占庭一致性算法<em>Paxos</em>和<em>Raft</em>。</p><h2 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h2><p>Paxos算法为非拜占庭一致性算法，<em>运行在允许宕机故障的异步系统中，不要求可靠的消息传递，可容忍消息丢失、延迟、乱序以及重复</em>。<strong>它利用大多数机制保证了2F+1的容错能力，即2F+1个节点的系统最多允许F个节点同时出现故障</strong>。</p><p>Paxos算法中的角色分为Proposer和Acceptor，Proposer是提案者，用来发起提案（Proposal），Acceptor是决策者，用来接收和响应Proposer提出的提案。这个算法的场景是<strong>一个或多个提议进程（Proposer）可以发起提案（Proposal），需要在所有提案中选取某一个提案，使其在所有进程中达成一致。系统中的多数派同时认可该提案，即达成了一致。最多只针对一个确定的提案达成一致。</strong></p><p>Paxos算法流程分为两阶段，第一阶段为Prepare阶段，第二阶段为Commit阶段。两阶段提交算法的思路大致可以概括为<strong>决策者将提案的结果通知提案者，再由提案者根据所有决策者反馈的结果决定是提交操作还是终止操作</strong>。</p><p>Paxos算法大致流程为Proposer询问Acceptors<strong>是否可以发起提案</strong>，Acceptors将结果返回给Proposer(第一阶段)，再由Proposer根据Acceptors反馈的<em>结果决定提案内容以及提案是提交还是终止</em>(第二阶段)。具体流程如下：<br>第一阶段Prepare阶段：</p><ol><li>Proposer提出一个提案时，每次提案时都生成一个全局唯一且递增的ID，向Acceptors发送<em>PrepareRequest</em>请求，PrepareRequest请求<em>只携带提案ID</em>，而<em>无需携带提案内容</em>。</li><li>Acceptors收到Proposer的请求后，判断<code>PrepareRequest</code>中的<strong>ID是否大于Acceptors记录的值</strong>，如果大于则检查下是否有已经Accept过的提案，<em>有则返回提案中ID最大的那个提案的value和ID，没有则返回空值</em>，如果<strong>小于Acceptors记录的值则不响应</strong>。<br>第一阶段结束，开始第二阶段Commit阶段：</li><li>Proposer接收到多数Acceptors的<code>PrepareResponse</code>应答之后，<strong>从应答中选择提案ID最大对应的value作为本次要发起的提案</strong>。 <em>如果所有应答的提案value均为空值，则可以自己随意决定提案value</em>。然后携带当前ID，向所有Acceptors发送<code>AccpetRequest</code>请求。</li><li>Accpetors收到<code>AccpetRequest</code>后，判断<code>AccpetRequest</code>中的<strong>ID是否大于等于Acceptors记录的值</strong>，是则持久化当前ID和提案内容，然后返回给Proposer响应<code>AcceptResponse</code></li><li>Proposer收到多数Acceptors的<code>AcceptResponse</code>后，决议形成。</li></ol><blockquote><p>整个流程中Acceptors的行为可以概括为<strong>两个承诺，一个应答</strong>。<br>两个承诺：</p></blockquote><ol><li>不再应答PrepareRequest中ID小于等于当前请求PrepareRequest中ID的请求(是因为当前PrepareRequest中ID已经赋值给minProposal)</li><li>不再应答AcceptRequest中ID小于当前请求AcceptRequest中ID的请求(因为当前AcceptRequest中ID是上次PrepareRequest请求中ID，所以不再应答小于的ID)<br>一个应答：<br>不违背之前作出的承诺下，返回自己已经Accept过的提案中ID最大的那个提案的内容，如果没有则返回空值</li></ol><p>结合下面的伪代码能够更加深刻理解这两个承诺一个应答的含义<br><img src="/blogimgs/PBFT-Paxos-Raft/basic-paxos.jpg" alt="basic paxos" title="basic paxos"><br>算法逻辑为：</p><ol><li>获取一个ProposalID n，为了保证ProposalID唯一，可采用时间戳+ServerID生成；</li><li>Proposer向所有Acceptors广播Prepare(n)请求；</li><li>Acceptor比较n和<code>minProposal</code>，如果<code>n&gt;minProposal</code>，则<code>minProposal=n</code>，并且将<code>acceptedProposal</code>和<code>acceptedValue</code>返回；</li><li>Proposer接收到过半数回复后，如果发现有<code>acceptedValue</code>返回，将所有回复中<em>acceptedProposal最大的acceptedValue作为本次提案的value</em>，否则可以任意决定本次提案的value；</li><li>到这里可以进入第二阶段，广播<code>Accept(n,value)</code> 到所有节点；</li><li>Acceptor比较n和minProposal，如果<code>n&gt;=minProposal</code>，则<em>acceptedProposal=minProposal=n，acceptedValue=value，本地持久化后</em>，返回；<em>否则，返回minProposal</em>。</li><li>提议者接收到过半数请求后，<strong>如果发现有返回值result&gt;n</strong>，表示有更新的提议，跳转到1；否则value达成一致。</li></ol><!--第一阶段：获取epoch轮次的访问权和当前var的取值，我们可以简单获取当前时间戳为epoch：通过Acceptor.prepare(epoch)，获取epoch轮次的访问权和当前var的取值；如果不能获取，返回<error>。第二阶段：采用“后者认同前者”的原则执行。如果var取值为null，则肯定旧epoch无法生成确定性取值，则通过Acceptor.accept(var, prepared_epoch, V)提交数据V。成功后返回<ok, V>；若accept失败，则说明被更新的epoch抢占或Acceptor故障，返回<error>。如果var取值存在，则此取值肯定是确定性取值，此时认同它不再更改，直接返回<ok, accepted_value>。--><!--提案编号怎么取值，防止恶意取值JN是如何写，如何同步数据的“活锁”的根本原因在于两个proposer交替提案，避免“活锁”的方式为，如果一个proposer通过accpter返回的消息知道此时有更高编号的提案被提出时，该proposer静默一段时间，而不是马上提出更高的方案，静默期长短为一个提案从提出到被接受的大概时间长度即可，静默期过后，proposer重新提案。系统中之所以要有主proposer的原因在于，如果每次数据更改都用paxos，那实在是太慢了，还是通过主节点下发请求这样来的快，因为省去了不必要的paxos时间。所以选择主proposer用paxos算法，因为选主的频率要比更改数据频率低太多。但是主proposer挂了咋整，整个集群就一直处于不可用状态，所以一般都用租约的方式，如果proposer挂了，则租约会过期，其它proposer就可以再重新选主，如果不挂，则主proposer自己续租。--><p>原始的Paxos算法(Basic Paxos)<em>只能对一个值形成决议</em>，决议的形成至少需要两次网络来回，*在高并发情况下可能需要更多的网络来回，极端情况下甚至可能形成活锁(活锁–多个Proposer交替向Acceptors提交PrepareRequest请求，在发送AccpetRequest请求时，都因为ID发生更新，Acceptors无法接受AccpetRequest请求，返回ID，是Proposer再次向Acceptors发送PrepareRequest请求，如此反复，无法形成共识。)*。更重要的是如果想连续确定多个值<!--这里不是太懂，标记下？？？？-->，Basic Paxos无法确定了。因此Basic Paxos几乎只是用来做理论研究，并不直接应用在实际工程中。</p><p>实际应用中几乎都需要连续确定多个值，而且希望能有更高的效率。<code>Multi-Paxos</code>正是为解决此问题而提出。Multi-Paxos基于Basic Paxos做了两点改进：</p><ol><li>针对每一个要确定的值，运行一次Paxos算法实例（Instance），形成决议。每一个Paxos实例使用唯一的Instance ID标识。</li><li>在所有Proposers中选举一个Leader，由Leader唯一的提交提案给Acceptors进行表决。<em>仅有一个Leader进行value提交的情况下，Prepare阶段就可以跳过，从而将两阶段变为一阶段，提高效率。</em>同时这样没有Proposer竞争，<em>也解决了活锁问题</em>。</li></ol><!--Multi-Paxos首先需要选举Leader，Leader的确定也是一次决议的形成，所以可执行一次Basic Paxos实例来选举出一个Leader。选出Leader之后只能由Leader提交Proposal，在Leader宕机之后服务临时不可用，需要重新选举Leader继续服务。在系统中仅有一个Leader进行Proposal提交的情况下，Prepare阶段可以跳过。Multi-Paxos通过改变Prepare阶段的作用范围至后面Leader提交的所有实例，从而使得Leader的连续提交只需要执行一次Prepare阶段，后续只需要执行Accept阶段，将两阶段变为一阶段，提高了效率。为了区分连续提交的多个实例，每个实例使用一个Instance ID标识，Instance ID由Leader本地递增生成即可。Multi-Paxos允许有多个自认为是Leader的节点并发提交Proposal而不影响其安全性，这样的场景即退化为Basic Paxos。--><p>Paxos确实很强大，而且也可以应用于实际工程中，但是其理论真的很难理解，于是<em>Raft算法</em>出现了，以简单著称，并在工业上也得到了广泛的使用。</p><h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><p>Raft也是两阶段提交算法，类似于Multi-Paxos。算法中的角色分为Leader、Follower和Candidate，但是<em>这三种角色并不是同时出现的，正常运行时只有Leader和Follower</em>，candidate只作为选举leader时的一个临时角色出现。</p><ul><li>Leader: 接受客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后告诉Follower提交日志。</li><li>Follower: 接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志。</li><li>Candidate: Leader选举过程中的临时角色。</li></ul><blockquote><p>系统在初始化时，同为Follower，在election timeout之后(各节点在150-300ms之间随机)，由Follower转化为Candidate进行选举Leader</p></blockquote><!-- heartbeat timeout 之后Follower感知到Leader消失，进行新Leader选举--><p>Raft算法主要用于管理多副本状态机的日志复制，并且其<em>将一致性分解为多个子问题</em>：Leader选举(Leader election)、日志同步(Log replication)、安全性(Safety)、日志压缩(Log compaction)、成员变更(Membership change)等。同时，<em>Raft算法使用了更强的假设来减少了需要考虑的状态，使之变的易于理解和实现</em>。Raft算法支持最大的容错故障节点是F，集群总数为2F+1。</p><p>个人感觉Raft算法学习的最好教程是<a href="http://thesecretlivesofdata.com/raft/#home">http://thesecretlivesofdata.com/raft/#home</a>，俗话说一图胜千言，更何况是还是个动图，老牛逼了，保管你看一遍就懂了。。。这里就不再进行过多的介绍了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/31780743">https://zhuanlan.zhihu.com/p/31780743</a><br><a href="https://my.oschina.net/ittrueman/blog/1612492">https://my.oschina.net/ittrueman/blog/1612492</a><br><a href="http://thesecretlivesofdata.com/raft/#home">http://thesecretlivesofdata.com/raft/#home</a><br><a href="https://zhuanlan.zhihu.com/p/32052223">https://zhuanlan.zhihu.com/p/32052223</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;分布式系统中有个著名的原则CAP原则，C为Consistency(一致性)、A为Availability(可用性)、P为Partition tolerance(分区容错性)。这里主要介绍下分布式环境下如果达到一致性。&lt;/p&gt;
&lt;p&gt;说到一致性不得不说下经典的拜占庭问题。&lt;/p&gt;</summary>
    
    
    
    <category term="BlockChain" scheme="http://yuanba.tech/categories/BlockChain/"/>
    
    
    <category term="BlockChain" scheme="http://yuanba.tech/tags/BlockChain/"/>
    
    <category term="Kafka" scheme="http://yuanba.tech/tags/Kafka/"/>
    
    <category term="Zookeeper" scheme="http://yuanba.tech/tags/Zookeeper/"/>
    
    <category term="Paxos" scheme="http://yuanba.tech/tags/Paxos/"/>
    
    <category term="Raft" scheme="http://yuanba.tech/tags/Raft/"/>
    
    <category term="BFT" scheme="http://yuanba.tech/tags/BFT/"/>
    
  </entry>
  
  <entry>
    <title>cryptozombies源码解析二</title>
    <link href="http://yuanba.tech/cryptozombies-src-parse-2.html"/>
    <id>http://yuanba.tech/cryptozombies-src-parse-2.html</id>
    <published>2019-03-04T14:30:04.000Z</published>
    <updated>2019-03-05T16:30:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://bigdatadecode.top/cryptozombies-src-parse.html">cryptozombies源码解析一</a>中对以太坊开发中的<em>事件</em>与<em>合约交互</em>进行了介绍，看过这篇文章的同学我相信对Dapp开发也有了一个初步的了解，下面我们继续学习一些智能合约开发中特性。</p><span id="more"></span><h2 id="如何减少gas"><a href="#如何减少gas" class="headerlink" title="如何减少gas"></a>如何减少gas</h2><p>gas是EVM中代码执行所消耗资源的计量单位，gas是需要用以太币购买的，现在你是不是已经get到了为什么要减少gas了，嘿嘿。。。</p><h3 id="使用合适的数据结构"><a href="#使用合适的数据结构" class="headerlink" title="使用合适的数据结构"></a>使用合适的数据结构</h3><p>这里以uint为例，在Solidity中除了有基本版的uint外，还有其他变种uint：uint8，uint16，uint32等。通常情况下我们不会考虑使用uint变种，<em>因为无论如何定义 uint的大小，Solidity为它保留256位的存储空间</em>。例如，使用uint8而不使用uint(uint256)，并不会为你节省任何gas，因为Solidity始终保留了256的空间。</p><p>那么为什么还要有其他uint的变种呢？<strong>是因为在struct里，可以通过声明具体的uint变种来节省存储空间</strong>。<br>在struct里，相同类型的uint要紧邻，例如uint8的变量要放在一起，uint16的要放在一起，这样可以将这些uint打包在一起，从而占用较少的存储空间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Zombie &#123;</span><br><span class="line">  string name;</span><br><span class="line">  uint dna;</span><br><span class="line">  uint32 level;</span><br><span class="line">  uint32 readyTime;</span><br><span class="line">  uint16 winCount;</span><br><span class="line">  uint16 lossCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意view和pure的使用场景"><a href="#注意view和pure的使用场景" class="headerlink" title="注意view和pure的使用场景"></a>注意view和pure的使用场景</h3><p>之所以要注意view和pure的使用场景，是<strong>因为从合约外部调用这两个修饰符修饰的函数的时候不花费任何gas</strong>，注意这里说的是在合约外部调用，<strong>它们在被内部其他函数调用的时候将会耗费gas</strong><!--，因为一个view函数在另一个函数的内部被调用，而调用函数与view函数的不属于同一个合约，也会产生调用成本。这是因为如果主调函数在以太坊创建了一个事务，它仍然需要逐个节点去验证。所以标记为view的函数只有在外部调用时才是免费的-->。</p><p>下面解释下为什么view和pure从合约外部调用不需要花费gas。<br>是因为<em>view修饰符的意思是不会改变区块链上的任何数据，只是从区块链上读取数据</em>。标记为view的函数，意味着告诉web3.js，运行这个函数只需要查询你的本地以太坊节点，而不需要在区块链上创建一个事务(事务需要运行在每个节点上，因此花费gas)。<br>所以在所有能只读的函数上标记上表示<code>只读</code>的<code>external view</code>声明，就能为你的玩家减少在DApp中gas用量。</p><p>pure与view类似，<em>pure修饰符的意思是不但不会往区块链写数据，它甚至不从区块链读取数据</em>，所以pure也不会消耗gas。</p><h3 id="尽可能的规避昂贵的操作"><a href="#尽可能的规避昂贵的操作" class="headerlink" title="尽可能的规避昂贵的操作"></a>尽可能的规避昂贵的操作</h3><p><strong>Solidity中使用storage(存储)是相当昂贵的，”写入”操作尤其贵</strong>。这是因为，无论是写入还是更改一段数据，这都将永久性地写入区块链。”永久性”啊！需要在全球数千个节点的硬盘上存入这些数据，随着区块链的增长，拷贝份数更多，存储量也就越大。这是需要成本的！</p><p>所以在开发中，为了降低成本，不到万不得已，避免将数据写入存储。虽然这样做会导致效率低下，但是在有些场景下还是可取的。</p><p>代码中有一个<code>getZombiesByOwner</code>的函数，功能是得到某个用户的僵尸军团，常规逻辑是在<code>ZombieFactory</code>中存入<em>owner</em>与<em>zombies</em>的映射<code>mapping (address =&gt; uint[]) public ownerToZombies</code>，然后我们每次创建新僵尸时，执行<code>ownerToZombies[owner].push(zombieId)</code>将其添加到主人的僵尸数组中。而 <code>getZombiesByOwner</code>函数也非常简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getZombiesByOwner</span>(<span class="params">address _owner</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ownerToZombies[_owner];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可是如果我们需要一个函数来把一头僵尸转移到另一个主人名下，又会发生什么？<br>这个”换主”函数要做到：</p><ol><li>将僵尸push到新主人的<code>ownerToZombies</code>映射中的数组， </li><li>从旧主的<code>ownerToZombies</code>数组中移除僵尸， </li><li>将旧主僵尸数组中”换主僵尸”之后的的每头僵尸都往前挪一位，把挪走”换主僵尸”后留下的”空槽”填上， </li><li>将数组长度减1。<br>但是<em>第三步实在是太贵了</em>！<em>因为每挪动一头僵尸，我们都要执行一次写操作</em>。如果一个主人有20头僵尸，而第一头被挪走了，那为了保持数组的顺序，我们得做19个写操作。<br>由于<em>写入存储是Solidity中最费gas的操作之一</em>，使得换主函数的每次调用都非常昂贵。更糟糕的是，每次调用的时候花费的gas都不同！具体还取决于用户在原主军团中的僵尸头数，以及移走的僵尸所在的位置。以至于用户都不知道应该支付多少gas。</li></ol><blockquote><p>注意：当然，我们也可以把数组中最后一个僵尸往前挪来填补空槽，并将数组长度减少一。但这样每做一笔交易，都会改变僵尸军团的秩序。</p></blockquote><p>此时我们就应该避免这种高昂的操作，使用另一种方案来解决。上面提到view修饰的函数从外部调用是免费的，而且我们也只是从区块链中读取数据，所以我们可以在<code>getZombiesByOwner</code>函数中一个for循环遍历整个僵尸数组<code>zombies</code>，把属于某个主人的僵尸挑出来构建出僵尸数组。那么我们的transfer函数将会便宜得多，因为我们不需要挪动存储里的僵尸数组重新排序，总体上这个方法会更便宜，就是有点反常。</p><blockquote><p>在大多数编程语言中，遍历大数据集合都是昂贵的。但是在Solidity中，使用一个标记了<code>external view</code>的函数，遍历比storage要便宜太多，因为view函数不会产生任何花销。 （gas可是真金白银啊！）。</p></blockquote><p>最后<code>getZombiesByOwner</code>的实现为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function getZombiesByOwner(address _owner) external view returns(uint[]) &#123;</span><br><span class="line">  uint[] memory result = new uint[](ownerZombieCount[_owner]);</span><br><span class="line">  uint counter = 0;</span><br><span class="line">  for (uint i = 0; i &lt; zombies.length; i++) &#123;</span><br><span class="line">    if (zombieToOwner[i] == _owner) &#123;</span><br><span class="line">      result[counter] = i;</span><br><span class="line">      counter++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>相信大家在日常开发中免不了用随机数，但是在区块链中如何使用随机数呢？区块链中的随机数与传统程序中的随机数不一样是因为，区块链是一个分布式执行环境，并且为了不可篡改性，需要n台机器在同一时刻的执行结果是一样的，也就是说在同一时刻随机数是一样的。</p><p>Solidity中最好的随机数生成器是<code>keccak256</code>哈希函数。<br>我们可以这样来生成一些随机数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成一个0到100的随机数:</span></span><br><span class="line">uint randNonce = <span class="number">0</span>;</span><br><span class="line">uint random = uint(keccak256(now, msg.sender, randNonce)) % <span class="number">100</span>;</span><br><span class="line">randNonce++;</span><br><span class="line">uint random2 = uint(keccak256(now, msg.sender, randNonce)) % <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>这个方法首先拿到now的时间戳、msg.sender、以及一个自增数nonce(一个仅会被使用一次的数，这样我们就不会对相同的输入值调用一次以上哈希函数了)。<br>然后利用<code>keccak</code>把输入的值转变为一个哈希值, 再将哈希值转换为uint, 然后利用<code>%100</code>来取最后两位, 就生成了一个0到100之间随机数了。</p><blockquote><p>这个方法很容易被不诚实的节点攻击</p></blockquote><p>不诚实节点是利用随机函数进行攻击的，假设我们有一个硬币翻转合约–正面你赢双倍钱，反面你输掉所有的钱。假如它使用上面的方法来决定是正面还是反面(random&gt;=50算正面, random&lt;50算反面)。<br>此时如果我正运行一个节点，我可以只对我自己的节点发布一个事务，<em>且不分享它</em>。我可以运行硬币翻转方法来偷窥我的输赢。<br>如果我输了，我就不把这个事务包含进我要解决的下一个区块中去。我可以一直运行这个方法，直到我赢得了硬币翻转并解决了下一个区块，然后获利。</p><p>当然，因为网络上成千上万的以太坊节点都在竞争解决下一个区块，我能成功解决下一个区块的几率非常之低。这将花费我们巨大的计算资源来开发这个获利方法，但是如果奖励异常地高(比如我可以在硬币翻转函数中赢得1个亿)，那就很值得去攻击了。</p><p>所以尽管这个方法在以太坊上不安全，在实际中，除非我们的随机函数有一大笔钱在上面，你游戏的用户一般是没有足够的资源去攻击的。</p><p>因此我们决定接受这个不足之处，使用这个简单的随机数生成函数。但是要谨记它是不安全的。</p><!--在以太坊上，当你在一个合约上调用函数的时候，你会把它广播给一个节点或者在网络上的transaction节点们。网络上的节点将收集很多事务，试着成为第一个解决计算密集型数学问题的人，作为"工作证明"，然后将"工作证明"(Proof of Work, PoW)和事务一起作为一个block发布在网络上。一旦一个节点解决了一个PoW, 其他节点就会停止尝试解决这个PoW，并验证其他节点的事务列表是有效的，然后接受这个节点转而尝试解决下一个节点。--><p>游戏中的随机函数应用在与其它僵尸打架的场景上，用来决定是否取胜，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.19</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./zombiehelper.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line">contract ZombieBattle is ZombieHelper &#123;</span><br><span class="line">  uint randNonce = <span class="number">0</span>;</span><br><span class="line">  uint attackVictoryProbability = <span class="number">70</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">randMod</span>(<span class="params">uint _modulus</span>) <span class="title">internal</span> <span class="title">returns</span>(<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    randNonce++;</span><br><span class="line">    <span class="keyword">return</span> uint(keccak256(now, msg.sender, randNonce)) % _modulus;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">attack</span>(<span class="params">uint _zombieId, uint _targetId</span>) <span class="title">external</span> <span class="title">ownerOf</span>(<span class="params">_zombieId</span>) </span>&#123;</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    Zombie storage enemyZombie = zombies[_targetId];</span><br><span class="line">    uint rand = randMod(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span> (rand &lt;= attackVictoryProbability) &#123;</span><br><span class="line">      myZombie.winCount++;</span><br><span class="line">      myZombie.level++;</span><br><span class="line">      enemyZombie.lossCount++;</span><br><span class="line">      feedAndMultiply(_zombieId, enemyZombie.dna, <span class="string">&quot;zombie&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      myZombie.lossCount++;</span><br><span class="line">      enemyZombie.winCount++;</span><br><span class="line">      _triggerCooldown(myZombie);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="订阅事件"><a href="#订阅事件" class="headerlink" title="订阅事件"></a>订阅事件</h2><p>一个完整可用的DApp除了智能合约必然也会包括前端应用，这样才能够更方便的让用户使用，那么前端应用如何及时的感知合约上的变化呢？答案是通过<em>订阅事件</em>。</p><p><a href="http://bigdatadecode.top/cryptozombies-src-parse.html">cryptozombies源码解析一</a>中zombiefactory.sol有个事件<code>NewZombie</code>，每次新建一个僵尸之后，都会触发这个时间，那么我们可以在前端中通过Web3.js订阅一个事件，这样Web3提供者就可以在每次事件发生后触发一些代码逻辑，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cryptoZombies.events.NewZombie()</span><br><span class="line">.on(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> zombie = event.returnValues;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;一个新僵尸诞生了！&quot;</span>, zombie.zombieId, zombie.name, zombie.dna);</span><br><span class="line">&#125;).on(<span class="string">&#x27;error&#x27;</span>, <span class="built_in">console</span>.error);</span><br></pre></td></tr></table></figure><p><code>NewZombie</code>事件在每个新建僵尸的时候都会调用，而上述代码是监听<code>NewZombie</code>的每次触发，所以无论谁的僵尸新建我都会收到一次弹窗信息，这对我可很不友好，我只关心我当自己的僵尸军团增加成员时提醒我，这个怎么实现呢？</p><blockquote><p>indexed关键字可用于过滤event </p></blockquote><p>为了筛选仅和当前用户相关的事件，Solidity合约必须使用<code>indexed</code>关键字，就像我们在ERC721实现中的<code>Transfer</code>事件中那样：<br><code>event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);</code><br>在这种情况下，因为_from和_to都是indexed，这就意味着我们可以在前端事件监听中过滤事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cryptoZombies.events.Transfer(&#123; <span class="attr">filter</span>: &#123; <span class="attr">_to</span>: userAccount &#125; &#125;)</span><br><span class="line">.on(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = event.returnValues;</span><br><span class="line">  <span class="comment">// 当前用户更新了一个僵尸！更新界面来显示</span></span><br><span class="line">&#125;).on(<span class="string">&#x27;error&#x27;</span>, <span class="built_in">console</span>.error);</span><br></pre></td></tr></table></figure><p>看到了吧，使用<code>event</code>和<code>indexed</code>字段对于监听合约中的更改并将其<em>反映到DApp的前端界面中是非常有用的做法</em>。</p><p>也可以查询过去的事件，查询过去事件使用<code>getPastEvents</code>方法，使用过滤器<code>fromBlock</code>和<code>toBlock</code>给Solidity一个事件日志的时间范围(“block” 在这里代表以太坊区块编号)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cryptoZombies.getPastEvents(<span class="string">&quot;NewZombie&quot;</span>, &#123; <span class="attr">fromBlock</span>: <span class="number">0</span>, <span class="attr">toBlock</span>: <span class="string">&#x27;latest&#x27;</span> &#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">events</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// events 是可以用来遍历的 `event` 对象 </span></span><br><span class="line">  <span class="comment">// 这段代码将返回给我们从开始以来创建的僵尸列表</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>有些牛逼的同学看到这里可能就想到了一个非常有趣的用例：<em>用事件来作为一种更便宜的存储</em>。但是这里的短板是，<strong>事件不能从智能合约本身读取</strong>。但是，<strong>如果你有一些数据需要永久性地记录在区块链中以便可以在应用的前端中读取，这将是一个很好的用例</strong>。这些数据不会影响智能合约向前的状态。</p><p>僵尸游戏中就有这样一个场景，<em>用事件来作为僵尸战斗的历史纪录</em>–我们可以在每次僵尸攻击别人以及有一方胜出的时候产生一个事件。智能合约不需要这些数据来计算任何接下来的事情，但是这对我们在前端向用户展示来说是非常有用的东西。</p><p>上面的示例代码是针对Web3.js最新版1.0的，此版本使用了WebSockets来订阅事件。但是，MetaMask尚且不支持最新的事件API。<br>所以现在我们必须使用一个单独Web3提供者，它针对事件提供了WebSockets支持。 我们可以用Infura来像实例化第二份拷贝：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> web3Infura = <span class="keyword">new</span> Web3(<span class="keyword">new</span> Web3.providers.WebsocketProvider(<span class="string">&quot;wss://mainnet.infura.io/ws&quot;</span>));</span><br><span class="line"><span class="keyword">var</span> czEvents = <span class="keyword">new</span> web3Infura.eth.Contract(cryptoZombiesABI, cryptoZombiesAddress);</span><br></pre></td></tr></table></figure><p>然后我们将使用<code>czEvents.events.Transfer</code>来监听事件，而不再使用<code>cryptoZombies.events.Transfer</code>。</p><p>这是我跟完这个教程之后的一些总结吧，还有一些内容没有总结，随后有时间再总结下，项目的源代码可从<a href="https://github.com/hunshenshi/cryptozombies">github</a>上浏览。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://bigdatadecode.top/cryptozombies-src-parse.html&quot;&gt;cryptozombies源码解析一&lt;/a&gt;中对以太坊开发中的&lt;em&gt;事件&lt;/em&gt;与&lt;em&gt;合约交互&lt;/em&gt;进行了介绍，看过这篇文章的同学我相信对Dapp开发也有了一个初步的了解，下面我们继续学习一些智能合约开发中特性。&lt;/p&gt;</summary>
    
    
    
    <category term="BlockChain" scheme="http://yuanba.tech/categories/BlockChain/"/>
    
    
    <category term="BlockChain" scheme="http://yuanba.tech/tags/BlockChain/"/>
    
    <category term="Ethereum" scheme="http://yuanba.tech/tags/Ethereum/"/>
    
    <category term="crypto" scheme="http://yuanba.tech/tags/crypto/"/>
    
    <category term="cryptozombies" scheme="http://yuanba.tech/tags/cryptozombies/"/>
    
  </entry>
  
</feed>
